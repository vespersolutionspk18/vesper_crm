import { inject as Ao, provide as To, shallowRef as Io, watchEffect as de, readonly as ta, customRef as Oo, ref as B, computed as A, watch as J, nextTick as ne, getCurrentScope as Is, onScopeDispose as Os, effectScope as ko, unref as o, toRef as Mo, onBeforeUnmount as fn, getCurrentInstance as st, onMounted as ae, shallowReactive as co, Fragment as xe, defineComponent as _, toRefs as te, renderSlot as C, onBeforeUpdate as ks, onUpdated as Ms, toHandlerKey as Vs, camelize as Vo, onUnmounted as De, mergeProps as k, h as nt, Comment as Fs, cloneVNode as Ls, openBlock as g, createBlock as w, withCtx as m, createVNode as j, createCommentVNode as re, withKeys as he, Teleport as At, normalizeProps as N, guardReactiveProps as K, normalizeStyle as ge, reactive as Fo, withModifiers as ye, createElementBlock as fe, withDirectives as xa, vShow as vn, createElementVNode as He, toDisplayString as ke, createTextVNode as me, mergeDefaults as Lo, renderList as mn, markRaw as po, resolveDynamicComponent as Ge, isRef as yt, toHandlers as No, onBeforeMount as zo, vModelSelect as Ns, useSlots as Ko, toRaw as zs } from "vue";
import { CalendarDateTime as Ho, CalendarDate as Ks, getLocalTimeZone as Pa, ZonedDateTime as Hs, parseZonedDateTime as Ws, parseDateTime as js, parseDate as Gs, toCalendar as Us, getDayOfWeek as Wo, startOfMonth as an, endOfMonth as qs, DateFormatter as Xe, today as Ys, isEqualDay as Re, isSameDay as Se, isSameMonth as hn, isToday as jo } from "@internationalized/date";
import { useFloating as Xs, autoUpdate as Zs, offset as Js, flip as fo, shift as Qs, limitShift as er, size as tr, arrow as ar, hide as nr } from "@floating-ui/vue";
function q(a, t) {
  const e = typeof a == "string" && !t ? `${a}Context` : t, n = Symbol(e);
  return [(r) => {
    const i = Ao(n, r);
    if (i || i === null)
      return i;
    throw new Error(
      `Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(a) ? `one of the following components: ${a.join(
        ", "
      )}` : `\`${a}\``}`
    );
  }, (r) => (To(n, r), r)];
}
function yn(a, t, e) {
  const n = e.originalEvent.target, l = new CustomEvent(a, {
    bubbles: !1,
    cancelable: !0,
    detail: e
  });
  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);
}
const aa = typeof document < "u";
function or(a, t) {
  if (a.length !== t.length)
    return !1;
  for (let e = 0; e < a.length; e++)
    if (a[e] !== t[e])
      return !1;
  return !0;
}
function lr(a, t) {
  const e = [];
  for (let n = 0; n < a.length; n += t)
    e.push(a.slice(n, n + t));
  return e;
}
function Tt(a) {
  const { defaultValue: t, defaultPlaceholder: e, granularity: n = "day" } = a;
  if (Array.isArray(t) && t.length)
    return t.at(-1).copy();
  if (t && !Array.isArray(t))
    return t.copy();
  if (e)
    return e.copy();
  const l = /* @__PURE__ */ new Date(), s = l.getFullYear(), r = l.getMonth() + 1, i = l.getDate();
  return ["hour", "minute", "second"].includes(n ?? "day") ? new Ho(s, r, i, 0, 0, 0) : new Ks(s, r, i);
}
function Ut(a, t) {
  let e;
  return na(t) ? e = Ws(a) : Go(t) ? e = js(a) : e = Gs(a), e.calendar !== t.calendar ? Us(e, t.calendar) : e;
}
function Ve(a, t = Pa()) {
  return na(a) ? a.toDate() : a.toDate(t);
}
function Go(a) {
  return a instanceof Ho;
}
function na(a) {
  return a instanceof Hs;
}
function qt(a) {
  return Go(a) || na(a);
}
function ba(a) {
  if (a instanceof Date) {
    const t = a.getFullYear(), e = a.getMonth() + 1;
    return new Date(t, e, 0).getDate();
  } else
    return a.set({ day: 100 }).day;
}
function Be(a, t) {
  return a.compare(t) < 0;
}
function Rt(a, t) {
  return a.compare(t) > 0;
}
function sr(a, t) {
  return a.compare(t) <= 0;
}
function rr(a, t) {
  return a.compare(t) >= 0;
}
function ir(a, t, e) {
  return rr(a, t) && sr(a, e);
}
function ur(a, t, e) {
  return Rt(a, t) && Be(a, e);
}
function dr(a, t, e) {
  const n = Wo(a, e);
  return t > n ? a.subtract({ days: n + 7 - t }) : t === n ? a : a.subtract({ days: n - t });
}
function cr(a, t, e) {
  const n = Wo(a, e), l = t === 0 ? 6 : t - 1;
  return n === l ? a : n > l ? a.add({ days: 7 - n + l }) : a.add({ days: l - n });
}
function Uo(a, t, e, n) {
  if (e === void 0 && n === void 0)
    return !0;
  let l = a.add({ days: 1 });
  if (n != null && n(l) || e != null && e(l))
    return !1;
  const s = t;
  for (; l.compare(s) < 0; )
    if (l = l.add({ days: 1 }), n != null && n(l) || e != null && e(l))
      return !1;
  return !0;
}
function vo(a, t) {
  const e = [];
  let n = a.add({ days: 1 });
  const l = t;
  for (; n.compare(l) < 0; )
    e.push(n), n = n.add({ days: 1 });
  return e;
}
function Ga(a) {
  const { dateObj: t, weekStartsOn: e, fixedWeeks: n, locale: l } = a, s = ba(t), r = Array.from({ length: s }, (x, P) => t.set({ day: P + 1 })), i = an(t), u = qs(t), d = dr(i, e, l), p = cr(u, e, l), c = vo(d.subtract({ days: 1 }), i), f = vo(u, p.add({ days: 1 })), v = c.length + r.length + f.length;
  if (n && v < 42) {
    const x = 42 - v;
    let P = f[f.length - 1];
    P || (P = t.add({ months: 1 }).set({ day: 1 }));
    const $ = Array.from({ length: x }, (b, S) => {
      const D = S + 1;
      return P.add({ days: D });
    });
    f.push(...$);
  }
  const y = c.concat(r, f), h = lr(y, 7);
  return {
    value: t,
    cells: y,
    rows: h
  };
}
function qo(a) {
  const { dateObj: t, startIndex: e, endIndex: n, minValue: l, maxValue: s } = a;
  return Array.from({ length: Math.abs(e ?? 0) + n }, (i, u) => u <= Math.abs(e ?? 0) ? t.subtract({ years: u }).set({ day: 1, month: 1 }) : t.add({ years: u - n }).set({ day: 1, month: 1 })).toSorted((i, u) => i.year - u.year).filter((i) => !(l && Be(i, l) || s && Rt(i, s)));
}
function Yo(a) {
  const { dateObj: t, numberOfMonths: e, pagedNavigation: n, minValue: l, maxValue: s } = a;
  return e && n ? Array.from({ length: Math.floor(12 / e) }, (u, d) => an(t.set({ month: d * e + 1 }))).filter((u) => !(l && Be(u, l) || s && Rt(u, s))) : Array.from({ length: 12 }, (i, u) => an(t.set({ month: u + 1 }))).filter((i) => !(l && Be(i, l) || s && Rt(i, s)));
}
function ia(a) {
  const { numberOfMonths: t, dateObj: e, ...n } = a, l = [];
  if (!t || t === 1)
    return l.push(
      Ga({
        ...n,
        dateObj: e
      })
    ), l;
  l.push(
    Ga({
      ...n,
      dateObj: e
    })
  );
  for (let s = 1; s < t; s++) {
    const r = e.add({ months: s });
    l.push(
      Ga({
        ...n,
        dateObj: r
      })
    );
  }
  return l;
}
const pr = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
], fr = ["year", "month", "day"], Ua = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "ዓዓዓዓ", month: "ሚሜ", day: "ቀቀ" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "سنة", month: "شهر", day: "يوم" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "гггг", month: "мм", day: "дд" },
  bg: { year: "гггг", month: "мм", day: "дд" },
  bn: { year: "yyyy", month: "মিমি", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "ساڵ", month: "مانگ", day: "ڕۆژ" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "åååå", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "źź" },
  el: { year: "εεεε", month: "μμ", day: "ηη" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "سال", month: "ماه", day: "روز" },
  ff: { year: "hhhh", month: "ll", day: "ññ" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "שנה", month: "חודש", day: "יום" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "éééé", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: " 年 ", month: "月", day: "日" },
  ka: { year: "წწწწ", month: "თთ", day: "რრ" },
  kk: { year: "жжжж", month: "аа", day: "кк" },
  kn: { year: "ವವವವ", month: "ಮಿಮೀ", day: "ದಿದಿ" },
  ko: { year: "연도", month: "월", day: "일" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "ປປປປ", month: "ດດ", day: "ວວ" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "വർഷം", month: "മാസം", day: "തീയതി" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "åååå", month: "mm", day: "dd" },
  no: { year: "åååå", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "гггг", month: "мм", day: "дд" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "гггг", month: "мм", day: "дд" },
  sv: { year: "åååå", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "сссс", month: "мм", day: "рр" },
  th: { year: "ปปปป", month: "ดด", day: "วว" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "рррр", month: "мм", day: "дд" },
  "zh-CN": { year: "年", month: "月", day: "日" },
  "zh-TW": { year: "年", month: "月", day: "日" }
};
function vr(a) {
  if (mo(a))
    return Ua[a];
  {
    const t = gr(a);
    return mo(t) ? Ua[t] : Ua.en;
  }
}
function qa(a, t, e) {
  return mr(a) ? vr(e)[a] : yr(a) ? t : hr(a) ? "––" : "";
}
function mo(a) {
  return pr.includes(a);
}
function mr(a) {
  return fr.includes(a);
}
function hr(a) {
  return a === "hour" || a === "minute" || a === "second";
}
function yr(a) {
  return a === "era" || a === "dayPeriod";
}
function gr(a) {
  return Intl.Locale ? new Intl.Locale(a).language : a.split("-")[0];
}
const gn = ["day", "month", "year"], Xo = ["hour", "minute", "second", "dayPeriod"], Zo = [...gn, ...Xo];
function br(a) {
  return gn.includes(a);
}
function Jo(a) {
  return Zo.includes(a);
}
function Cr(a, t) {
  const e = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: t === 24 ? "h24" : void 0,
    hour12: t === 24 ? !1 : void 0
  };
  return a === "day" && (delete e.second, delete e.hour, delete e.minute, delete e.timeZoneName), a === "hour" && (delete e.minute, delete e.second), a === "minute" && delete e.second, e;
}
function Qo(a) {
  const t = a.querySelector("[data-selected]");
  if (t)
    return t.focus();
  const e = a.querySelector("[data-today]");
  if (e)
    return e.focus();
  const n = a.querySelector("[data-radix-vue-calendar-day]");
  if (n)
    return n.focus();
}
function _r(a, t) {
  var e;
  const n = Io();
  return de(() => {
    n.value = a();
  }, {
    ...t,
    flush: (e = t == null ? void 0 : t.flush) != null ? e : "sync"
  }), ta(n);
}
function rt(a) {
  return Is() ? (Os(a), !0) : !1;
}
function wr() {
  const a = /* @__PURE__ */ new Set(), t = (l) => {
    a.delete(l);
  };
  return {
    on: (l) => {
      a.add(l);
      const s = () => t(l);
      return rt(s), {
        off: s
      };
    },
    off: t,
    trigger: (...l) => Promise.all(Array.from(a).map((s) => s(...l)))
  };
}
function xr(a) {
  let t = !1, e;
  const n = ko(!0);
  return (...l) => (t || (e = n.run(() => a(...l)), t = !0), e);
}
function Pr(a) {
  let t = 0, e, n;
  const l = () => {
    t -= 1, n && t <= 0 && (n.stop(), e = void 0, n = void 0);
  };
  return (...s) => (t += 1, e || (n = ko(!0), e = n.run(() => a(...s))), rt(l), e);
}
function Ne(a) {
  return typeof a == "function" ? a() : o(a);
}
const Ue = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Sr = (a) => typeof a < "u", Dr = (a) => a != null, $r = Object.prototype.toString, Er = (a) => $r.call(a) === "[object Object]", ho = (a, t, e) => Math.min(e, Math.max(t, a)), Yt = () => {
}, yo = /* @__PURE__ */ Br();
function Br() {
  var a, t;
  return Ue && ((a = window == null ? void 0 : window.navigator) == null ? void 0 : a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Rr(a, t) {
  function e(...n) {
    return new Promise((l, s) => {
      Promise.resolve(a(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(l).catch(s);
    });
  }
  return e;
}
function Ar(a, t = {}) {
  let e, n, l = Yt;
  const s = (i) => {
    clearTimeout(i), l(), l = Yt;
  };
  return (i) => {
    const u = Ne(a), d = Ne(t.maxWait);
    return e && s(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (s(n), n = null), Promise.resolve(i())) : new Promise((p, c) => {
      l = t.rejectOnCancel ? c : p, d && !n && (n = setTimeout(() => {
        e && s(e), n = null, p(i());
      }, d)), e = setTimeout(() => {
        n && s(n), n = null, p(i());
      }, u);
    });
  };
}
function Tr(a) {
  return a || st();
}
function Ir(...a) {
  if (a.length !== 1)
    return Mo(...a);
  const t = a[0];
  return typeof t == "function" ? ta(Oo(() => ({ get: t, set: Yt }))) : B(t);
}
function Sa(a, t = 1e4) {
  return Oo((e, n) => {
    let l = Ne(a), s;
    const r = () => setTimeout(() => {
      l = Ne(a), n();
    }, Ne(t));
    return rt(() => {
      clearTimeout(s);
    }), {
      get() {
        return e(), l;
      },
      set(i) {
        l = i, n(), clearTimeout(s), s = r();
      }
    };
  });
}
function bn(a, t = 200, e = {}) {
  return Rr(
    Ar(t, e),
    a
  );
}
function Or(a, t) {
  Tr(t) && fn(a, t);
}
function Cn(a, t, e = {}) {
  const {
    immediate: n = !0
  } = e, l = B(!1);
  let s = null;
  function r() {
    s && (clearTimeout(s), s = null);
  }
  function i() {
    l.value = !1, r();
  }
  function u(...d) {
    r(), l.value = !0, s = setTimeout(() => {
      l.value = !1, s = null, a(...d);
    }, Ne(t));
  }
  return n && (l.value = !0, Ue && u()), rt(i), {
    isPending: ta(l),
    start: u,
    stop: i
  };
}
function kr(a = 1e3, t = {}) {
  const {
    controls: e = !1,
    callback: n
  } = t, l = Cn(
    n ?? Yt,
    a,
    t
  ), s = A(() => !l.isPending.value);
  return e ? {
    ready: s,
    ...l
  } : s;
}
function Mr(a, t, e) {
  const n = J(a, (...l) => (ne(() => n()), t(...l)), e);
  return n;
}
function Ae(a) {
  var t;
  const e = Ne(a);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const It = Ue ? window : void 0;
function ot(...a) {
  let t, e, n, l;
  if (typeof a[0] == "string" || Array.isArray(a[0]) ? ([e, n, l] = a, t = It) : [t, e, n, l] = a, !t)
    return Yt;
  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);
  const s = [], r = () => {
    s.forEach((p) => p()), s.length = 0;
  }, i = (p, c, f, v) => (p.addEventListener(c, f, v), () => p.removeEventListener(c, f, v)), u = J(
    () => [Ae(t), Ne(l)],
    ([p, c]) => {
      if (r(), !p)
        return;
      const f = Er(c) ? { ...c } : c;
      s.push(
        ...e.flatMap((v) => n.map((y) => i(p, v, y, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    u(), r();
  };
  return rt(d), d;
}
function Vr(a) {
  return typeof a == "function" ? a : typeof a == "string" ? (t) => t.key === a : Array.isArray(a) ? (t) => a.includes(t.key) : () => !0;
}
function _n(...a) {
  let t, e, n = {};
  a.length === 3 ? (t = a[0], e = a[1], n = a[2]) : a.length === 2 ? typeof a[1] == "object" ? (t = !0, e = a[0], n = a[1]) : (t = a[0], e = a[1]) : (t = !0, e = a[0]);
  const {
    target: l = It,
    eventName: s = "keydown",
    passive: r = !1,
    dedupe: i = !1
  } = n, u = Vr(t);
  return ot(l, s, (p) => {
    p.repeat && Ne(i) || u(p) && e(p);
  }, r);
}
function Fr(a = {}) {
  var t;
  const {
    window: e = It,
    deep: n = !0
  } = a, l = (t = a.document) != null ? t : e == null ? void 0 : e.document, s = () => {
    var u;
    let d = l == null ? void 0 : l.activeElement;
    if (n)
      for (; d != null && d.shadowRoot; )
        d = (u = d == null ? void 0 : d.shadowRoot) == null ? void 0 : u.activeElement;
    return d;
  }, r = B(), i = () => {
    r.value = s();
  };
  return e && (ot(e, "blur", (u) => {
    u.relatedTarget === null && i();
  }, !0), ot(e, "focus", i, !0)), i(), r;
}
function Da() {
  const a = B(!1), t = st();
  return t && ae(() => {
    a.value = !0;
  }, t), a;
}
function el(a) {
  const t = Da();
  return A(() => (t.value, !!a()));
}
function Lr(a, t = {}) {
  const {
    immediate: e = !0,
    fpsLimit: n = void 0,
    window: l = It
  } = t, s = B(!1), r = n ? 1e3 / n : null;
  let i = 0, u = null;
  function d(f) {
    if (!s.value || !l)
      return;
    i || (i = f);
    const v = f - i;
    if (r && v < r) {
      u = l.requestAnimationFrame(d);
      return;
    }
    i = f, a({ delta: v, timestamp: f }), u = l.requestAnimationFrame(d);
  }
  function p() {
    !s.value && l && (s.value = !0, i = 0, u = l.requestAnimationFrame(d));
  }
  function c() {
    s.value = !1, u != null && l && (l.cancelAnimationFrame(u), u = null);
  }
  return e && p(), rt(c), {
    isActive: ta(s),
    pause: c,
    resume: p
  };
}
function Nr(a) {
  return JSON.parse(JSON.stringify(a));
}
function zr(a, t, e = {}) {
  const { window: n = It, ...l } = e;
  let s;
  const r = el(() => n && "MutationObserver" in n), i = () => {
    s && (s.disconnect(), s = void 0);
  }, u = A(() => {
    const f = Ne(a), v = (Array.isArray(f) ? f : [f]).map(Ae).filter(Dr);
    return new Set(v);
  }), d = J(
    () => u.value,
    (f) => {
      i(), r.value && n && f.size && (s = new MutationObserver(t), f.forEach((v) => s.observe(v, l)));
    },
    { immediate: !0, flush: "post" }
  ), p = () => s == null ? void 0 : s.takeRecords(), c = () => {
    i(), d();
  };
  return rt(c), {
    isSupported: r,
    stop: c,
    takeRecords: p
  };
}
function We(a, t, e = {}) {
  const { window: n = It, ...l } = e;
  let s;
  const r = el(() => n && "ResizeObserver" in n), i = () => {
    s && (s.disconnect(), s = void 0);
  }, u = A(() => Array.isArray(a) ? a.map((c) => Ae(c)) : [Ae(a)]), d = J(
    u,
    (c) => {
      if (i(), r.value && n) {
        s = new ResizeObserver(t);
        for (const f of c)
          f && s.observe(f, l);
      }
    },
    { immediate: !0, flush: "post" }
  ), p = () => {
    i(), d();
  };
  return rt(p), {
    isSupported: r,
    stop: p
  };
}
function Kr(a, t = {}) {
  const e = Fr(t), n = A(() => Ae(a));
  return { focused: A(() => n.value && e.value ? n.value.contains(e.value) : !1) };
}
function tl(a, t) {
  const n = (() => t != null && t.cache ? co(t.cache) : co(/* @__PURE__ */ new Map()))(), l = (...p) => t != null && t.getKey ? t.getKey(...p) : JSON.stringify(p), s = (p, ...c) => (n.set(p, a(...c)), n.get(p)), r = (...p) => s(l(...p), ...p), i = (...p) => {
    n.delete(l(...p));
  }, u = () => {
    n.clear();
  }, d = (...p) => {
    const c = l(...p);
    return n.has(c) ? n.get(c) : s(c, ...p);
  };
  return d.load = r, d.delete = i, d.clear = u, d.generateKey = l, d.cache = n, d;
}
function Hr(a, t) {
  const e = Io(t);
  return J(
    Ir(a),
    (n, l) => {
      e.value = l;
    },
    { flush: "sync" }
  ), ta(e);
}
function Q(a, t, e, n = {}) {
  var l, s, r;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: p = !1,
    defaultValue: c,
    shouldEmit: f
  } = n, v = st(), y = e || (v == null ? void 0 : v.emit) || ((l = v == null ? void 0 : v.$emit) == null ? void 0 : l.bind(v)) || ((r = (s = v == null ? void 0 : v.proxy) == null ? void 0 : s.$emit) == null ? void 0 : r.bind(v == null ? void 0 : v.proxy));
  let h = d;
  t || (t = "modelValue"), h = h || `update:${t.toString()}`;
  const x = (b) => i ? typeof i == "function" ? i(b) : Nr(b) : b, P = () => Sr(a[t]) ? x(a[t]) : c, $ = (b) => {
    f ? f(b) && y(h, b) : y(h, b);
  };
  if (u) {
    const b = P(), S = B(b);
    let D = !1;
    return J(
      () => a[t],
      (E) => {
        D || (D = !0, S.value = x(E), ne(() => D = !1));
      }
    ), J(
      S,
      (E) => {
        !D && (E !== a[t] || p) && $(E);
      },
      { deep: p }
    ), S;
  } else
    return A({
      get() {
        return P();
      },
      set(b) {
        $(b);
      }
    });
}
function $a(a) {
  return a ? a.flatMap((t) => t.type === xe ? $a(t.children) : [t]) : [];
}
const Wr = ["INPUT", "TEXTAREA"];
function Ot(a, t, e, n = {}) {
  if (!t || n.enableIgnoredElement && Wr.includes(t.nodeName))
    return null;
  const {
    arrowKeyOptions: l = "both",
    attributeName: s = "[data-radix-vue-collection-item]",
    itemsArray: r = [],
    loop: i = !0,
    dir: u = "ltr",
    preventScroll: d = !0,
    focus: p = !1
  } = n, [c, f, v, y, h, x] = [
    a.key === "ArrowRight",
    a.key === "ArrowLeft",
    a.key === "ArrowUp",
    a.key === "ArrowDown",
    a.key === "Home",
    a.key === "End"
  ], P = v || y, $ = c || f;
  if (!h && !x && (!P && !$ || l === "vertical" && $ || l === "horizontal" && P))
    return null;
  const b = e ? Array.from(e.querySelectorAll(s)) : r;
  if (!b.length)
    return null;
  d && a.preventDefault();
  let S = null;
  return $ || P ? S = al(b, t, {
    goForward: P ? y : u === "ltr" ? c : f,
    loop: i
  }) : h ? S = b.at(0) || null : x && (S = b.at(-1) || null), p && (S == null || S.focus()), S;
}
function al(a, t, { goForward: e, loop: n }, l = a.length) {
  if (--l === 0)
    return null;
  const s = a.indexOf(t), r = e ? s + 1 : s - 1;
  if (!n && (r < 0 || r >= a.length))
    return null;
  const i = (r + a.length) % a.length, u = a[i];
  return u ? u.hasAttribute("disabled") && u.getAttribute("disabled") !== "false" ? al(
    a,
    u,
    { goForward: e, loop: n },
    l
  ) : u : null;
}
function Ya(a) {
  if (a === null || typeof a != "object")
    return !1;
  const t = Object.getPrototypeOf(a);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in a ? !1 : Symbol.toStringTag in a ? Object.prototype.toString.call(a) === "[object Module]" : !0;
}
function nn(a, t, e = ".", n) {
  if (!Ya(t))
    return nn(a, {}, e, n);
  const l = Object.assign({}, t);
  for (const s in a) {
    if (s === "__proto__" || s === "constructor")
      continue;
    const r = a[s];
    r != null && (n && n(l, s, r, e) || (Array.isArray(r) && Array.isArray(l[s]) ? l[s] = [...r, ...l[s]] : Ya(r) && Ya(l[s]) ? l[s] = nn(
      r,
      l[s],
      (e ? `${e}.` : "") + s.toString(),
      n
    ) : l[s] = r));
  }
  return l;
}
function jr(a) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((e, n) => nn(e, n, "", a), {})
  );
}
const Gr = jr(), [wn, Ur] = q("ConfigProvider"), of = /* @__PURE__ */ _({
  __name: "ConfigProvider",
  props: {
    dir: { default: "ltr" },
    scrollBody: { type: [Boolean, Object], default: !0 },
    useId: { type: Function, default: void 0 }
  },
  setup(a) {
    const t = a, { dir: e, scrollBody: n } = te(t);
    return Ur({
      dir: e,
      scrollBody: n,
      useId: t.useId
    }), (l, s) => C(l.$slots, "default");
  }
});
let qr = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Yr = (a = 21) => {
  let t = "", e = a;
  for (; e--; )
    t += qr[Math.random() * 64 | 0];
  return t;
};
const Xr = Pr(() => {
  const a = B(/* @__PURE__ */ new Map()), t = B(), e = A(() => {
    for (const r of a.value.values())
      if (r)
        return !0;
    return !1;
  }), n = wn({
    scrollBody: B(!0)
  });
  let l = null;
  const s = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", yo && (l == null || l()), t.value = void 0;
  };
  return J(e, (r, i) => {
    var c;
    if (!Ue)
      return;
    if (!r) {
      i && s();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, p = (c = n.scrollBody) != null && c.value ? typeof n.scrollBody.value == "object" ? Gr({
      padding: n.scrollBody.value.padding === !0 ? u : n.scrollBody.value.padding,
      margin: n.scrollBody.value.margin === !0 ? u : n.scrollBody.value.margin
    }, d) : d : { padding: 0, margin: 0 };
    u > 0 && (document.body.style.paddingRight = `${p.padding}px`, document.body.style.marginRight = `${p.margin}px`, document.body.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), yo && (l = ot(
      document,
      "touchmove",
      (f) => {
        var v;
        f.target === document.documentElement && (f.touches.length > 1 || (v = f.preventDefault) == null || v.call(f));
      },
      { passive: !1 }
    )), ne(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, { immediate: !0, flush: "sync" }), a;
});
function oa(a) {
  const t = Yr(6), e = Xr();
  e.value.set(t, a ?? !1);
  const n = A({
    get: () => e.value.get(t) ?? !1,
    set: (l) => e.value.set(t, l)
  });
  return Or(() => {
    e.value.delete(t);
  }), n;
}
const Zr = "data-radix-vue-collection-item";
function Te(a, t = Zr) {
  const e = a ?? Symbol();
  return { createCollection: (s) => {
    const r = B([]);
    function i() {
      const u = Ae(s);
      return u ? r.value = Array.from(
        u.querySelectorAll(`[${t}]:not([data-disabled])`)
      ) : r.value = [];
    }
    return ks(() => {
      r.value = [];
    }), ae(i), Ms(i), J(() => s == null ? void 0 : s.value, i, { immediate: !0 }), To(e, r), r;
  }, injectCollection: () => Ao(e, B([])) };
}
function xn(a) {
  const t = B(a);
  function e() {
    return t.value;
  }
  function n(h) {
    t.value = h;
  }
  function l(h, x) {
    return new Xe(t.value, x).format(h);
  }
  function s(h, x = !0) {
    return qt(h) && x ? l(Ve(h), {
      dateStyle: "long",
      timeStyle: "long"
    }) : l(Ve(h), {
      dateStyle: "long"
    });
  }
  function r(h) {
    return new Xe(t.value, { month: "long", year: "numeric" }).format(h);
  }
  function i(h) {
    return new Xe(t.value, { month: "long" }).format(h);
  }
  function u() {
    const h = Ys(Pa());
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((P) => ({ label: i(Ve(h.set({ month: P }))), value: P }));
  }
  function d(h) {
    return new Xe(t.value, { year: "numeric" }).format(h);
  }
  function p(h, x) {
    return na(h) ? new Xe(t.value, {
      ...x,
      timeZone: h.timeZone
    }).formatToParts(Ve(h)) : new Xe(t.value, x).formatToParts(Ve(h));
  }
  function c(h, x = "narrow") {
    return new Xe(t.value, { weekday: x }).format(h);
  }
  function f(h) {
    var $;
    return (($ = new Xe(t.value, {
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(h).find((b) => b.type === "dayPeriod")) == null ? void 0 : $.value) === "PM" ? "PM" : "AM";
  }
  const v = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function y(h, x, P = {}) {
    const $ = { ...v, ...P }, S = p(h, $).find((D) => D.type === x);
    return S ? S.value : "";
  }
  return {
    setLocale: n,
    getLocale: e,
    fullMonth: i,
    fullYear: d,
    fullMonthAndYear: r,
    toParts: p,
    custom: l,
    part: y,
    dayPeriod: f,
    selectedDate: s,
    dayOfWeek: c,
    getMonths: u
  };
}
function Pe(a) {
  const t = wn({
    dir: B("ltr")
  });
  return A(() => {
    var e;
    return (a == null ? void 0 : a.value) || ((e = t.dir) == null ? void 0 : e.value) || "ltr";
  });
}
function $e(a) {
  const t = st(), e = t == null ? void 0 : t.type.emits, n = {};
  return e != null && e.length || console.warn(
    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`
  ), e == null || e.forEach((l) => {
    n[Vs(Vo(l))] = (...s) => a(l, ...s);
  }), n;
}
let Xa = 0;
function Pn() {
  de((a) => {
    if (!Ue)
      return;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      t[0] ?? go()
    ), document.body.insertAdjacentElement(
      "beforeend",
      t[1] ?? go()
    ), Xa++, a(() => {
      Xa === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), Xa--;
    });
  });
}
function go() {
  const a = document.createElement("span");
  return a.setAttribute("data-radix-focus-guard", ""), a.tabIndex = 0, a.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", a;
}
function gt(a) {
  return A(() => {
    var t;
    return Ne(a) ? !!((t = Ae(a)) != null && t.closest("form")) : !0;
  });
}
function bt(a) {
  const t = st(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((l, s) => {
    const r = (t == null ? void 0 : t.type.props[s]).default;
    return r !== void 0 && (l[s] = r), l;
  }, {}), n = Mo(a);
  return A(() => {
    const l = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(s).forEach((r) => {
      l[Vo(r)] = s[r];
    }), Object.keys({ ...e, ...l }).reduce((r, i) => (n.value[i] !== void 0 && (r[i] = n.value[i]), r), {});
  });
}
function be(a, t) {
  const e = bt(a), n = t ? $e(t) : {};
  return A(() => ({
    ...e.value,
    ...n
  }));
}
function R() {
  const a = st(), t = B(), e = A(() => {
    var r, i;
    return ["#text", "#comment"].includes((r = t.value) == null ? void 0 : r.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : Ae(t);
  }), n = Object.assign({}, a.exposed), l = {};
  for (const r in a.props)
    Object.defineProperty(l, r, {
      enumerable: !0,
      configurable: !0,
      get: () => a.props[r]
    });
  if (Object.keys(n).length > 0)
    for (const r in n)
      Object.defineProperty(l, r, {
        enumerable: !0,
        configurable: !0,
        get: () => n[r]
      });
  Object.defineProperty(l, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => a.vnode.el
  }), a.exposed = l;
  function s(r) {
    t.value = r, !(r instanceof Element || !r) && (Object.defineProperty(l, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => r.$el
    }), a.exposed = l);
  }
  return { forwardRef: s, currentRef: t, currentElement: e };
}
function nl(a, t) {
  const e = Sa(!1, 300), n = B(null), l = wr();
  function s() {
    n.value = null, e.value = !1;
  }
  function r(i, u) {
    const d = i.currentTarget, p = { x: i.clientX, y: i.clientY }, c = Jr(p, d.getBoundingClientRect()), f = Qr(p, c), v = ei(u.getBoundingClientRect()), y = ai([...f, ...v]);
    n.value = y, e.value = !0;
  }
  return de((i) => {
    if (a.value && t.value) {
      const u = (p) => r(p, t.value), d = (p) => r(p, a.value);
      a.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        var p, c;
        (p = a.value) == null || p.removeEventListener("pointerleave", u), (c = t.value) == null || c.removeEventListener("pointerleave", d);
      });
    }
  }), de((i) => {
    if (n.value) {
      const u = (d) => {
        var y, h;
        if (!n.value)
          return;
        const p = d.target, c = { x: d.clientX, y: d.clientY }, f = ((y = a.value) == null ? void 0 : y.contains(p)) || ((h = t.value) == null ? void 0 : h.contains(p)), v = !ti(c, n.value);
        f ? s() : v && (s(), l.trigger());
      };
      document.addEventListener("pointermove", u), i(() => document.removeEventListener("pointermove", u));
    }
  }), {
    isPointerInTransit: e,
    onPointerExit: l.on
  };
}
function Jr(a, t) {
  const e = Math.abs(t.top - a.y), n = Math.abs(t.bottom - a.y), l = Math.abs(t.right - a.x), s = Math.abs(t.left - a.x);
  switch (Math.min(e, n, l, s)) {
    case s:
      return "left";
    case l:
      return "right";
    case e:
      return "top";
    case n:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function Qr(a, t, e = 5) {
  const n = [];
  switch (t) {
    case "top":
      n.push(
        { x: a.x - e, y: a.y + e },
        { x: a.x + e, y: a.y + e }
      );
      break;
    case "bottom":
      n.push(
        { x: a.x - e, y: a.y - e },
        { x: a.x + e, y: a.y - e }
      );
      break;
    case "left":
      n.push(
        { x: a.x + e, y: a.y - e },
        { x: a.x + e, y: a.y + e }
      );
      break;
    case "right":
      n.push(
        { x: a.x - e, y: a.y - e },
        { x: a.x - e, y: a.y + e }
      );
      break;
  }
  return n;
}
function ei(a) {
  const { top: t, right: e, bottom: n, left: l } = a;
  return [
    { x: l, y: t },
    { x: e, y: t },
    { x: e, y: n },
    { x: l, y: n }
  ];
}
function ti(a, t) {
  const { x: e, y: n } = a;
  let l = !1;
  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {
    const i = t[s].x, u = t[s].y, d = t[r].x, p = t[r].y;
    u > n != p > n && e < (d - i) * (n - u) / (p - u) + i && (l = !l);
  }
  return l;
}
function ai(a) {
  const t = a.slice();
  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), ni(t);
}
function ni(a) {
  if (a.length <= 1)
    return a.slice();
  const t = [];
  for (let n = 0; n < a.length; n++) {
    const l = a[n];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], r = t[t.length - 2];
      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))
        t.pop();
      else
        break;
    }
    t.push(l);
  }
  t.pop();
  const e = [];
  for (let n = a.length - 1; n >= 0; n--) {
    const l = a[n];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1], r = e[e.length - 2];
      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))
        e.pop();
      else
        break;
    }
    e.push(l);
  }
  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);
}
var oi = function(a) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(a) ? a[0] : a;
  return t.ownerDocument.body;
}, Dt = /* @__PURE__ */ new WeakMap(), ua = /* @__PURE__ */ new WeakMap(), da = {}, Za = 0, ol = function(a) {
  return a && (a.host || ol(a.parentNode));
}, li = function(a, t) {
  return t.map(function(e) {
    if (a.contains(e))
      return e;
    var n = ol(e);
    return n && a.contains(n) ? n : (console.error("aria-hidden", e, "in not contained inside", a, ". Doing nothing"), null);
  }).filter(function(e) {
    return !!e;
  });
}, si = function(a, t, e, n) {
  var l = li(t, Array.isArray(a) ? a : [a]);
  da[e] || (da[e] = /* @__PURE__ */ new WeakMap());
  var s = da[e], r = [], i = /* @__PURE__ */ new Set(), u = new Set(l), d = function(c) {
    !c || i.has(c) || (i.add(c), d(c.parentNode));
  };
  l.forEach(d);
  var p = function(c) {
    !c || u.has(c) || Array.prototype.forEach.call(c.children, function(f) {
      if (i.has(f))
        p(f);
      else {
        var v = f.getAttribute(n), y = v !== null && v !== "false", h = (Dt.get(f) || 0) + 1, x = (s.get(f) || 0) + 1;
        Dt.set(f, h), s.set(f, x), r.push(f), h === 1 && y && ua.set(f, !0), x === 1 && f.setAttribute(e, "true"), y || f.setAttribute(n, "true");
      }
    });
  };
  return p(t), i.clear(), Za++, function() {
    r.forEach(function(c) {
      var f = Dt.get(c) - 1, v = s.get(c) - 1;
      Dt.set(c, f), s.set(c, v), f || (ua.has(c) || c.removeAttribute(n), ua.delete(c)), v || c.removeAttribute(e);
    }), Za--, Za || (Dt = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakMap(), ua = /* @__PURE__ */ new WeakMap(), da = {});
  };
}, ri = function(a, t, e) {
  e === void 0 && (e = "data-aria-hidden");
  var n = Array.from(Array.isArray(a) ? a : [a]), l = t || oi(a);
  return l ? (n.push.apply(n, Array.from(l.querySelectorAll("[aria-live]"))), si(n, l, e, "aria-hidden")) : function() {
    return null;
  };
};
function la(a) {
  let t;
  J(() => Ae(a), (e) => {
    e ? t = ri(e) : t && t();
  }), De(() => {
    t && t();
  });
}
let ii = 0;
function ve(a, t = "radix") {
  if (a)
    return a;
  const { useId: e } = wn({ useId: void 0 });
  return e && typeof e == "function" ? `${t}-${e()}` : `${t}-${++ii}`;
}
function ll(a) {
  const t = B(), e = A(() => {
    var l;
    return ((l = t.value) == null ? void 0 : l.width) ?? 0;
  }), n = A(() => {
    var l;
    return ((l = t.value) == null ? void 0 : l.height) ?? 0;
  });
  return ae(() => {
    const l = Ae(a);
    if (l) {
      t.value = { width: l.offsetWidth, height: l.offsetHeight };
      const s = new ResizeObserver((r) => {
        if (!Array.isArray(r) || !r.length)
          return;
        const i = r[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const p = i.borderBoxSize, c = Array.isArray(p) ? p[0] : p;
          u = c.inlineSize, d = c.blockSize;
        } else
          u = l.offsetWidth, d = l.offsetHeight;
        t.value = { width: u, height: d };
      });
      return s.observe(l, { box: "border-box" }), () => s.unobserve(l);
    } else
      t.value = void 0;
  }), {
    width: e,
    height: n
  };
}
function sl(a, t) {
  const e = B(a);
  function n(s) {
    return t[e.value][s] ?? e.value;
  }
  return {
    state: e,
    dispatch: (s) => {
      e.value = n(s);
    }
  };
}
function Sn(a) {
  const t = Sa("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (l) => {
      var c, f;
      t.value = t.value + l;
      const s = a.value, r = document.activeElement, i = ((f = (c = s.find((v) => v === r)) == null ? void 0 : c.textContent) == null ? void 0 : f.trim()) ?? "", u = s.map((v) => {
        var y;
        return ((y = v.textContent) == null ? void 0 : y.trim()) ?? "";
      }), d = ui(u, t.value, i), p = s.find(
        (v) => {
          var y;
          return ((y = v.textContent) == null ? void 0 : y.trim()) === d;
        }
      );
      p && p.focus();
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function Dn(a, t) {
  return a.map((e, n) => a[(t + n) % a.length]);
}
function ui(a, t, e) {
  const l = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, s = e ? a.indexOf(e) : -1;
  let r = Dn(a, Math.max(s, 0));
  l.length === 1 && (r = r.filter((d) => d !== e));
  const u = r.find(
    (d) => d.toLowerCase().startsWith(l.toLowerCase())
  );
  return u !== e ? u : void 0;
}
function lf(a, t) {
  return {
    inheritAttrs: !1,
    name: `${a.__name ?? ""}Wrapper`,
    setup(e, n) {
      return () => {
        const l = typeof (t == null ? void 0 : t.props) == "function" ? t == null ? void 0 : t.props(n.attrs) : t == null ? void 0 : t.props, { forwardRef: s } = R(), r = k(l, n.attrs);
        return nt(a, { ...r, ref: s }, n.slots);
      };
    }
  };
}
function Ct() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
const $n = _({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(a, { attrs: t, slots: e }) {
    return () => {
      var u, d;
      if (!e.default)
        return null;
      const n = $a(e.default()), l = n.findIndex((p) => p.type !== Fs);
      if (l === -1)
        return n;
      const s = n[l];
      (u = s.props) == null || delete u.ref;
      const r = s.props ? k(t, s.props) : t;
      t.class && ((d = s.props) != null && d.class) && delete s.props.class;
      const i = Ls(s, r);
      for (const p in r)
        p.startsWith("on") && (i.props || (i.props = {}), i.props[p] = r[p]);
      return n.length === 1 ? i : (n[l] = i, n);
    };
  }
}), O = _({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(a, { attrs: t, slots: e }) {
    const n = a.asChild ? "template" : a.as;
    return typeof n == "string" && ["area", "img", "input"].includes(n) ? () => nt(n, t) : n !== "template" ? () => nt(a.as, t, { default: e.default }) : () => nt($n, t, { default: e.default });
  }
});
function it() {
  const a = B(), t = A(() => {
    var e, n;
    return ["#text", "#comment"].includes((e = a.value) == null ? void 0 : e.$el.nodeName) ? (n = a.value) == null ? void 0 : n.$el.nextElementSibling : Ae(a);
  });
  return {
    primitiveElement: a,
    currentElement: t
  };
}
const [rl, di] = q("CollapsibleRoot"), ci = /* @__PURE__ */ _({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(a, { expose: t, emit: e }) {
    const n = a, s = Q(n, "open", e, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), r = Q(n, "disabled");
    return di({
      contentId: "",
      disabled: r,
      open: s,
      onOpenToggle: () => {
        s.value = !s.value;
      }
    }), t({ open: s }), R(), (i, u) => (g(), w(o(O), {
      as: i.as,
      "as-child": n.asChild,
      "data-state": n.open ? "open" : "closed",
      "data-disabled": n.disabled ? "" : void 0
    }, {
      default: m(() => [
        C(i.$slots, "default", { open: o(s) })
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state", "data-disabled"]));
  }
}), pi = /* @__PURE__ */ _({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = rl();
    return (n, l) => {
      var s, r;
      return g(), w(o(O), {
        type: n.as === "button" ? "button" : void 0,
        as: n.as,
        "as-child": t.asChild,
        "aria-controls": o(e).contentId,
        "aria-expanded": o(e).open.value,
        "data-state": o(e).open.value ? "open" : "closed",
        "data-disabled": (s = o(e).disabled) != null && s.value ? "" : void 0,
        disabled: (r = o(e).disabled) == null ? void 0 : r.value,
        onClick: o(e).onOpenToggle
      }, {
        default: m(() => [
          C(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
function fi(a, t) {
  const e = B({}), n = B("none"), l = a.value ? "mounted" : "unmounted", { state: s, dispatch: r } = sl(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  J(
    a,
    async (f, v) => {
      var h;
      const y = v !== f;
      if (await ne(), y) {
        const x = n.value, P = ca(t.value);
        f ? r("MOUNT") : P === "none" || ((h = e.value) == null ? void 0 : h.display) === "none" ? r("UNMOUNT") : r(v && x !== P ? "ANIMATION_OUT" : "UNMOUNT");
      }
    },
    { immediate: !0 }
  );
  const i = (f) => {
    const v = ca(t.value), y = v.includes(
      f.animationName
    );
    f.target === t.value && y && r("ANIMATION_END"), f.target === t.value && v === "none" && r("ANIMATION_END");
  }, u = (f) => {
    f.target === t.value && (n.value = ca(t.value));
  }, d = J(
    t,
    (f, v) => {
      f ? (e.value = getComputedStyle(f), f.addEventListener("animationstart", u), f.addEventListener("animationcancel", i), f.addEventListener("animationend", i)) : (r("ANIMATION_END"), v == null || v.removeEventListener("animationstart", u), v == null || v.removeEventListener("animationcancel", i), v == null || v.removeEventListener("animationend", i));
    },
    { immediate: !0 }
  ), p = J(s, () => {
    const f = ca(t.value);
    n.value = s.value === "mounted" ? f : "none";
  });
  return De(() => {
    d(), p();
  }), {
    isPresent: A(
      () => ["mounted", "unmountSuspended"].includes(s.value)
    )
  };
}
function ca(a) {
  return a && getComputedStyle(a).animationName || "none";
}
const we = _({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(a, { slots: t, expose: e }) {
    var d;
    const { present: n, forceMount: l } = te(a), s = B(), { isPresent: r } = fi(n, s);
    e({ present: r });
    let i = t.default({ present: r });
    i = $a(i || []);
    const u = st();
    if (i && (i == null ? void 0 : i.length) > 1) {
      const p = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${p}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((c) => `  - ${c}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => l.value || n.value || r.value ? nt(t.default({ present: r })[0], {
      ref: (p) => {
        const c = Ae(p);
        return typeof (c == null ? void 0 : c.hasAttribute) > "u" || (c != null && c.hasAttribute("data-radix-popper-content-wrapper") ? s.value = c.firstElementChild : s.value = c), c;
      }
    }) : null;
  }
}), vi = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = rl();
    e.contentId || (e.contentId = ve(void 0, "radix-vue-collapsible-content"));
    const n = B(), { forwardRef: l, currentElement: s } = R(), r = B(0), i = B(0), u = A(() => e.open.value), d = B(u.value), p = B();
    return J(
      () => {
        var c;
        return [u.value, (c = n.value) == null ? void 0 : c.present];
      },
      async () => {
        await ne();
        const c = s.value;
        if (!c)
          return;
        p.value = p.value || {
          transitionDuration: c.style.transitionDuration,
          animationName: c.style.animationName
        }, c.style.transitionDuration = "0s", c.style.animationName = "none";
        const f = c.getBoundingClientRect();
        i.value = f.height, r.value = f.width, d.value || (c.style.transitionDuration = p.value.transitionDuration, c.style.animationName = p.value.animationName);
      },
      {
        immediate: !0
      }
    ), ae(() => {
      requestAnimationFrame(() => {
        d.value = !1;
      });
    }), (c, f) => (g(), w(o(we), {
      ref_key: "presentRef",
      ref: n,
      present: c.forceMount || o(e).open.value,
      "force-mount": !0
    }, {
      default: m(() => {
        var v, y;
        return [
          j(o(O), k(c.$attrs, {
            id: o(e).contentId,
            ref: o(l),
            "as-child": t.asChild,
            as: c.as,
            "data-state": o(e).open.value ? "open" : "closed",
            "data-disabled": (v = o(e).disabled) != null && v.value ? "" : void 0,
            hidden: !((y = n.value) != null && y.present),
            style: {
              "--radix-collapsible-content-height": `${i.value}px`,
              "--radix-collapsible-content-width": `${r.value}px`
            }
          }), {
            default: m(() => {
              var h;
              return [
                (h = n.value) != null && h.present ? C(c.$slots, "default", { key: 0 }) : re("", !0)
              ];
            }),
            _: 3
          }, 16, ["id", "as-child", "as", "data-state", "data-disabled", "hidden", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
});
function il({ type: a, defaultValue: t, modelValue: e }) {
  const n = e || t;
  if (!a && !e && !t)
    throw new Error("Either the `type` or the `value` or `default-value` prop must be defined.");
  if (e !== void 0 && t !== void 0 && typeof e != typeof t)
    throw new Error(
      `Invalid prop \`value\` of value \`${e}\` supplied, should be the same type as the \`defaultValue\` prop, which is \`${t}\`. The \`value\` prop must be:
  ${a === "single" ? "- a string" : a === "multiple" ? "- an array of strings" : `- a string
- an array of strings`}
  - \`undefined\``
    );
  const l = e !== void 0 || t !== void 0;
  if (a && l) {
    const s = Array.isArray(e) || Array.isArray(t), r = e !== void 0 ? "modelValue" : "defaultValue", i = r === "modelValue" ? typeof e : typeof t;
    if (a === "single" && s)
      return console.error(`Invalid prop \`${r}\` of type ${i} supplied with type \`single\`. The \`modelValue\` prop must be a string or \`undefined\`.
You can remove the \`type\` prop to let the component infer the type from the ${r} prop.`), "multiple";
    if (a === "multiple" && !s)
      return console.error(`Invalid prop \`${r}\` of type ${i} supplied with type \`multiple\`. The \`modelValue\` prop must be an array of strings or \`undefined\`.
    You can remove the \`type\` prop to let the component infer the type from the ${r} prop.`), "single";
  }
  return l ? Array.isArray(n) ? "multiple" : "single" : a;
}
function mi({ type: a, defaultValue: t, modelValue: e }) {
  return a || il({ type: a, defaultValue: t, modelValue: e });
}
function hi({ type: a, defaultValue: t }) {
  return t !== void 0 ? t : a === "single" ? void 0 : [];
}
function ul(a, t) {
  const e = B(mi(a)), n = Q(a, "modelValue", t, {
    defaultValue: hi(a),
    passive: a.modelValue === void 0
  });
  J(
    () => [a.type, a.modelValue, a.defaultValue],
    () => {
      const r = il(a);
      e.value !== r && (e.value = r);
    },
    { immediate: !0 }
  );
  function l(r) {
    if (e.value === "single")
      n.value = r === n.value ? void 0 : r;
    else {
      const i = n.value || [];
      if (i.includes(r)) {
        const u = i.findIndex((d) => d === r);
        i.splice(u, 1);
      } else
        i.push(r);
      n.value = i, t("update:modelValue", n.value);
    }
  }
  const s = A(() => e.value === "single");
  return {
    modelValue: n,
    type: e,
    changeModelValue: l,
    isSingle: s
  };
}
const [Ea, yi] = q("AccordionRoot"), sf = /* @__PURE__ */ _({
  __name: "AccordionRoot",
  props: {
    collapsible: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dir: {},
    orientation: { default: "vertical" },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, n = t, { dir: l, disabled: s } = te(e), r = Pe(l), { modelValue: i, changeModelValue: u, isSingle: d } = ul(e, n), { forwardRef: p, currentElement: c } = R();
    return yi({
      disabled: s,
      direction: r,
      orientation: e.orientation,
      parentElement: c,
      isSingle: d,
      collapsible: e.collapsible,
      modelValue: i,
      changeModelValue: u
    }), (f, v) => (g(), w(o(O), {
      ref: o(p),
      "as-child": f.asChild,
      as: f.as
    }, {
      default: m(() => [
        C(f.$slots, "default", { modelValue: o(i) })
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), [En, gi] = q("AccordionItem"), rf = /* @__PURE__ */ _({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a, { expose: t }) {
    const e = a, n = Ea(), l = A(
      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)
    ), s = A(() => n.disabled.value || e.disabled || n.isSingle.value && l.value && !n.collapsible), r = A(() => s.value ? "" : void 0), i = A(
      () => l.value ? "open" : "closed"
      /* Closed */
    );
    t({ open: l, dataDisabled: r });
    const { currentRef: u, currentElement: d } = R();
    gi({
      open: l,
      dataState: i,
      disabled: s,
      dataDisabled: r,
      triggerId: "",
      currentRef: u,
      currentElement: d,
      value: A(() => e.value)
    });
    function p(c) {
      Ot(
        c,
        d.value,
        n.parentElement.value,
        {
          arrowKeyOptions: n.orientation,
          dir: n.direction.value,
          focus: !0
        }
      );
    }
    return (c, f) => (g(), w(o(ci), {
      "data-orientation": o(n).orientation,
      "data-disabled": r.value,
      "data-state": i.value,
      disabled: s.value,
      open: l.value,
      "as-child": e.asChild,
      onKeydown: he(p, ["up", "down", "left", "right", "home", "end"])
    }, {
      default: m(() => [
        C(c.$slots, "default", { open: l.value })
      ]),
      _: 3
    }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as-child"]));
  }
}), uf = /* @__PURE__ */ _({
  __name: "AccordionContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Ea(), n = En();
    return R(), (l, s) => (g(), w(o(vi), {
      role: "region",
      open: o(n).open.value,
      hidden: !o(n).open.value,
      "as-child": t.asChild,
      "aria-labelledby": o(n).triggerId,
      "data-state": o(n).dataState.value,
      "data-disabled": o(n).dataDisabled.value,
      "data-orientation": o(e).orientation,
      style: { "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", "--radix-accordion-content-height": "var(--radix-collapsible-content-height)" }
    }, {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "hidden", "as-child", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]));
  }
}), df = /* @__PURE__ */ _({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(a) {
    const t = a, e = Ea(), n = En();
    return R(), (l, s) => (g(), w(o(O), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": o(e).orientation,
      "data-state": o(n).dataState.value,
      "data-disabled": o(n).dataDisabled.value
    }, {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]));
  }
}), cf = /* @__PURE__ */ _({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Ea(), n = En();
    n.triggerId || (n.triggerId = ve(void 0, "radix-vue-accordion-trigger"));
    function l() {
      n.disabled.value || e.changeModelValue(n.value.value);
    }
    return (s, r) => (g(), w(o(pi), {
      id: o(n).triggerId,
      ref: o(n).currentRef,
      "data-radix-vue-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-disabled": o(n).disabled.value || void 0,
      "aria-expanded": o(n).open.value || !1,
      "data-disabled": o(n).dataDisabled.value,
      "data-orientation": o(e).orientation,
      "data-state": o(n).dataState.value,
      disabled: o(n).disabled.value,
      onClick: l
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "as", "as-child", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]));
  }
}), [ze, bi] = q("DialogRoot"), Ci = /* @__PURE__ */ _({
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), s = B(), r = B(), { modal: i } = te(e);
    return bi({
      open: l,
      modal: i,
      openModal: () => {
        l.value = !0;
      },
      onOpenChange: (u) => {
        l.value = u;
      },
      onOpenToggle: () => {
        l.value = !l.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: s,
      contentElement: r
    }), (u, d) => C(u.$slots, "default");
  }
}), _i = /* @__PURE__ */ _({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = ze(), { forwardRef: n, currentElement: l } = R();
    return e.contentId || (e.contentId = ve(void 0, "radix-vue-dialog-content")), ae(() => {
      e.triggerElement = l;
    }), (s, r) => (g(), w(o(O), k(t, {
      ref: o(n),
      type: s.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": o(e).open.value || !1,
      "aria-controls": o(e).open.value ? o(e).contentId : void 0,
      "data-state": o(e).open.value ? "open" : "closed",
      onClick: o(e).onOpenToggle
    }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]));
  }
}), ut = /* @__PURE__ */ _({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = Da();
    return (e, n) => o(t) || e.forceMount ? (g(), w(At, {
      key: 0,
      to: e.to,
      disabled: e.disabled
    }, [
      C(e.$slots, "default")
    ], 8, ["to", "disabled"])) : re("", !0);
  }
}), pf = /* @__PURE__ */ _({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wi = "dismissableLayer.pointerDownOutside", xi = "dismissableLayer.focusOutside";
function dl(a, t) {
  const e = t.closest(
    "[data-dismissable-layer]"
  ), n = a.querySelector(
    "[data-dismissable-layer]"
  ), l = Array.from(
    a.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(e && n === e || l.indexOf(n) < l.indexOf(e));
}
function Pi(a, t) {
  var s;
  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = B(!1), l = B(() => {
  });
  return de((r) => {
    if (!Ue)
      return;
    const i = async (d) => {
      const p = d.target;
      if (t != null && t.value) {
        if (dl(t.value, p)) {
          n.value = !1;
          return;
        }
        if (d.target && !n.value) {
          let c = function() {
            yn(
              wi,
              a,
              f
            );
          };
          const f = { originalEvent: d };
          d.pointerType === "touch" ? (e.removeEventListener("click", l.value), l.value = c, e.addEventListener("click", l.value, {
            once: !0
          })) : c();
        } else
          e.removeEventListener("click", l.value);
        n.value = !1;
      }
    }, u = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    r(() => {
      window.clearTimeout(u), e.removeEventListener("pointerdown", i), e.removeEventListener("click", l.value);
    });
  }), {
    onPointerDownCapture: () => n.value = !0
  };
}
function Si(a, t) {
  var l;
  const e = ((l = t == null ? void 0 : t.value) == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = B(!1);
  return de((s) => {
    if (!Ue)
      return;
    const r = async (i) => {
      t != null && t.value && (await ne(), !(!t.value || dl(t.value, i.target)) && i.target && !n.value && yn(
        xi,
        a,
        { originalEvent: i }
      ));
    };
    e.addEventListener("focusin", r), s(() => e.removeEventListener("focusin", r));
  }), {
    onFocusCapture: () => n.value = !0,
    onBlurCapture: () => n.value = !1
  };
}
const Le = Fo({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), dt = /* @__PURE__ */ _({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = A(
      () => {
        var y;
        return ((y = s.value) == null ? void 0 : y.ownerDocument) ?? globalThis.document;
      }
    ), i = A(() => Le.layersRoot), u = A(() => s.value ? Array.from(i.value).indexOf(s.value) : -1), d = A(() => Le.layersWithOutsidePointerEventsDisabled.size > 0), p = A(() => {
      const y = Array.from(i.value), [h] = [...Le.layersWithOutsidePointerEventsDisabled].slice(-1), x = y.indexOf(h);
      return u.value >= x;
    }), c = Pi(async (y) => {
      const h = [...Le.branches].some(
        (x) => x.contains(y.target)
      );
      !p.value || h || (n("pointerDownOutside", y), n("interactOutside", y), await ne(), y.defaultPrevented || n("dismiss"));
    }, s), f = Si((y) => {
      [...Le.branches].some(
        (x) => x.contains(y.target)
      ) || (n("focusOutside", y), n("interactOutside", y), y.defaultPrevented || n("dismiss"));
    }, s);
    _n("Escape", (y) => {
      u.value === i.value.size - 1 && (n("escapeKeyDown", y), y.defaultPrevented || n("dismiss"));
    });
    let v;
    return de((y) => {
      s.value && (e.disableOutsidePointerEvents && (Le.layersWithOutsidePointerEventsDisabled.size === 0 && (v = r.value.body.style.pointerEvents, r.value.body.style.pointerEvents = "none"), Le.layersWithOutsidePointerEventsDisabled.add(s.value)), i.value.add(s.value), y(() => {
        e.disableOutsidePointerEvents && Le.layersWithOutsidePointerEventsDisabled.size === 1 && (r.value.body.style.pointerEvents = v);
      }));
    }), de((y) => {
      y(() => {
        s.value && (i.value.delete(s.value), Le.layersWithOutsidePointerEventsDisabled.delete(s.value));
      });
    }), (y, h) => (g(), w(o(O), {
      ref: o(l),
      "as-child": y.asChild,
      as: y.as,
      "data-dismissable-layer": "",
      style: ge({
        pointerEvents: d.value ? p.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: o(f).onFocusCapture,
      onBlurCapture: o(f).onBlurCapture,
      onPointerdownCapture: o(c).onPointerDownCapture
    }, {
      default: m(() => [
        C(y.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), Di = /* @__PURE__ */ _({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e, currentElement: n } = R();
    return ae(() => {
      Le.branches.add(n.value);
    }), De(() => {
      Le.branches.delete(n.value);
    }), (l, s) => (g(), w(o(O), k({ ref: o(e) }, t), {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ja = "focusScope.autoFocusOnMount", Qa = "focusScope.autoFocusOnUnmount", bo = { bubbles: !1, cancelable: !0 };
function ya(a, { select: t = !1 } = {}) {
  const e = document.activeElement;
  for (const n of a)
    if (tt(n, { select: t }), document.activeElement !== e)
      return !0;
}
function $i(a) {
  const t = Bn(a), e = Co(t, a), n = Co(t.reverse(), a);
  return [e, n];
}
function Bn(a) {
  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const l = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function Co(a, t) {
  for (const e of a)
    if (!Ei(e, { upTo: t }))
      return e;
}
function Ei(a, { upTo: t }) {
  if (getComputedStyle(a).visibility === "hidden")
    return !0;
  for (; a; ) {
    if (t !== void 0 && a === t)
      return !1;
    if (getComputedStyle(a).display === "none")
      return !0;
    a = a.parentElement;
  }
  return !1;
}
function Bi(a) {
  return a instanceof HTMLInputElement && "select" in a;
}
function tt(a, { select: t = !1 } = {}) {
  if (a && a.focus) {
    const e = document.activeElement;
    a.focus({ preventScroll: !0 }), a !== e && Bi(a) && t && a.select();
  }
}
const Ri = xr(() => B([]));
function Ai() {
  const a = Ri();
  return {
    add(t) {
      const e = a.value[0];
      t !== e && (e == null || e.pause()), a.value = _o(a.value, t), a.value.unshift(t);
    },
    remove(t) {
      var e;
      a.value = _o(a.value, t), (e = a.value[0]) == null || e.resume();
    }
  };
}
function _o(a, t) {
  const e = [...a], n = e.indexOf(t);
  return n !== -1 && e.splice(n, 1), e;
}
function Ti(a) {
  return a.filter((t) => t.tagName !== "A");
}
const Ba = /* @__PURE__ */ _({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, { currentRef: l, currentElement: s } = R(), r = B(null), i = Ai(), u = Fo({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    de((p) => {
      if (!Ue)
        return;
      const c = s.value;
      if (!e.trapped)
        return;
      function f(x) {
        if (u.paused || !c)
          return;
        const P = x.target;
        c.contains(P) ? r.value = P : tt(r.value, { select: !0 });
      }
      function v(x) {
        if (u.paused || !c)
          return;
        const P = x.relatedTarget;
        P !== null && (c.contains(P) || tt(r.value, { select: !0 }));
      }
      function y(x) {
        c.contains(r.value) || tt(c);
      }
      document.addEventListener("focusin", f), document.addEventListener("focusout", v);
      const h = new MutationObserver(y);
      c && h.observe(c, { childList: !0, subtree: !0 }), p(() => {
        document.removeEventListener("focusin", f), document.removeEventListener("focusout", v), h.disconnect();
      });
    }), de(async (p) => {
      const c = s.value;
      if (await ne(), !c)
        return;
      i.add(u);
      const f = document.activeElement;
      if (!c.contains(f)) {
        const y = new CustomEvent(Ja, bo);
        c.addEventListener(
          Ja,
          (h) => n("mountAutoFocus", h)
        ), c.dispatchEvent(y), y.defaultPrevented || (ya(Ti(Bn(c)), {
          select: !0
        }), document.activeElement === f && tt(c));
      }
      p(() => {
        c.removeEventListener(
          Ja,
          (x) => n("mountAutoFocus", x)
        );
        const y = new CustomEvent(Qa, bo), h = (x) => {
          n("unmountAutoFocus", x);
        };
        c.addEventListener(Qa, h), c.dispatchEvent(y), setTimeout(() => {
          y.defaultPrevented || tt(f ?? document.body, { select: !0 }), c.removeEventListener(Qa, h), i.remove(u);
        }, 0);
      });
    });
    function d(p) {
      if (!e.loop && !e.trapped || u.paused)
        return;
      const c = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey, f = document.activeElement;
      if (c && f) {
        const v = p.currentTarget, [y, h] = $i(v);
        y && h ? !p.shiftKey && f === h ? (p.preventDefault(), e.loop && tt(y, { select: !0 })) : p.shiftKey && f === y && (p.preventDefault(), e.loop && tt(h, { select: !0 })) : f === v && p.preventDefault();
      }
    }
    return (p, c) => (g(), w(o(O), {
      ref_key: "currentRef",
      ref: l,
      tabindex: "-1",
      "as-child": p.asChild,
      as: p.as,
      onKeydown: d
    }, {
      default: m(() => [
        C(p.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Ii = "menu.itemSelect", on = ["Enter", " "], Oi = ["ArrowDown", "PageUp", "Home"], cl = ["ArrowUp", "PageDown", "End"], ki = [...Oi, ...cl], Mi = {
  ltr: [...on, "ArrowRight"],
  rtl: [...on, "ArrowLeft"]
}, Vi = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function Rn(a) {
  return a ? "open" : "closed";
}
function Ca(a) {
  return a === "indeterminate";
}
function An(a) {
  return Ca(a) ? "indeterminate" : a ? "checked" : "unchecked";
}
function ln(a) {
  const t = document.activeElement;
  for (const e of a)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function Fi(a, t) {
  const { x: e, y: n } = a;
  let l = !1;
  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {
    const i = t[s].x, u = t[s].y, d = t[r].x, p = t[r].y;
    u > n != p > n && e < (d - i) * (n - u) / (p - u) + i && (l = !l);
  }
  return l;
}
function Li(a, t) {
  if (!t)
    return !1;
  const e = { x: a.clientX, y: a.clientY };
  return Fi(e, t);
}
function Xt(a) {
  return a.pointerType === "mouse";
}
function Ni() {
  const a = "DialogContent", t = "DialogTitle", e = ze(), n = `Warning: \`${a}\` requires a \`${t}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.radix-vue.com/components/dialog.html#title;`, l = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${a}.`;
  ae(() => {
    var i;
    document.getElementById(e.titleId) || console.warn(n);
    const r = (i = e.contentElement.value) == null ? void 0 : i.getAttribute("aria-describedby");
    e.descriptionId && r && (document.getElementById(e.descriptionId) || console.warn(l));
  });
}
const pl = /* @__PURE__ */ _({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = ze(), { forwardRef: s, currentElement: r } = R();
    return l.titleId || (l.titleId = ve(void 0, "radix-vue-dialog-title")), l.descriptionId || (l.descriptionId = ve(void 0, "radix-vue-dialog-description")), ae(() => {
      l.contentElement = r;
    }), process.env.NODE_ENV !== "production" && Ni(), (i, u) => (g(), w(o(Ba), {
      "as-child": "",
      loop: "",
      trapped: e.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => n("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => n("closeAutoFocus", d))
    }, {
      default: m(() => [
        j(o(dt), k({
          id: o(l).contentId,
          ref: o(s),
          as: i.as,
          "as-child": i.asChild,
          "disable-outside-pointer-events": i.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": o(l).descriptionId,
          "aria-labelledby": o(l).titleId,
          "data-state": o(Rn)(o(l).open.value)
        }, i.$attrs, {
          onDismiss: u[0] || (u[0] = (d) => o(l).onOpenChange(!1)),
          onEscapeKeyDown: u[1] || (u[1] = (d) => n("escapeKeyDown", d)),
          onFocusOutside: u[2] || (u[2] = (d) => n("focusOutside", d)),
          onInteractOutside: u[3] || (u[3] = (d) => n("interactOutside", d)),
          onPointerDownOutside: u[4] || (u[4] = (d) => n("pointerDownOutside", d))
        }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), zi = /* @__PURE__ */ _({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = ze(), s = $e(n), { forwardRef: r, currentElement: i } = R();
    return la(i), (u, d) => (g(), w(pl, k({ ...e, ...o(s) }, {
      ref: o(r),
      "trap-focus": o(l).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (p) => {
        var c;
        n("closeAutoFocus", p), p.defaultPrevented || (p.preventDefault(), (c = o(l).triggerElement.value) == null || c.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (p) => {
        const c = p.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
        (c.button === 2 || f) && p.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (p) => {
        p.preventDefault();
      }),
      onOpenAutoFocus: d[3] || (d[3] = (p) => n("openAutoFocus", p))
    }), {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Ki = /* @__PURE__ */ _({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = $e(n);
    R();
    const s = ze(), r = B(!1), i = B(!1);
    return (u, d) => (g(), w(pl, k({ ...e, ...o(l) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (p) => {
        var c;
        n("closeAutoFocus", p), p.defaultPrevented || (r.value || (c = o(s).triggerElement.value) == null || c.focus(), p.preventDefault()), r.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (p) => {
        var v;
        p.defaultPrevented || (r.value = !0, p.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const c = p.target;
        ((v = o(s).triggerElement.value) == null ? void 0 : v.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === "focusin" && i.value && p.preventDefault();
      })
    }), {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hi = /* @__PURE__ */ _({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = ze(), s = $e(n), { forwardRef: r } = R();
    return (i, u) => (g(), w(o(we), {
      present: i.forceMount || o(l).open.value
    }, {
      default: m(() => [
        o(l).modal.value ? (g(), w(zi, k({
          key: 0,
          ref: o(r)
        }, { ...e, ...o(s), ...i.$attrs }, {
          onOpenAutoFocus: u[0] || (u[0] = (d) => n("openAutoFocus", d))
        }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (g(), w(Ki, k({
          key: 1,
          ref: o(r)
        }, { ...e, ...o(s), ...i.$attrs }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Wi = /* @__PURE__ */ _({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = ze();
    return oa(!0), R(), (e, n) => (g(), w(o(O), {
      as: e.as,
      "as-child": e.asChild,
      "data-state": o(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
}), ji = /* @__PURE__ */ _({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = ze(), { forwardRef: e } = R();
    return (n, l) => {
      var s;
      return (s = o(t)) != null && s.modal.value ? (g(), w(o(we), {
        key: 0,
        present: n.forceMount || o(t).open.value
      }, {
        default: m(() => [
          j(Wi, k(n.$attrs, {
            ref: o(e),
            as: n.as,
            "as-child": n.asChild
          }), {
            default: m(() => [
              C(n.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : re("", !0);
    };
  }
}), fl = /* @__PURE__ */ _({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = ze();
    return (n, l) => (g(), w(o(O), k(t, {
      type: n.as === "button" ? "button" : void 0,
      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), Gi = /* @__PURE__ */ _({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(a) {
    const t = a, e = ze();
    return R(), (n, l) => (g(), w(o(O), k(t, {
      id: o(e).titleId
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Ui = /* @__PURE__ */ _({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(a) {
    const t = a;
    R();
    const e = ze();
    return (n, l) => (g(), w(o(O), k(t, {
      id: o(e).descriptionId
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), ff = /* @__PURE__ */ _({
  __name: "AlertDialogRoot",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return R(), (s, r) => (g(), w(o(Ci), k(o(l), { modal: !0 }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vf = /* @__PURE__ */ _({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(_i), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mf = /* @__PURE__ */ _({
  __name: "AlertDialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [qi, Yi] = q("AlertDialogContent"), hf = /* @__PURE__ */ _({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    R();
    const s = B();
    return Yi({
      onCancelElementChange: (r) => {
        s.value = r;
      }
    }), (r, i) => (g(), w(o(Hi), k({ ...e, ...o(l) }, {
      role: "alertdialog",
      onPointerDownOutside: i[0] || (i[0] = ye(() => {
      }, ["prevent"])),
      onInteractOutside: i[1] || (i[1] = ye(() => {
      }, ["prevent"])),
      onOpenAutoFocus: i[2] || (i[2] = () => {
        ne(() => {
          var u;
          (u = s.value) == null || u.focus({
            preventScroll: !0
          });
        });
      })
    }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yf = /* @__PURE__ */ _({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(ji), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gf = /* @__PURE__ */ _({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = qi(), { forwardRef: n, currentElement: l } = R();
    return ae(() => {
      e.onCancelElementChange(l.value);
    }), (s, r) => (g(), w(o(fl), k(t, { ref: o(n) }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bf = /* @__PURE__ */ _({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Gi), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cf = /* @__PURE__ */ _({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Ui), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _f = /* @__PURE__ */ _({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(fl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wf = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: { default: 1 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e } = R(), n = A(() => 1 / t.ratio * 100);
    return (l, s) => (g(), fe("div", {
      style: ge(`position: relative; width: 100%; padding-bottom: ${n.value}%`),
      "data-radix-aspect-ratio-wrapper": ""
    }, [
      j(o(O), k({
        ref: o(e),
        "as-child": l.asChild,
        as: l.as,
        style: { position: "absolute", inset: "0px" }
      }, l.$attrs), {
        default: m(() => [
          C(l.$slots, "default", { aspect: n.value })
        ]),
        _: 3
      }, 16, ["as-child", "as"])
    ], 4));
  }
}), [vl, Xi] = q("AvatarRoot"), xf = /* @__PURE__ */ _({
  __name: "AvatarRoot",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    return R(), Xi({
      imageLoadingStatus: B("loading")
    }), (t, e) => (g(), w(o(O), {
      "as-child": t.asChild,
      as: t.as
    }, {
      default: m(() => [
        C(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
});
function Zi(a) {
  const t = B("idle"), e = B(!1), n = (l) => () => {
    e.value && (t.value = l);
  };
  return ae(() => {
    e.value = !0, J(a, (l) => {
      if (!l)
        t.value = "error";
      else {
        const s = new window.Image();
        t.value = "loading", s.onload = n("loaded"), s.onerror = n("error"), s.src = l;
      }
    }, { immediate: !0 });
  }), De(() => {
    e.value = !1;
  }), t;
}
const Pf = /* @__PURE__ */ _({
  __name: "AvatarImage",
  props: {
    src: {},
    asChild: { type: Boolean },
    as: { default: "img" }
  },
  emits: ["loadingStatusChange"],
  setup(a, { emit: t }) {
    const e = a, n = t, { src: l } = te(e);
    R();
    const s = vl(), r = Zi(l);
    return J(
      r,
      (i) => {
        n("loadingStatusChange", i), i !== "idle" && (s.imageLoadingStatus.value = i);
      },
      { immediate: !0 }
    ), (i, u) => xa((g(), w(o(O), {
      role: "img",
      "as-child": i.asChild,
      as: i.as,
      src: o(l)
    }, {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "src"])), [
      [vn, o(r) === "loaded"]
    ]);
  }
}), Sf = /* @__PURE__ */ _({
  __name: "AvatarFallback",
  props: {
    delayMs: { default: 0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a, e = vl();
    R();
    const n = B(!1);
    let l;
    return J(e.imageLoadingStatus, (s) => {
      s === "loading" && (n.value = !1, t.delayMs ? l = setTimeout(() => {
        n.value = !0, clearTimeout(l);
      }, t.delayMs) : n.value = !0);
    }, { immediate: !0 }), (s, r) => n.value && o(e).imageLoadingStatus.value !== "loaded" ? (g(), w(o(O), {
      key: 0,
      "as-child": s.asChild,
      as: s.as
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"])) : re("", !0);
  }
});
function Ji(a) {
  function t(n) {
    return Array.isArray(a.date.value) ? a.date.value.some((l) => Se(l, n)) : a.date.value ? Se(a.date.value, n) : !1;
  }
  const e = A(
    () => {
      var n, l, s, r;
      if (Array.isArray(a.date.value)) {
        if (!a.date.value.length)
          return !1;
        for (const i of a.date.value)
          if ((n = a.isDateDisabled) != null && n.call(a, i) || (l = a.isDateUnavailable) != null && l.call(a, i))
            return !0;
      } else {
        if (!a.date.value)
          return !1;
        if ((s = a.isDateDisabled) != null && s.call(a, a.date.value) || (r = a.isDateUnavailable) != null && r.call(a, a.date.value))
          return !0;
      }
      return !1;
    }
  );
  return {
    isDateSelected: t,
    isInvalid: e
  };
}
function ml(a) {
  const t = xn(a.locale.value), e = B(ia({
    dateObj: a.placeholder.value,
    weekStartsOn: a.weekStartsOn,
    locale: a.locale.value,
    fixedWeeks: a.fixedWeeks,
    numberOfMonths: a.numberOfMonths
  })), n = A(() => e.value.map((y) => y.value));
  function l(y) {
    return !n.value.some((h) => hn(y, h));
  }
  const s = A(() => {
    if (!a.maxValue.value || !e.value.length)
      return !1;
    if (a.disabled.value)
      return !0;
    const h = e.value[e.value.length - 1].value.add({ months: 1 }).set({ day: 1 });
    return Rt(h, a.maxValue.value);
  }), r = A(() => {
    if (!a.minValue.value || !e.value.length)
      return !1;
    if (a.disabled.value)
      return !0;
    const h = e.value[0].value.subtract({ months: 1 }).set({ day: 35 });
    return Be(h, a.minValue.value);
  });
  function i(y) {
    var h;
    return !!((h = a.isDateDisabled) != null && h.call(a, y) || a.disabled.value || a.maxValue.value && Rt(y, a.maxValue.value) || a.minValue.value && Be(y, a.minValue.value));
  }
  const u = (y) => {
    var h;
    return !!((h = a.isDateUnavailable) != null && h.call(a, y));
  }, d = A(() => e.value.length ? e.value[0].rows[0].map((y) => t.dayOfWeek(Ve(y), a.weekdayFormat)) : []), p = () => {
    const y = e.value[0].value, h = ia({
      dateObj: y.add({ months: a.pagedNavigation ? a.numberOfMonths : 1 }),
      weekStartsOn: a.weekStartsOn,
      locale: a.locale.value,
      fixedWeeks: a.fixedWeeks,
      numberOfMonths: a.numberOfMonths
    });
    e.value = h, a.placeholder.value = h[0].value.set({ day: 1 });
  }, c = () => {
    const y = e.value[0].value, h = ia({
      dateObj: y.subtract({ months: a.pagedNavigation ? a.numberOfMonths : 1 }),
      weekStartsOn: a.weekStartsOn,
      locale: a.locale.value,
      fixedWeeks: a.fixedWeeks,
      numberOfMonths: a.numberOfMonths
    });
    a.placeholder.value = h[0].value.set({ day: 1 });
  };
  J(a.placeholder, (y, h) => {
    Re(y, h) || (e.value = ia({
      dateObj: y,
      weekStartsOn: a.weekStartsOn,
      locale: a.locale.value,
      fixedWeeks: a.fixedWeeks,
      numberOfMonths: a.numberOfMonths
    }));
  });
  const f = A(() => {
    if (!e.value.length)
      return "";
    if (a.locale.value !== t.getLocale() && t.setLocale(a.locale.value), e.value.length === 1) {
      const D = e.value[0].value;
      return `${t.fullMonthAndYear(Ve(D))}`;
    }
    const y = Ve(e.value[0].value), h = Ve(e.value[e.value.length - 1].value), x = t.fullMonth(y), P = t.fullMonth(h), $ = t.fullYear(y), b = t.fullYear(h);
    return $ === b ? `${x} - ${P} ${b}` : `${x} ${$} - ${P} ${b}`;
  }), v = A(() => `${a.calendarLabel ?? "Event Date"}, ${f.value}`);
  return {
    isDateDisabled: i,
    isDateUnavailable: u,
    isNextButtonDisabled: s,
    isPrevButtonDisabled: r,
    grid: e,
    weekdays: d,
    visibleView: n,
    isOutsideVisibleView: l,
    formatter: t,
    nextPage: p,
    prevPage: c,
    headingValue: f,
    fullCalendarLabel: v
  };
}
const Qi = { style: { border: "0px", clip: "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(50%)", height: "1px", margin: "-1px", overflow: "hidden", padding: "0px", position: "absolute", "white-space": "nowrap", width: "1px" } }, eu = {
  role: "heading",
  "aria-level": "2"
}, [kt, tu] = q("CalendarRoot"), au = /* @__PURE__ */ _({
  __name: "CalendarRoot",
  props: {
    modelValue: {},
    multiple: { type: Boolean, default: !1 },
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    preventDeselect: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    calendarLabel: {},
    fixedWeeks: { type: Boolean, default: !1 },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    numberOfMonths: { default: 1 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    initialFocus: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    isDateUnavailable: { type: Function, default: void 0 },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(a, { emit: t }) {
    const e = a, n = t, {
      locale: l,
      disabled: s,
      readonly: r,
      initialFocus: i,
      pagedNavigation: u,
      weekStartsOn: d,
      weekdayFormat: p,
      fixedWeeks: c,
      multiple: f,
      minValue: v,
      maxValue: y,
      numberOfMonths: h,
      preventDeselect: x,
      isDateDisabled: P,
      isDateUnavailable: $,
      calendarLabel: b
    } = te(e), { primitiveElement: S, currentElement: D } = it(), E = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? void 0,
      passive: e.modelValue === void 0
    }), T = Tt({
      defaultPlaceholder: e.placeholder,
      defaultValue: E.value
    }), M = Q(e, "placeholder", n, {
      defaultValue: e.defaultPlaceholder ?? T.copy(),
      passive: e.placeholder === void 0
    });
    function V(se) {
      M.value = se.copy();
    }
    const {
      fullCalendarLabel: I,
      headingValue: L,
      isDateDisabled: G,
      isDateUnavailable: X,
      isNextButtonDisabled: H,
      isPrevButtonDisabled: z,
      weekdays: F,
      isOutsideVisibleView: Y,
      nextPage: U,
      prevPage: Z,
      formatter: oe,
      grid: ee
    } = ml({
      locale: l,
      placeholder: M,
      weekStartsOn: e.weekStartsOn,
      fixedWeeks: e.fixedWeeks,
      numberOfMonths: e.numberOfMonths,
      minValue: v,
      maxValue: y,
      disabled: s,
      weekdayFormat: e.weekdayFormat,
      pagedNavigation: e.pagedNavigation,
      isDateDisabled: P.value,
      isDateUnavailable: $.value,
      calendarLabel: b.value
    }), {
      isInvalid: W,
      isDateSelected: ce
    } = Ji({
      date: E,
      isDateDisabled: G,
      isDateUnavailable: X
    });
    J(E, (se) => {
      if (Array.isArray(se) && se.length) {
        const ie = se[se.length - 1];
        ie && !Re(M.value, ie) && V(ie);
      } else
        !Array.isArray(se) && se && !Re(M.value, se) && V(se);
    });
    function pe(se) {
      if (f.value) {
        if (Array.isArray(E.value)) {
          if (!E.value) {
            E.value = [se.copy()];
            return;
          }
          if (E.value.findIndex((Ce) => Se(Ce, se)) === -1)
            E.value = [...E.value, se];
          else if (!x.value) {
            const Ce = E.value.filter((Ie) => !Se(Ie, se));
            if (!Ce.length) {
              M.value = se.copy(), E.value = void 0;
              return;
            }
            E.value = Ce.map((Ie) => Ie.copy());
          }
        }
      } else {
        if (!E.value) {
          E.value = se.copy();
          return;
        }
        !x.value && Re(E.value, se) ? (M.value = se.copy(), E.value = void 0) : E.value = se.copy();
      }
    }
    const ue = A(() => {
      const se = M.value.copy();
      return Yo({
        dateObj: se,
        maxValue: v.value,
        minValue: y.value,
        numberOfMonths: h.value,
        pagedNavigation: u.value
      });
    }), Ee = tl(({ startIndex: se, endIndex: ie }) => {
      const Ce = M.value.copy();
      return qo({
        dateObj: Ce,
        startIndex: se,
        endIndex: ie,
        maxValue: v.value,
        minValue: y.value
      });
    });
    return ae(() => {
      i.value && Qo(D.value);
    }), tu({
      isDateUnavailable: X,
      isDateDisabled: G,
      locale: l,
      formatter: oe,
      modelValue: E,
      placeholder: M,
      disabled: s,
      initialFocus: i,
      pagedNavigation: u,
      weekStartsOn: d,
      weekdayFormat: p,
      fixedWeeks: c,
      multiple: f,
      numberOfMonths: h,
      readonly: r,
      preventDeselect: x,
      fullCalendarLabel: I,
      headingValue: L,
      isInvalid: W,
      isDateSelected: ce,
      isNextButtonDisabled: H,
      isPrevButtonDisabled: z,
      isOutsideVisibleView: Y,
      nextPage: U,
      prevPage: Z,
      parentElement: D,
      onPlaceholderChange: V,
      onDateChange: pe
    }), (se, ie) => (g(), w(o(O), {
      ref_key: "primitiveElement",
      ref: S,
      as: se.as,
      "as-child": se.asChild,
      role: "application",
      "aria-label": o(I),
      "data-readonly": o(r) ? "" : void 0,
      "data-disabled": o(s) ? "" : void 0,
      "data-invalid": o(W) ? "" : void 0
    }, {
      default: m(() => [
        C(se.$slots, "default", {
          date: o(M),
          grid: o(ee),
          weekDays: o(F),
          formatter: o(oe),
          getMonths: ue.value,
          getYears: o(Ee)
        }),
        He("div", Qi, [
          He("div", eu, ke(o(I)), 1)
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-label", "data-readonly", "data-disabled", "data-invalid"]));
  }
}), nu = /* @__PURE__ */ _({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ou = /* @__PURE__ */ _({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a, e = kt();
    return (n, l) => (g(), w(o(O), k(t, {
      "data-disabled": o(e).disabled.value ? "" : void 0
    }), {
      default: m(() => [
        C(n.$slots, "default", {
          headingValue: o(e).headingValue.value
        }, () => [
          me(ke(o(e).headingValue.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), lu = /* @__PURE__ */ _({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: { default: "table" }
  },
  setup(a) {
    const t = a, e = kt();
    return (n, l) => (g(), w(o(O), k(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": o(e).readonly ? !0 : void 0,
      "aria-disabled": o(e).disabled ? !0 : void 0,
      "data-readonly": o(e).readonly ? "" : void 0,
      "data-disabled": o(e).disabled ? "" : void 0
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-readonly", "aria-disabled", "data-readonly", "data-disabled"]));
  }
}), su = /* @__PURE__ */ _({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: { default: "td" }
  },
  setup(a) {
    const t = kt();
    return (e, n) => {
      var l, s;
      return g(), w(o(O), {
        as: e.as,
        "as-child": e.asChild,
        role: "gridcell",
        "aria-selected": o(t).isDateSelected(e.date) ? !0 : void 0,
        "aria-disabled": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),
        "data-disabled": o(t).isDateDisabled(e.date) ? "" : void 0
      }, {
        default: m(() => [
          C(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-selected", "aria-disabled", "data-disabled"]);
    };
  }
}), ru = /* @__PURE__ */ _({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: { default: "th" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), iu = /* @__PURE__ */ _({
  __name: "CalendarNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = kt();
    return (n, l) => (g(), w(o(O), k(t, {
      "aria-label": "Next page",
      type: n.as === "button" ? "button" : void 0,
      "aria-disabled": o(e).isNextButtonDisabled.value || void 0,
      "data-disabled": o(e).isNextButtonDisabled.value || void 0,
      disabled: o(e).isNextButtonDisabled.value,
      onClick: o(e).nextPage
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("Next page")
        ])
      ]),
      _: 3
    }, 16, ["type", "aria-disabled", "data-disabled", "disabled", "onClick"]));
  }
}), uu = /* @__PURE__ */ _({
  __name: "CalendarPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = kt();
    return (n, l) => (g(), w(o(O), k({ "aria-label": "Previous page" }, t, {
      type: n.as === "button" ? "button" : void 0,
      "aria-disabled": o(e).isPrevButtonDisabled.value || void 0,
      "data-disabled": o(e).isPrevButtonDisabled.value || void 0,
      disabled: o(e).isPrevButtonDisabled.value,
      onClick: o(e).prevPage
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("Prev page")
        ])
      ]),
      _: 3
    }, 16, ["type", "aria-disabled", "data-disabled", "disabled", "onClick"]));
  }
}), du = /* @__PURE__ */ _({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: { default: "thead" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), k(t, { "aria-hidden": "true" }), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cu = /* @__PURE__ */ _({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: { default: "tbody" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pu = /* @__PURE__ */ _({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: { default: "tr" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fu = /* @__PURE__ */ _({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a, e = Ct(), n = kt(), { primitiveElement: l, currentElement: s } = it(), r = A(() => n.formatter.custom(Ve(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = A(() => n.isDateDisabled(t.day)), u = A(
      () => {
        var $;
        return ($ = n.isDateUnavailable) == null ? void 0 : $.call(n, t.day);
      }
    ), d = A(() => jo(t.day, Pa())), p = A(() => !hn(t.day, t.month)), c = A(
      () => n.isOutsideVisibleView(t.day)
    ), f = A(() => Se(t.day, n.placeholder.value)), v = A(() => n.isDateSelected(t.day)), y = "[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-month]):not([data-outside-visible-months])";
    function h($) {
      var b;
      n.readonly.value || n.isDateDisabled($) || (b = n.isDateUnavailable) != null && b.call(n, $) || n.onDateChange($);
    }
    function x($) {
      h(
        Ut(
          $.target.getAttribute("data-value"),
          n.placeholder.value
        )
      );
    }
    function P($) {
      const b = $.target;
      $.preventDefault(), $.stopPropagation();
      const S = n.parentElement.value, D = S ? Array.from(S.querySelectorAll(y)) : [];
      let T = D.indexOf(s.value);
      const M = 7;
      switch ($.code) {
        case e.ARROW_RIGHT:
          T++;
          break;
        case e.ARROW_LEFT:
          T--;
          break;
        case e.ARROW_UP:
          T -= M;
          break;
        case e.ARROW_DOWN:
          T += M;
          break;
        case e.ENTER:
        case e.SPACE_CODE:
          h(
            Ut(
              b.getAttribute("data-value"),
              n.placeholder.value
            )
          );
          return;
        default:
          return;
      }
      if (T >= 0 && T < D.length) {
        D[T].focus();
        return;
      }
      if (T < 0) {
        if (n.isPrevButtonDisabled.value)
          return;
        n.prevPage(), ne(() => {
          const V = S ? Array.from(S.querySelectorAll(y)) : [];
          V[V.length - Math.abs(T)].focus();
        });
        return;
      }
      if (T >= D.length) {
        if (n.isNextButtonDisabled.value)
          return;
        n.nextPage(), ne(() => {
          (S ? Array.from(S.querySelectorAll(y)) : [])[T - D.length].focus();
        });
      }
    }
    return ($, b) => (g(), w(o(O), k({
      ref_key: "primitiveElement",
      ref: l
    }, t, {
      role: "button",
      "aria-label": r.value,
      "data-radix-vue-calendar-cell-trigger": "",
      "aria-disabled": p.value || i.value || u.value ? !0 : void 0,
      "data-selected": v.value ? !0 : void 0,
      "data-value": $.day.toString(),
      "data-disabled": i.value || p.value ? "" : void 0,
      "data-unavailable": u.value ? "" : void 0,
      "data-today": d.value ? "" : void 0,
      "data-outside-view": p.value ? "" : void 0,
      "data-outside-visible-view": c.value ? "" : void 0,
      "data-focused": f.value ? "" : void 0,
      tabindex: f.value ? 0 : p.value || i.value ? void 0 : -1,
      onClick: x,
      onKeydown: [
        he(P, ["up", "down", "left", "right", "space", "enter"]),
        b[0] || (b[0] = he(ye(() => {
        }, ["prevent"]), ["enter"]))
      ]
    }), {
      default: m(() => [
        C($.$slots, "default", {}, () => [
          me(ke($.day.day.toLocaleString(o(n).locale.value)), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-disabled", "data-selected", "data-value", "data-disabled", "data-unavailable", "data-today", "data-outside-view", "data-outside-visible-view", "data-focused", "tabindex"]));
  }
});
function _a(a) {
  return a === "indeterminate";
}
function hl(a) {
  return _a(a) ? "indeterminate" : a ? "checked" : "unchecked";
}
const vu = ["value", "checked", "name", "disabled", "required"], [mu, hu] = q("CheckboxRoot"), Df = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String], default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(a, { emit: t }) {
    const e = a, n = t, { disabled: l } = te(e), s = Q(e, "checked", n, {
      defaultValue: e.defaultChecked,
      passive: e.checked === void 0
    }), { forwardRef: r, currentElement: i } = R(), u = gt(i), d = A(() => {
      var p;
      return e.id && i.value ? (p = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : p.innerText : void 0;
    });
    return hu({
      disabled: l,
      state: s
    }), (p, c) => (g(), fe(xe, null, [
      j(o(O), k(p.$attrs, {
        id: p.id,
        ref: o(r),
        role: "checkbox",
        "as-child": e.asChild,
        as: p.as,
        type: p.as === "button" ? "button" : void 0,
        "aria-checked": o(_a)(o(s)) ? "mixed" : o(s),
        "aria-required": !1,
        "aria-label": p.$attrs["aria-label"] || d.value,
        "data-state": o(hl)(o(s)),
        "data-disabled": o(l) ? "" : void 0,
        disabled: o(l),
        onKeydown: he(ye(() => {
        }, ["prevent"]), ["enter"]),
        onClick: c[0] || (c[0] = (f) => s.value = o(_a)(o(s)) ? !0 : !o(s))
      }), {
        default: m(() => [
          C(p.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-label", "data-state", "data-disabled", "disabled", "onKeydown"]),
      o(u) ? (g(), fe("input", {
        key: 0,
        type: "checkbox",
        tabindex: "-1",
        "aria-hidden": "",
        value: p.value,
        checked: !!o(s),
        name: e.name,
        disabled: e.disabled,
        required: e.required,
        style: ge({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, vu)) : re("", !0)
    ], 64));
  }
}), $f = /* @__PURE__ */ _({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const { forwardRef: t } = R(), e = mu();
    return (n, l) => (g(), w(o(we), {
      present: n.forceMount || o(_a)(o(e).state.value) || o(e).state.value === !0
    }, {
      default: m(() => [
        j(o(O), k({
          ref: o(t),
          "data-state": o(hl)(o(e).state.value),
          "data-disabled": o(e).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": n.asChild,
          as: n.as
        }, n.$attrs), {
          default: m(() => [
            C(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [yl, yu] = q("PopperRoot"), _t = /* @__PURE__ */ _({
  __name: "PopperRoot",
  setup(a) {
    const t = B();
    return yu({
      anchor: t,
      onAnchorChange: (e) => t.value = e
    }), (e, n) => C(e.$slots, "default");
  }
}), wt = /* @__PURE__ */ _({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e, currentElement: n } = R(), l = yl();
    return J(n, () => {
      l.onAnchorChange(t.element ?? n.value);
    }), (s, r) => (g(), w(o(O), {
      ref: o(e),
      as: s.as,
      "as-child": s.asChild
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function gu(a) {
  return a !== null;
}
function bu(a) {
  return {
    name: "transformOrigin",
    options: a,
    fn(t) {
      var x, P, $;
      const { placement: e, rects: n, middlewareData: l } = t, r = ((x = l.arrow) == null ? void 0 : x.centerOffset) !== 0, i = r ? 0 : a.arrowWidth, u = r ? 0 : a.arrowHeight, [d, p] = sn(e), c = { start: "0%", center: "50%", end: "100%" }[p], f = (((P = l.arrow) == null ? void 0 : P.x) ?? 0) + i / 2, v = ((($ = l.arrow) == null ? void 0 : $.y) ?? 0) + u / 2;
      let y = "", h = "";
      return d === "bottom" ? (y = r ? c : `${f}px`, h = `${-u}px`) : d === "top" ? (y = r ? c : `${f}px`, h = `${n.floating.height + u}px`) : d === "right" ? (y = `${-u}px`, h = r ? c : `${v}px`) : d === "left" && (y = `${n.floating.width + u}px`, h = r ? c : `${v}px`), { data: { x: y, y: h } };
    }
  };
}
function sn(a) {
  const [t, e = "center"] = a.split("-");
  return [t, e];
}
const gl = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [Cu, _u] = q("PopperContent"), ht = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ Lo({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...gl
  }),
  emits: ["placed"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = yl(), { forwardRef: s, currentElement: r } = R(), i = B(), u = B(), { width: d, height: p } = ll(u), c = A(
      () => e.side + (e.align !== "center" ? `-${e.align}` : "")
    ), f = A(() => typeof e.collisionPadding == "number" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), v = A(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), y = A(() => ({
      padding: f.value,
      boundary: v.value.filter(gu),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: v.value.length > 0
    })), h = _r(() => [
      Js({
        mainAxis: e.sideOffset + p.value,
        alignmentAxis: e.alignOffset
      }),
      e.prioritizePosition && e.avoidCollisions && fo({
        ...y.value
      }),
      e.avoidCollisions && Qs({
        mainAxis: !0,
        crossAxis: !!e.prioritizePosition,
        limiter: e.sticky === "partial" ? er() : void 0,
        ...y.value
      }),
      !e.prioritizePosition && e.avoidCollisions && fo({
        ...y.value
      }),
      tr({
        ...y.value,
        apply: ({ elements: I, rects: L, availableWidth: G, availableHeight: X }) => {
          const { width: H, height: z } = L.reference, F = I.floating.style;
          Object.assign(I.floating.style, {
            maxWidth: `${G}px`,
            maxHeight: `${X}px`
          }), F.setProperty(
            "--radix-popper-available-width",
            `${G}px`
          ), F.setProperty(
            "--radix-popper-available-height",
            `${X}px`
          ), F.setProperty(
            "--radix-popper-anchor-width",
            `${H}px`
          ), F.setProperty(
            "--radix-popper-anchor-height",
            `${z}px`
          );
        }
      }),
      u.value && ar({ element: u.value, padding: e.arrowPadding }),
      bu({
        arrowWidth: d.value,
        arrowHeight: p.value
      }),
      e.hideWhenDetached && nr({ strategy: "referenceHidden", ...y.value })
    ]), { floatingStyles: x, placement: P, isPositioned: $, middlewareData: b } = Xs(
      l.anchor,
      i,
      {
        strategy: "fixed",
        placement: c,
        whileElementsMounted: (...I) => Zs(...I, {
          animationFrame: e.updatePositionStrategy === "always"
        }),
        middleware: h
      }
    ), S = A(
      () => sn(P.value)[0]
    ), D = A(
      () => sn(P.value)[1]
    );
    de(() => {
      $.value && n("placed");
    });
    const E = A(
      () => {
        var I;
        return ((I = b.value.arrow) == null ? void 0 : I.centerOffset) !== 0;
      }
    ), T = B("");
    de(() => {
      r.value && (T.value = window.getComputedStyle(r.value).zIndex);
    });
    const M = A(() => {
      var I;
      return ((I = b.value.arrow) == null ? void 0 : I.x) ?? 0;
    }), V = A(() => {
      var I;
      return ((I = b.value.arrow) == null ? void 0 : I.y) ?? 0;
    });
    return _u({
      placedSide: S,
      onArrowChange: (I) => u.value = I,
      arrowX: M,
      arrowY: V,
      shouldHideArrow: E
    }), (I, L) => {
      var G, X, H;
      return g(), fe("div", {
        ref_key: "floatingRef",
        ref: i,
        "data-radix-popper-content-wrapper": "",
        style: ge({
          ...o(x),
          transform: o($) ? o(x).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: T.value,
          "--radix-popper-transform-origin": [
            (G = o(b).transformOrigin) == null ? void 0 : G.x,
            (X = o(b).transformOrigin) == null ? void 0 : X.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((H = o(b).hide) == null ? void 0 : H.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        j(o(O), k({ ref: o(s) }, I.$attrs, {
          "as-child": e.asChild,
          as: I.as,
          "data-side": S.value,
          "data-align": D.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: o($) ? void 0 : "none"
          }
        }), {
          default: m(() => [
            C(I.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
}), wu = /* @__PURE__ */ He("polygon", { points: "0,0 30,0 15,10" }, null, -1), xu = /* @__PURE__ */ _({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(O), k(t, {
      width: e.width,
      height: e.height,
      viewBox: e.asChild ? void 0 : "0 0 30 10",
      preserveAspectRatio: e.asChild ? void 0 : "none"
    }), {
      default: m(() => [
        C(e.$slots, "default", {}, () => [
          wu
        ])
      ]),
      _: 3
    }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]));
  }
}), Pu = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, Mt = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const { forwardRef: t } = R(), e = Cu(), n = A(() => Pu[e.placedSide.value]);
    return (l, s) => {
      var r, i, u, d;
      return g(), fe("span", {
        ref: (p) => {
          o(e).onArrowChange(p);
        },
        style: ge({
          position: "absolute",
          left: (r = o(e).arrowX) != null && r.value ? `${(i = o(e).arrowX) == null ? void 0 : i.value}px` : void 0,
          top: (u = o(e).arrowY) != null && u.value ? `${(d = o(e).arrowY) == null ? void 0 : d.value}px` : void 0,
          [n.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o(e).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o(e).placedSide.value],
          visibility: o(e).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        j(xu, k(l.$attrs, {
          ref: o(t),
          style: {
            display: "block"
          },
          as: l.as,
          "as-child": l.asChild,
          width: l.width,
          height: l.height
        }), {
          default: m(() => [
            C(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "width", "height"])
      ], 4);
    };
  }
}), Vt = /* @__PURE__ */ _({
  __name: "VisuallyHidden",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    return R(), (t, e) => (g(), w(o(O), {
      as: t.as,
      "as-child": t.asChild,
      style: ge({
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        display: "inline-block",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      })
    }, {
      default: m(() => [
        C(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "style"]));
  }
}), bl = /* @__PURE__ */ _({
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {},
    required: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(a) {
    const t = a, e = A(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" ? [{ name: t.name, value: t.value }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((n, l) => typeof n == "object" ? Object.entries(n).map(([s, r]) => ({ name: `[${l}][${t.name}][${s}]`, value: r })) : { name: `[${t.name}][${l}]`, value: n }) : typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, l]) => ({ name: `[${t.name}][${n}]`, value: l })) : []);
    return (n, l) => (g(!0), fe(xe, null, mn(e.value, (s) => (g(), w(Vt, {
      key: s.name,
      as: "input",
      type: "hidden",
      hidden: "",
      readonly: "",
      name: s.name,
      value: s.value,
      required: n.required,
      disabled: n.disabled
    }, null, 8, ["name", "value", "required", "disabled"]))), 128));
  }
});
function Su(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var Du = function a(t, e) {
  if (t === e)
    return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    if (t.constructor !== e.constructor)
      return !1;
    var n, l, s;
    if (Array.isArray(t)) {
      if (n = t.length, n != e.length)
        return !1;
      for (l = n; l-- !== 0; )
        if (!a(t[l], e[l]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === e.source && t.flags === e.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === e.toString();
    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length)
      return !1;
    for (l = n; l-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, s[l]))
        return !1;
    for (l = n; l-- !== 0; ) {
      var r = s[l];
      if (!a(t[r], e[r]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
};
const $t = /* @__PURE__ */ Su(Du), $u = "data-radix-vue-collection-item", [Tn, Eu] = q("CollectionProvider");
function In(a = $u) {
  const t = B(/* @__PURE__ */ new Map()), e = B(), n = Eu({
    collectionRef: e,
    itemMap: t,
    attrName: a
  }), { getItems: l } = Cl(n), s = A(() => Array.from(n.itemMap.value.values())), r = A(() => n.itemMap.value.size);
  return { getItems: l, reactiveItems: s, itemMapSize: r };
}
const On = _({
  name: "CollectionSlot",
  setup(a, { slots: t }) {
    const e = Tn(), { primitiveElement: n, currentElement: l } = it();
    return J(l, () => {
      e.collectionRef.value = l.value;
    }), () => nt($n, { ref: n }, t);
  }
}), kn = _({
  name: "CollectionItem",
  setup(a, { slots: t, attrs: e }) {
    const n = Tn(), { primitiveElement: l, currentElement: s } = it(), r = st();
    return de((i) => {
      var u;
      if (s.value) {
        const d = po(s.value);
        n.itemMap.value.set(d, { ref: s.value, ...po(((u = r == null ? void 0 : r.parent) == null ? void 0 : u.props) ?? {}) }), i(() => n.itemMap.value.delete(d));
      }
    }), () => nt($n, { ...e, [n.attrName]: "", ref: l }, t);
  }
});
function Cl(a) {
  const t = a ?? Tn();
  return { getItems: () => {
    const n = t.collectionRef.value;
    if (!n)
      return [];
    const l = Array.from(n.querySelectorAll(`[${t.attrName}]`));
    return Array.from(t.itemMap.value.values()).sort(
      (i, u) => l.indexOf(i.ref) - l.indexOf(u.ref)
    );
  } };
}
const [qe, Bu] = q("ComboboxRoot"), Ef = /* @__PURE__ */ _({
  __name: "ComboboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: {},
    filterFunction: {},
    displayValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm"],
  setup(a, { emit: t }) {
    const e = a, n = t, { multiple: l, disabled: s, dir: r } = te(e), i = Pe(r), u = Q(e, "searchTerm", n, {
      // @ts-expect-error ignore the type error here
      defaultValue: "",
      passive: e.searchTerm === void 0
    }), d = Q(e, "modelValue", n, {
      // @ts-expect-error ignore the type error here
      defaultValue: e.defaultValue ?? l.value ? [] : void 0,
      passive: e.modelValue === void 0,
      deep: !0
    }), p = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), c = B();
    async function f(H) {
      var z, F;
      p.value = H, await ne(), H ? (d.value && (Array.isArray(d.value) && l.value ? c.value = (z = b().find((Y) => {
        var U, Z;
        return ((Z = (U = Y.ref) == null ? void 0 : U.dataset) == null ? void 0 : Z.state) === "checked";
      })) == null ? void 0 : z.value : c.value = d.value), (F = h.value) == null || F.focus(), X()) : (y.value = !1, M());
    }
    function v(H) {
      if (Array.isArray(d.value) && l.value) {
        const z = d.value.findIndex((F) => $t(F, H));
        z === -1 ? d.value.push(H) : d.value.splice(z, 1);
      } else
        d.value = H, f(!1);
    }
    const y = B(!1), h = B(), x = B(), { forwardRef: P, currentElement: $ } = R(), { getItems: b, reactiveItems: S, itemMapSize: D } = In("data-radix-vue-combobox-item"), E = B([]);
    J(() => D.value, () => {
      E.value = b().map((H) => H.value);
    }, { immediate: !0 });
    const T = A(() => {
      if (y.value) {
        if (e.filterFunction)
          return e.filterFunction(E.value, u.value);
        const H = E.value.filter((z) => typeof z == "string");
        if (H.length)
          return H.filter((z) => {
            var F;
            return z.toLowerCase().includes((F = u.value) == null ? void 0 : F.toLowerCase());
          });
      }
      return E.value;
    });
    function M() {
      !l.value && d.value && !Array.isArray(d.value) ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != "object" ? u.value = d.value.toString() : u.value = "" : u.value = "";
    }
    const V = A(() => T.value.findIndex((H) => $t(H, c.value))), I = A(() => {
      var H;
      return (H = S.value.find((z) => z.value === c.value)) == null ? void 0 : H.ref;
    }), L = A(() => JSON.stringify(d.value));
    J(L, async () => {
      await ne(), await ne(), M();
    }, { immediate: !0 }), J(() => T.value.length, async (H) => {
      await ne(), await ne(), H && V.value === -1 && (c.value = T.value[0]);
    });
    const G = gt($);
    function X() {
      I.value instanceof Element && I.value.scrollIntoView({ block: "nearest" });
    }
    return Bu({
      searchTerm: u,
      modelValue: d,
      // @ts-expect-error igoring
      onValueChange: v,
      isUserInputted: y,
      multiple: l,
      disabled: s,
      open: p,
      onOpenChange: f,
      filteredOptions: T,
      contentId: "",
      inputElement: h,
      onInputElementChange: (H) => h.value = H,
      onInputNavigation: async (H) => {
        const z = V.value;
        z === 0 && H === "up" || z === T.value.length - 1 && H === "down" || (z === -1 && T.value.length || H === "home" ? c.value = T.value[0] : H === "end" ? c.value = T.value[T.value.length - 1] : c.value = T.value[H === "up" ? z - 1 : z + 1], X());
      },
      onInputEnter: async () => {
        var H;
        T.value.length && c.value && I.value instanceof Element && ((H = I.value) == null || H.click());
      },
      selectedValue: c,
      onSelectedValueChange: (H) => c.value = H,
      parentElement: $,
      contentElement: x,
      onContentElementChange: (H) => x.value = H
    }), (H, z) => (g(), w(o(_t), null, {
      default: m(() => [
        j(o(O), k({
          ref: o(P),
          style: {
            pointerEvents: o(p) ? "auto" : void 0
          },
          as: H.as,
          "as-child": H.asChild,
          dir: o(i)
        }, H.$attrs), {
          default: m(() => [
            C(H.$slots, "default", {
              open: o(p),
              modelValue: o(d)
            }),
            o(G) && e.name ? (g(), w(o(bl), {
              key: 0,
              name: e.name,
              value: o(d)
            }, null, 8, ["name", "value"])) : re("", !0)
          ]),
          _: 3
        }, 16, ["style", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), Bf = /* @__PURE__ */ _({
  __name: "ComboboxInput",
  props: {
    type: { default: "text" },
    disabled: { type: Boolean },
    autoFocus: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(a) {
    const t = a, e = qe(), { forwardRef: n, currentElement: l } = R();
    ae(() => {
      const d = l.value.nodeName === "INPUT" ? l.value : l.value.querySelector("input");
      d && (e.onInputElementChange(d), setTimeout(() => {
        t.autoFocus && (d == null || d.focus());
      }, 1));
    });
    const s = A(() => t.disabled || e.disabled.value || !1);
    function r(d) {
      e.open.value ? e.onInputNavigation(d.key === "ArrowUp" ? "up" : "down") : e.onOpenChange(!0);
    }
    function i(d) {
      e.open.value && e.onInputNavigation(d.key === "Home" ? "home" : "end");
    }
    function u(d) {
      var p;
      e.searchTerm.value = (p = d.target) == null ? void 0 : p.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;
    }
    return (d, p) => (g(), w(o(O), {
      ref: o(n),
      as: d.as,
      "as-child": d.asChild,
      type: d.type,
      disabled: s.value,
      value: o(e).searchTerm.value,
      "aria-expanded": o(e).open.value,
      "aria-controls": o(e).contentId,
      "aria-disabled": s.value ?? void 0,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "false",
      onInput: u,
      onKeydown: [
        he(ye(r, ["prevent"]), ["down", "up"]),
        he(o(e).onInputEnter, ["enter"]),
        he(ye(i, ["prevent"]), ["home", "end"])
      ]
    }, {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "type", "disabled", "value", "aria-expanded", "aria-controls", "aria-disabled", "onKeydown"]));
  }
}), Rf = /* @__PURE__ */ _({
  __name: "ComboboxAnchor",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const { forwardRef: t } = R();
    return (e, n) => (g(), w(o(wt), { "as-child": "" }, {
      default: m(() => [
        j(o(O), k({
          ref: o(t),
          "as-child": e.asChild,
          as: e.as
        }, e.$attrs), {
          default: m(() => [
            C(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as"])
      ]),
      _: 3
    }));
  }
}), Af = /* @__PURE__ */ _({
  __name: "ComboboxTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = qe(), n = A(() => t.disabled || e.disabled.value || !1);
    return (l, s) => (g(), w(o(O), k(t, {
      type: l.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": o(e).open.value,
      "aria-controls": o(e).contentId,
      "data-state": o(e).open.value ? "open" : "closed",
      disabled: n.value,
      "data-disabled": n.value ? "" : void 0,
      "aria-disabled": n.value ?? void 0,
      onClick: s[0] || (s[0] = (r) => o(e).onOpenChange(!o(e).open.value))
    }), {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "disabled", "data-disabled", "aria-disabled"]));
  }
}), Tf = /* @__PURE__ */ _({
  __name: "ComboboxCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = qe();
    function n() {
      var l;
      e.searchTerm.value = "", (l = e.inputElement.value) == null || l.focus();
    }
    return (l, s) => (g(), w(o(O), k({
      type: l.as === "button" ? "button" : void 0
    }, t, {
      tabindex: "-1",
      onClick: n
    }), {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), [_l, Ru] = q("ComboboxGroup"), If = /* @__PURE__ */ _({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { currentRef: e, currentElement: n } = R(), l = ve(void 0, "radix-vue-combobox-group"), s = qe(), r = B(!1);
    function i() {
      if (!n.value)
        return;
      const u = n.value.querySelectorAll("[data-radix-vue-combobox-item]:not([data-hidden])");
      r.value = !!u.length;
    }
    return zr(n, () => {
      i();
    }, { childList: !0 }), J(() => s.searchTerm.value, () => {
      ne(() => {
        i();
      });
    }, { immediate: !0 }), Ru({
      id: l
    }), (u, d) => xa((g(), w(o(O), k(t, {
      ref_key: "currentRef",
      ref: e,
      role: "group",
      "aria-labelledby": o(l)
    }), {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"])), [
      [vn, r.value]
    ]);
  }
}), Of = /* @__PURE__ */ _({
  __name: "ComboboxLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a;
    R();
    const e = _l({ id: "" });
    return (n, l) => (g(), w(o(O), k(t, {
      id: o(e).id
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), [Au, Tu] = q("ComboboxContent"), Iu = /* @__PURE__ */ _({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean, default: !0 },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, { position: l } = te(e), s = qe();
    oa(e.bodyLock);
    const { forwardRef: r, currentElement: i } = R();
    la(i);
    const u = A(() => e.position === "popper" ? e : {}), d = bt(u.value);
    function p(f) {
      s.onSelectedValueChange("");
    }
    ae(() => {
      s.onContentElementChange(i.value);
    });
    const c = {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
      "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
      "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
    };
    return Tu({ position: l }), (f, v) => (g(), w(o(On), null, {
      default: m(() => [
        f.dismissable ? (g(), w(o(dt), {
          key: 0,
          "as-child": "",
          "disable-outside-pointer-events": f.disableOutsidePointerEvents,
          onDismiss: v[0] || (v[0] = (y) => o(s).onOpenChange(!1)),
          onFocusOutside: v[1] || (v[1] = (y) => {
            var h;
            (h = o(s).parentElement.value) != null && h.contains(y.target) && y.preventDefault(), n("focusOutside", y);
          }),
          onInteractOutside: v[2] || (v[2] = (y) => n("interactOutside", y)),
          onEscapeKeyDown: v[3] || (v[3] = (y) => n("escapeKeyDown", y)),
          onPointerDownOutside: v[4] || (v[4] = (y) => {
            var h;
            (h = o(s).parentElement.value) != null && h.contains(y.target) && y.preventDefault(), n("pointerDownOutside", y);
          })
        }, {
          default: m(() => [
            (g(), w(Ge(o(l) === "popper" ? o(ht) : o(O)), k({ ...f.$attrs, ...o(d) }, {
              id: o(s).contentId,
              ref: o(r),
              role: "listbox",
              "data-state": o(s).open.value ? "open" : "closed",
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none",
                ...o(l) === "popper" ? c : {}
              },
              onPointerleave: p
            }), {
              default: m(() => [
                C(f.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"]))
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])) : (g(), w(Ge(o(l) === "popper" ? o(ht) : o(O)), k({ key: 1 }, { ...f.$attrs, ...u.value }, {
          id: o(s).contentId,
          ref: o(r),
          role: "listbox",
          "data-state": o(s).open.value ? "open" : "closed",
          style: {
            // flex layout so we can place the scroll buttons properly
            display: "flex",
            flexDirection: "column",
            // reset the outline by default as the content MAY get focused
            outline: "none",
            ...o(l) === "popper" ? c : {}
          },
          onPointerleave: p
        }), {
          default: m(() => [
            C(f.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "data-state", "style"]))
      ]),
      _: 3
    }));
  }
}), kf = /* @__PURE__ */ _({
  __name: "ComboboxContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(a, { emit: t }) {
    const l = be(a, t), { forwardRef: s } = R(), r = qe();
    return r.contentId || (r.contentId = ve(void 0, "radix-vue-combobox-content")), (i, u) => (g(), w(o(we), {
      present: i.forceMount || o(r).open.value
    }, {
      default: m(() => [
        j(Iu, k({ ...o(l), ...i.$attrs }, { ref: o(s) }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Mf = /* @__PURE__ */ _({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    R();
    const e = qe(), n = A(() => e.filteredOptions.value.length === 0);
    return (l, s) => n.value ? (g(), w(o(O), N(k({ key: 0 }, t)), {
      default: m(() => [
        C(l.$slots, "default", {}, () => [
          me("No options")
        ])
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), Vf = /* @__PURE__ */ _({
  __name: "ComboboxViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e } = R();
    return (n, l) => (g(), fe(xe, null, [
      j(o(O), k({ ...n.$attrs, ...t }, {
        ref: o(e),
        "data-radix-combobox-viewport": "",
        role: "presentation",
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        }
      }), {
        default: m(() => [
          C(n.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"]),
      j(o(O), {
        as: "style",
        nonce: n.nonce
      }, {
        default: m(() => [
          me(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
}), [Ou, ku] = q("ComboboxItem"), Mu = "combobox.select", Ff = /* @__PURE__ */ _({
  __name: "ComboboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, n = t, { disabled: l } = te(e), s = qe();
    _l({ id: "", options: B([]) });
    const { forwardRef: r } = R(), i = A(
      () => {
        var y, h;
        return s.multiple.value && Array.isArray(s.modelValue.value) ? (y = s.modelValue.value) == null ? void 0 : y.some((x) => $t(x, e.value)) : $t((h = s.modelValue) == null ? void 0 : h.value, e.value);
      }
    ), u = A(() => $t(s.selectedValue.value, e.value)), d = ve(void 0, "radix-vue-combobox-item"), p = A(() => s.isUserInputted.value ? s.searchTerm.value === "" || !!s.filteredOptions.value.find((y) => $t(y, e.value)) : !0);
    async function c(y) {
      n("select", y), !(y != null && y.defaultPrevented) && !l.value && y && s.onValueChange(e.value);
    }
    function f(y) {
      if (!y)
        return;
      const h = { originalEvent: y, value: e.value };
      yn(Mu, c, h);
    }
    async function v(y) {
      await ne(), !y.defaultPrevented && s.onSelectedValueChange(e.value);
    }
    if (e.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return ku({
      isSelected: i
    }), (y, h) => (g(), w(o(kn), null, {
      default: m(() => [
        xa(j(o(O), {
          ref: o(r),
          role: "option",
          tabindex: "-1",
          "aria-labelledby": o(d),
          "data-highlighted": u.value ? "" : void 0,
          "aria-selected": i.value,
          "data-state": i.value ? "checked" : "unchecked",
          "aria-disabled": o(l) || void 0,
          "data-disabled": o(l) ? "" : void 0,
          as: y.as,
          "as-child": y.asChild,
          "data-hidden": p.value ? void 0 : !0,
          onClick: f,
          onPointermove: v
        }, {
          default: m(() => [
            C(y.$slots, "default", {}, () => [
              me(ke(y.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "as", "as-child", "data-hidden"]), [
          [vn, p.value]
        ])
      ]),
      _: 3
    }));
  }
}), Lf = /* @__PURE__ */ _({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a;
    R();
    const e = Ou();
    return (n, l) => o(e).isSelected.value ? (g(), w(o(O), k({
      key: 0,
      "aria-hidden": ""
    }, t), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), Nf = /* @__PURE__ */ _({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(O), k(t, { "aria-hidden": "" }), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zf = /* @__PURE__ */ _({
  __name: "ComboboxArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a, e = qe(), n = Au();
    return R(), (l, s) => o(e).open.value && o(n).position.value === "popper" ? (g(), w(o(Mt), N(k({ key: 0 }, t)), {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), Kf = /* @__PURE__ */ _({
  __name: "ComboboxPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ra = /* @__PURE__ */ _({
  __name: "MenuAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(wt), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Mn = /* @__PURE__ */ _({
  __name: "MenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Mt), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [xt, wl] = q(["MenuRoot", "MenuSub"], "MenuContext"), [sa, Vu] = q("MenuRoot"), Vn = /* @__PURE__ */ _({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, { modal: l, dir: s } = te(e), r = Pe(s), i = Q(e, "open", n), u = B(), d = B(!1);
    return de((p) => {
      if (!Ue)
        return;
      const c = () => {
        d.value = !0, document.addEventListener("pointerdown", f, {
          capture: !0,
          once: !0
        }), document.addEventListener("pointermove", f, {
          capture: !0,
          once: !0
        });
      }, f = () => d.value = !1;
      document.addEventListener("keydown", c, { capture: !0 }), p(() => {
        document.removeEventListener("keydown", c, { capture: !0 }), document.removeEventListener("pointerdown", f, {
          capture: !0
        }), document.removeEventListener("pointermove", f, {
          capture: !0
        });
      });
    }), wl({
      open: i,
      onOpenChange: (p) => {
        i.value = p;
      },
      content: u,
      onContentChange: (p) => {
        u.value = p;
      }
    }), Vu({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: r,
      modal: l
    }), (p, c) => (g(), w(o(_t), null, {
      default: m(() => [
        C(p.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Fu = "rovingFocusGroup.onEntryFocus", Lu = { bubbles: !1, cancelable: !0 }, Nu = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function zu(a, t) {
  return t !== "rtl" ? a : a === "ArrowLeft" ? "ArrowRight" : a === "ArrowRight" ? "ArrowLeft" : a;
}
function Ku(a, t, e) {
  const n = zu(a.key, e);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return Nu[n];
}
function xl(a) {
  const t = document.activeElement;
  for (const e of a)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function Hu(a, t) {
  return a.map((e, n) => a[(t + n) % a.length]);
}
const [Wu, ju] = q("RovingFocusGroup"), Ft = /* @__PURE__ */ _({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(a, { emit: t }) {
    const e = a, n = t, { loop: l, orientation: s, dir: r } = te(e), i = Pe(r), u = Q(e, "currentTabStopId", n, {
      defaultValue: e.defaultCurrentTabStopId,
      passive: e.currentTabStopId === void 0
    }), d = B(!1), p = B(!1), c = B(0), { forwardRef: f, currentElement: v } = R(), { createCollection: y } = Te("rovingFocus"), h = y(v);
    function x(P) {
      const $ = !p.value;
      if (P.currentTarget && P.target === P.currentTarget && $ && !d.value) {
        const b = new CustomEvent(Fu, Lu);
        if (P.currentTarget.dispatchEvent(b), n("entryFocus", b), !b.defaultPrevented) {
          const S = h.value, D = S.find((M) => M.getAttribute("data-active") === "true"), E = S.find(
            (M) => M.id === u.value
          ), T = [D, E, ...S].filter(
            Boolean
          );
          xl(T);
        }
      }
      p.value = !1;
    }
    return ju({
      loop: l,
      dir: i,
      orientation: s,
      currentTabStopId: u,
      onItemFocus: (P) => {
        u.value = P;
      },
      onItemShiftTab: () => {
        d.value = !0;
      },
      onFocusableItemAdd: () => {
        c.value++;
      },
      onFocusableItemRemove: () => {
        c.value--;
      }
    }), (P, $) => (g(), w(o(O), {
      ref: o(f),
      tabindex: d.value || c.value === 0 ? -1 : 0,
      "data-orientation": o(s),
      as: P.as,
      "as-child": P.asChild,
      dir: o(i),
      style: { outline: "none" },
      onMousedown: $[0] || ($[0] = (b) => p.value = !0),
      onFocus: x,
      onBlur: $[1] || ($[1] = (b) => d.value = !1)
    }, {
      default: m(() => [
        C(P.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"]));
  }
}), Lt = /* @__PURE__ */ _({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a, e = Wu(), n = A(() => t.tabStopId || ve()), l = A(
      () => e.currentTabStopId.value === n.value
    ), { injectCollection: s } = Te("rovingFocus"), r = s();
    ae(() => {
      t.focusable && e.onFocusableItemAdd();
    }), De(() => {
      t.focusable && e.onFocusableItemRemove();
    });
    function i(u) {
      if (u.key === "Tab" && u.shiftKey) {
        e.onItemShiftTab();
        return;
      }
      if (u.target !== u.currentTarget)
        return;
      const d = Ku(
        u,
        e.orientation.value,
        e.dir.value
      );
      if (d !== void 0) {
        if (u.metaKey || u.ctrlKey || u.altKey || u.shiftKey)
          return;
        u.preventDefault();
        let p = [...r.value];
        if (d === "last")
          p.reverse();
        else if (d === "prev" || d === "next") {
          d === "prev" && p.reverse();
          const c = p.indexOf(
            u.currentTarget
          );
          p = e.loop.value ? Hu(p, c + 1) : p.slice(c + 1);
        }
        ne(() => xl(p));
      }
    }
    return (u, d) => (g(), w(o(O), {
      "data-radix-vue-collection-item": "",
      tabindex: l.value ? 0 : -1,
      "data-orientation": o(e).orientation.value,
      "data-active": u.active,
      "data-disabled": !u.focusable || void 0,
      as: u.as,
      "as-child": u.asChild,
      onMousedown: d[0] || (d[0] = (p) => {
        u.focusable ? o(e).onItemFocus(n.value) : p.preventDefault();
      }),
      onFocus: d[1] || (d[1] = (p) => o(e).onItemFocus(n.value)),
      onKeydown: i
    }, {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"]));
  }
}), [Fn, Gu] = q("MenuContent"), Ln = /* @__PURE__ */ _({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ Lo({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...gl
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = xt(), s = sa(), { trapFocus: r, disableOutsidePointerEvents: i, loop: u } = te(e);
    Pn(), oa(i.value);
    const d = B(""), p = B(0), c = B(0), f = B(null), v = B("right"), y = B(0), h = B(null), { createCollection: x } = Te(), { forwardRef: P, currentElement: $ } = R(), b = x($);
    J($, (I) => {
      l.onContentChange(I);
    });
    const { handleTypeaheadSearch: S } = Sn(b);
    De(() => {
      window.clearTimeout(p.value);
    });
    function D(I) {
      var G, X;
      return v.value === ((G = f.value) == null ? void 0 : G.side) && Li(I, (X = f.value) == null ? void 0 : X.area);
    }
    async function E(I) {
      var L;
      n("openAutoFocus", I), !I.defaultPrevented && (I.preventDefault(), (L = $.value) == null || L.focus());
    }
    function T(I) {
      if (I.defaultPrevented)
        return;
      const G = I.target.closest("[data-radix-menu-content]") === I.currentTarget, X = I.ctrlKey || I.altKey || I.metaKey, H = I.key.length === 1, z = Ot(
        I,
        document.activeElement,
        $.value,
        {
          loop: u.value,
          arrowKeyOptions: "vertical",
          dir: s == null ? void 0 : s.dir.value,
          focus: !0,
          attributeName: "[data-radix-vue-collection-item]:not([data-disabled])"
        }
      );
      if (z)
        return z == null ? void 0 : z.focus();
      if (I.code === "Space" || (G && (I.key === "Tab" && I.preventDefault(), !X && H && S(I.key)), I.target !== $.value) || !ki.includes(I.key))
        return;
      I.preventDefault();
      const F = b.value;
      cl.includes(I.key) && F.reverse(), ln(F);
    }
    function M(I) {
      var L, G;
      (G = (L = I == null ? void 0 : I.currentTarget) == null ? void 0 : L.contains) != null && G.call(L, I.target) || (window.clearTimeout(p.value), d.value = "");
    }
    function V(I) {
      var X;
      if (!Xt(I))
        return;
      const L = I.target, G = y.value !== I.clientX;
      if ((X = I == null ? void 0 : I.currentTarget) != null && X.contains(L) && G) {
        const H = I.clientX > y.value ? "right" : "left";
        v.value = H, y.value = I.clientX;
      }
    }
    return Gu({
      onItemEnter: (I) => !!D(I),
      onItemLeave: (I) => {
        var L;
        D(I) || ((L = $.value) == null || L.focus(), h.value = null);
      },
      onTriggerLeave: (I) => !!D(I),
      searchRef: d,
      pointerGraceTimerRef: c,
      onPointerGraceIntentChange: (I) => {
        f.value = I;
      }
    }), (I, L) => (g(), w(o(Ba), {
      "as-child": "",
      trapped: o(r),
      onMountAutoFocus: E,
      onUnmountAutoFocus: L[7] || (L[7] = (G) => n("closeAutoFocus", G))
    }, {
      default: m(() => [
        j(o(dt), {
          "as-child": "",
          "disable-outside-pointer-events": o(i),
          onEscapeKeyDown: L[2] || (L[2] = (G) => n("escapeKeyDown", G)),
          onPointerDownOutside: L[3] || (L[3] = (G) => n("pointerDownOutside", G)),
          onFocusOutside: L[4] || (L[4] = (G) => n("focusOutside", G)),
          onInteractOutside: L[5] || (L[5] = (G) => n("interactOutside", G)),
          onDismiss: L[6] || (L[6] = (G) => n("dismiss"))
        }, {
          default: m(() => [
            j(o(Ft), {
              "current-tab-stop-id": h.value,
              "onUpdate:currentTabStopId": L[0] || (L[0] = (G) => h.value = G),
              "as-child": "",
              orientation: "vertical",
              dir: o(s).dir.value,
              loop: o(u),
              onEntryFocus: L[1] || (L[1] = (G) => {
                n("entryFocus", G), o(s).isUsingKeyboardRef.value || G.preventDefault();
              })
            }, {
              default: m(() => [
                j(o(ht), {
                  ref: o(P),
                  role: "menu",
                  as: I.as,
                  "as-child": I.asChild,
                  "aria-orientation": "vertical",
                  "data-radix-menu-content": "",
                  "data-state": o(Rn)(o(l).open.value),
                  dir: o(s).dir.value,
                  side: I.side,
                  "side-offset": I.sideOffset,
                  align: I.align,
                  "align-offset": I.alignOffset,
                  "avoid-collisions": I.avoidCollisions,
                  "collision-boundary": I.collisionBoundary,
                  "collision-padding": I.collisionPadding,
                  "arrow-padding": I.arrowPadding,
                  "prioritize-position": I.prioritizePosition,
                  sticky: I.sticky,
                  "hide-when-detached": I.hideWhenDetached,
                  onKeydown: T,
                  onBlur: M,
                  onPointermove: V
                }, {
                  default: m(() => [
                    C(I.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "sticky", "hide-when-detached"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Pl = /* @__PURE__ */ _({
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Fn(), n = B(!1);
    async function l(r) {
      if (!r.defaultPrevented && Xt(r)) {
        if (t.disabled)
          e.onItemLeave(r);
        else if (!e.onItemEnter(r)) {
          const u = r.currentTarget;
          u == null || u.focus();
        }
      }
    }
    async function s(r) {
      await ne(), !r.defaultPrevented && Xt(r) && e.onItemLeave(r);
    }
    return (r, i) => (g(), w(o(O), {
      role: "menuitem",
      tabindex: "-1",
      as: r.as,
      "as-child": r.asChild,
      "data-radix-vue-collection-item": "",
      "aria-disabled": r.disabled || void 0,
      "data-disabled": r.disabled ? "" : void 0,
      "data-highlighted": n.value ? "" : void 0,
      onPointermove: l,
      onPointerleave: s,
      onFocus: i[0] || (i[0] = async (u) => {
        await ne(), !(u.defaultPrevented || r.disabled) && (n.value = !0);
      }),
      onBlur: i[1] || (i[1] = async (u) => {
        await ne(), !u.defaultPrevented && (n.value = !1);
      })
    }, {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"]));
  }
}), ra = /* @__PURE__ */ _({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = sa(), i = Fn(), u = B(!1);
    async function d() {
      const p = s.value;
      if (!e.disabled && p) {
        const c = new CustomEvent(Ii, {
          bubbles: !0,
          cancelable: !0
        });
        n("select", c), await ne(), c.defaultPrevented ? u.value = !1 : r.onClose();
      }
    }
    return (p, c) => (g(), w(Pl, k(e, {
      ref: o(l),
      onClick: d,
      onPointerdown: c[0] || (c[0] = () => {
        u.value = !0;
      }),
      onPointerup: c[1] || (c[1] = async (f) => {
        var v;
        await ne(), !f.defaultPrevented && (u.value || (v = f.currentTarget) == null || v.click());
      }),
      onKeydown: c[2] || (c[2] = async (f) => {
        const v = o(i).searchRef.value !== "";
        p.disabled || v && f.key === " " || o(on).includes(f.key) && (f.currentTarget.click(), f.preventDefault());
      })
    }), {
      default: m(() => [
        C(p.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Uu, Sl] = q(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
), Nn = /* @__PURE__ */ _({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = Uu({
      checked: B(!1)
    });
    return (e, n) => (g(), w(o(we), {
      present: e.forceMount || o(Ca)(o(t).checked.value) || o(t).checked.value === !0
    }, {
      default: m(() => [
        j(o(O), {
          as: e.as,
          "as-child": e.asChild,
          "data-state": o(An)(o(t).checked.value)
        }, {
          default: m(() => [
            C(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), zn = /* @__PURE__ */ _({
  __name: "MenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String], default: !1 },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = Q(e, "checked", n);
    return Sl({ checked: l }), (s, r) => (g(), w(ra, k({ role: "menuitemcheckbox" }, e, {
      "aria-checked": o(Ca)(o(l)) ? "mixed" : o(l),
      "data-state": o(An)(o(l)),
      onSelect: r[0] || (r[0] = async (i) => {
        n("select", i), o(Ca)(o(l)) ? l.value = !0 : l.value = !o(l);
      })
    }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), qu = /* @__PURE__ */ _({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = be(e, n), s = xt(), { forwardRef: r, currentElement: i } = R();
    return la(i), (u, d) => (g(), w(Ln, k(o(l), {
      ref: o(r),
      "trap-focus": o(s).open.value,
      "disable-outside-pointer-events": o(s).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (p) => o(s).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = ye((p) => n("focusOutside", p), ["prevent"]))
    }), {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), Yu = /* @__PURE__ */ _({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t), s = xt();
    return (r, i) => (g(), w(Ln, k(o(l), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (u) => o(s).onOpenChange(!1))
    }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Kn = /* @__PURE__ */ _({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t), s = xt(), r = sa();
    return (i, u) => (g(), w(o(we), {
      present: i.forceMount || o(s).open.value
    }, {
      default: m(() => [
        o(r).modal.value ? (g(), w(qu, N(k({ key: 0 }, { ...i.$attrs, ...o(l) })), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (g(), w(Yu, N(k({ key: 1 }, { ...i.$attrs, ...o(l) })), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Aa = /* @__PURE__ */ _({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), k({ role: "group" }, t), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hn = /* @__PURE__ */ _({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Wn = /* @__PURE__ */ _({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Xu, Zu] = q("MenuRadioGroup"), jn = /* @__PURE__ */ _({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "modelValue", t);
    return Zu({
      modelValue: l,
      onValueChange: (s) => {
        l.value = s;
      }
    }), (s, r) => (g(), w(Aa, N(K(e)), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Gn = /* @__PURE__ */ _({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, n = t, { value: l } = te(e), s = Xu(), r = A(
      () => s.modelValue.value === (l == null ? void 0 : l.value)
    );
    return Sl({ checked: r }), (i, u) => (g(), w(ra, k({ role: "menuitemradio" }, e, {
      "aria-checked": r.value,
      "data-state": o(An)(r.value),
      onSelect: u[0] || (u[0] = async (d) => {
        n("select", d), o(s).onValueChange(o(l));
      })
    }), {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Un = /* @__PURE__ */ _({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), k(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Dl, Ju] = q("MenuSub"), qn = /* @__PURE__ */ _({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "open", t, {
      defaultValue: !1,
      passive: e.open === void 0
    }), s = xt(), r = B(), i = B();
    return de((u) => {
      (s == null ? void 0 : s.open.value) === !1 && (l.value = !1), u(() => l.value = !1);
    }), wl({
      open: l,
      onOpenChange: (u) => {
        l.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), Ju({
      triggerId: "",
      contentId: "",
      trigger: r,
      onTriggerChange: (u) => {
        r.value = u;
      }
    }), (u, d) => (g(), w(o(_t), null, {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Yn = /* @__PURE__ */ _({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t), s = xt(), r = sa(), i = Dl(), { forwardRef: u, currentElement: d } = R();
    return i.contentId || (i.contentId = ve(void 0, "radix-vue-menu-sub-content")), (p, c) => (g(), w(o(we), {
      present: p.forceMount || o(s).open.value
    }, {
      default: m(() => [
        j(Ln, k(o(l), {
          id: o(i).contentId,
          ref: o(u),
          "aria-labelledby": o(i).triggerId,
          align: "start",
          side: o(r).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": !1,
          "disable-outside-scroll": !1,
          "trap-focus": !1,
          onOpenAutoFocus: c[0] || (c[0] = ye((f) => {
            var v;
            o(r).isUsingKeyboardRef.value && ((v = o(d)) == null || v.focus());
          }, ["prevent"])),
          onCloseAutoFocus: c[1] || (c[1] = ye(() => {
          }, ["prevent"])),
          onFocusOutside: c[2] || (c[2] = (f) => {
            f.defaultPrevented || f.target !== o(i).trigger.value && o(s).onOpenChange(!1);
          }),
          onEscapeKeyDown: c[3] || (c[3] = (f) => {
            o(r).onClose(), f.preventDefault();
          }),
          onKeydown: c[4] || (c[4] = (f) => {
            var h, x;
            const v = (h = f.currentTarget) == null ? void 0 : h.contains(f.target), y = o(Vi)[o(r).dir.value].includes(f.key);
            v && y && (o(s).onOpenChange(!1), (x = o(i).trigger.value) == null || x.focus(), f.preventDefault());
          })
        }), {
          default: m(() => [
            C(p.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Xn = /* @__PURE__ */ _({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = xt(), n = sa(), l = Dl(), s = Fn(), r = B(null);
    l.triggerId || (l.triggerId = ve(void 0, "radix-vue-menu-sub-trigger"));
    function i() {
      r.value && window.clearTimeout(r.value), r.value = null;
    }
    De(() => {
      i();
    });
    function u(c) {
      !Xt(c) || s.onItemEnter(c) || !t.disabled && !e.open.value && !r.value && (s.onPointerGraceIntentChange(null), r.value = window.setTimeout(() => {
        e.onOpenChange(!0), i();
      }, 100));
    }
    async function d(c) {
      var v, y;
      if (!Xt(c))
        return;
      i();
      const f = (v = e.content.value) == null ? void 0 : v.getBoundingClientRect();
      if (f != null && f.width) {
        const h = (y = e.content.value) == null ? void 0 : y.dataset.side, x = h === "right", P = x ? -5 : 5, $ = f[x ? "left" : "right"], b = f[x ? "right" : "left"];
        s.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: c.clientX + P, y: c.clientY },
            { x: $, y: f.top },
            { x: b, y: f.top },
            { x: b, y: f.bottom },
            { x: $, y: f.bottom }
          ],
          side: h
        }), window.clearTimeout(s.pointerGraceTimerRef.value), s.pointerGraceTimerRef.value = window.setTimeout(
          () => s.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (s.onTriggerLeave(c))
          return;
        s.onPointerGraceIntentChange(null);
      }
    }
    async function p(c) {
      var v;
      const f = s.searchRef.value !== "";
      t.disabled || f && c.key === " " || Mi[n.dir.value].includes(c.key) && (e.onOpenChange(!0), await ne(), (v = e.content.value) == null || v.focus(), c.preventDefault());
    }
    return (c, f) => (g(), w(Ra, { "as-child": "" }, {
      default: m(() => [
        j(Pl, k(t, {
          id: o(l).triggerId,
          ref: (v) => {
            var y;
            (y = o(l)) == null || y.onTriggerChange(v == null ? void 0 : v.$el);
          },
          "aria-haspopup": "menu",
          "aria-expanded": o(e).open.value,
          "aria-controls": o(l).contentId,
          "data-state": o(Rn)(o(e).open.value),
          onClick: f[0] || (f[0] = async (v) => {
            t.disabled || v.defaultPrevented || (v.currentTarget.focus(), o(e).open.value || o(e).onOpenChange(!0));
          }),
          onPointermove: u,
          onPointerleave: d,
          onKeydown: p
        }), {
          default: m(() => [
            C(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
      ]),
      _: 3
    }));
  }
}), [$l, Qu] = q("ContextMenuRoot"), Hf = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, { dir: l, modal: s } = te(e);
    R();
    const r = Pe(l), i = B(!1);
    return Qu({
      open: i,
      onOpenChange: (u) => {
        i.value = u;
      },
      dir: r,
      modal: s
    }), J(i, (u) => {
      n("update:open", u);
    }), (u, d) => (g(), w(o(Vn), {
      open: i.value,
      "onUpdate:open": d[0] || (d[0] = (p) => i.value = p),
      dir: o(r),
      modal: o(s)
    }, {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
});
function wo(a) {
  return a.pointerType !== "mouse";
}
const Wf = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a, { disabled: e } = te(t), { forwardRef: n } = R(), l = $l(), s = B({ x: 0, y: 0 }), r = A(() => ({
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        left: s.value.x,
        right: s.value.x,
        top: s.value.y,
        bottom: s.value.y,
        ...s.value
      })
    })), i = B(0);
    function u() {
      window.clearTimeout(i.value);
    }
    function d(v) {
      s.value = { x: v.clientX, y: v.clientY }, l.onOpenChange(!0);
    }
    async function p(v) {
      e.value || (await ne(), v.defaultPrevented || (u(), d(v), v.preventDefault()));
    }
    async function c(v) {
      e.value || (await ne(), wo(v) && !v.defaultPrevented && (u(), i.value = window.setTimeout(() => d(v), 700)));
    }
    async function f(v) {
      e.value || (await ne(), wo(v) && !v.defaultPrevented && u());
    }
    return (v, y) => (g(), fe(xe, null, [
      j(o(Ra), {
        as: "template",
        element: r.value
      }, null, 8, ["element"]),
      j(o(O), k({
        ref: o(n),
        as: v.as,
        "as-child": v.asChild,
        "data-state": o(l).open.value ? "open" : "closed",
        "data-disabled": o(e) ? "" : void 0,
        style: {
          WebkitTouchCallout: "none"
        }
      }, v.$attrs, {
        onContextmenu: p,
        onPointerdown: c,
        onPointermove: f,
        onPointercancel: f,
        onPointerup: f
      }), {
        default: m(() => [
          C(v.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "data-state", "data-disabled"])
    ], 64));
  }
}), jf = /* @__PURE__ */ _({
  __name: "ContextMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Wn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Gf = /* @__PURE__ */ _({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    alignOffset: { default: 0 },
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    R();
    const s = $l(), r = B(!1);
    return (i, u) => (g(), w(o(Kn), k(o(l), {
      side: "right",
      "side-offset": 2,
      align: "start",
      style: {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        !d.defaultPrevented && r.value && d.preventDefault(), r.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        !d.defaultPrevented && !o(s).modal.value && (r.value = !0);
      })
    }), {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Uf = /* @__PURE__ */ _({
  __name: "ContextMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Mn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qf = /* @__PURE__ */ _({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(ra), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Yf = /* @__PURE__ */ _({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Aa), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Xf = /* @__PURE__ */ _({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Un), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zf = /* @__PURE__ */ _({
  __name: "ContextMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(zn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jf = /* @__PURE__ */ _({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Nn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qf = /* @__PURE__ */ _({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Hn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ev = /* @__PURE__ */ _({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(jn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tv = /* @__PURE__ */ _({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(Gn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), av = /* @__PURE__ */ _({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    const l = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    return (s, r) => (g(), w(o(qn), {
      open: o(l),
      "onUpdate:open": r[0] || (r[0] = (i) => yt(l) ? l.value = i : null)
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), nv = /* @__PURE__ */ _({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return R(), (s, r) => (g(), w(o(Yn), k(o(l), { style: {
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), ov = /* @__PURE__ */ _({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Xn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ed = ["hour", "minute", "second"];
function Et(a) {
  const { formatter: t } = a, e = gn.map((n) => [n, a.value[n]]);
  if ("hour" in a.value) {
    const n = Xo.map((s) => s === "dayPeriod" ? [s, t.dayPeriod(Ve(a.value))] : [s, a.value[s]]), l = [...e, ...n];
    return Object.fromEntries(l);
  }
  return Object.fromEntries(e);
}
function El(a) {
  const t = Zo.map((e) => e === "dayPeriod" ? [e, "AM"] : [e, null]).filter(([e]) => e === "literal" || e === null ? !1 : a === "day" ? !ed.includes(e) : !0);
  return Object.fromEntries(t);
}
function td(a) {
  const { segmentValues: t, formatter: e, locale: n } = a;
  function l(r) {
    if ("hour" in t) {
      const i = t[r];
      return i !== null ? r === "day" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r, {
        hourCycle: a.hourCycle === 24 ? "h24" : void 0
      }) : e.part(a.dateRef.set({ [r]: i }), r, {
        hourCycle: a.hourCycle === 24 ? "h24" : void 0
      }) : qa(r, "", n.value);
    } else {
      if (br(r)) {
        const i = t[r];
        return i !== null ? r === "day" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r) : e.part(a.dateRef.set({ [r]: i }), r) : qa(r, "", n.value);
      }
      return "";
    }
  }
  return Object.keys(t).reduce((r, i) => {
    if (!Jo(i))
      return r;
    if ("hour" in t && i === "dayPeriod") {
      const u = t[i];
      u !== null ? r[i] = u : r[i] = qa(i, "AM", n.value);
    } else
      r[i] = l(i);
    return r;
  }, {});
}
function ad(a) {
  const { granularity: t, formatter: e, contentObj: n, hideTimeZone: l, hourCycle: s } = a;
  return e.toParts(a.dateRef, Cr(t, s)).map((u) => ["literal", "timeZoneName", null].includes(u.type) || !Jo(u.type) ? {
    part: u.type,
    value: u.value
  } : {
    part: u.type,
    value: n[u.type]
  }).filter((u) => !(u.part === null || u.value === null || u.part === "timeZoneName" && (!na(a.dateRef) || l)));
}
function rn(a) {
  const t = td(a), e = ad({
    contentObj: t,
    ...a
  });
  return {
    obj: t,
    arr: e
  };
}
function Ke(a) {
  const t = Ct();
  return a === t.ARROW_RIGHT || a === t.ARROW_LEFT;
}
function vt(a) {
  return !Number.isNaN(Number.parseInt(a));
}
function Ze(a) {
  const t = Ct();
  return !!([
    t.ENTER,
    t.ARROW_UP,
    t.ARROW_DOWN,
    t.ARROW_LEFT,
    t.ARROW_RIGHT,
    t.BACKSPACE,
    t.SPACE
  ].includes(a) || vt(a));
}
const nd = ["id", "value", "name", "disabled", "required"], [od, ld] = q("DateFieldRoot"), sd = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "DateFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    name: {},
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(a, { expose: t, emit: e }) {
    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, granularity: d } = te(n), p = xn(n.locale), { primitiveElement: c, currentElement: f } = it(), v = B(/* @__PURE__ */ new Set());
    ae(() => {
      Array.from(f.value.querySelectorAll("[data-radix-vue-date-field-segment]")).filter((z) => z.getAttribute("data-radix-vue-date-field-segment") !== "literal").forEach((z) => v.value.add(z));
    });
    const y = Q(n, "modelValue", l, {
      defaultValue: n.defaultValue ?? void 0,
      passive: n.modelValue === void 0
    }), h = Tt({
      defaultPlaceholder: n.placeholder,
      granularity: d.value,
      defaultValue: y.value
    }), x = Q(n, "placeholder", l, {
      defaultValue: n.defaultPlaceholder ?? h.copy(),
      passive: n.placeholder === void 0
    }), P = A(() => n.granularity ? qt(x.value) ? n.granularity : "day" : qt(x.value) ? "minute" : "day"), $ = A(() => {
      var z;
      return y.value ? !!((z = u.value) != null && z.call(u, y.value) || n.minValue && Be(y.value, n.minValue) || n.maxValue && Be(n.maxValue, y.value)) : !1;
    }), b = El(P.value), S = B(y.value ? { ...Et({ value: y.value, formatter: p }) } : { ...b }), D = A(() => rn({
      granularity: P.value,
      dateRef: x.value,
      formatter: p,
      hideTimeZone: n.hideTimeZone,
      hourCycle: n.hourCycle,
      segmentValues: S.value,
      locale: s
    })), E = A(() => D.value.arr), T = A(() => E.value.filter(({ part: z }) => z !== "literal"));
    J(s, (z) => {
      p.getLocale() !== z && p.setLocale(z);
    }), J(y, (z) => {
      z !== void 0 && (!Re(x.value, z) || x.value.compare(z) !== 0) && (x.value = z.copy());
    }), J([y, s], ([z]) => {
      z !== void 0 ? S.value = { ...Et({ value: z, formatter: p }) } : S.value = { ...b };
    });
    const M = B(null), V = A(() => Array.from(v.value).findIndex((z) => {
      var F;
      return z.getAttribute("data-radix-vue-date-field-segment") === ((F = M.value) == null ? void 0 : F.getAttribute("data-radix-vue-date-field-segment"));
    })), I = A(() => V.value > v.value.size - 1 ? null : Array.from(v.value)[V.value + 1]), L = A(() => V.value < 0 ? null : Array.from(v.value)[V.value - 1]), G = Ct();
    function X(z) {
      var F, Y;
      Ke(z.key) && (z.key === G.ARROW_LEFT && ((F = L.value) == null || F.focus()), z.key === G.ARROW_RIGHT && ((Y = I.value) == null || Y.focus()));
    }
    function H(z) {
      M.value = z;
    }
    return ld({
      isDateUnavailable: u.value,
      locale: s,
      modelValue: y,
      placeholder: x,
      disabled: r,
      formatter: p,
      hourCycle: n.hourCycle,
      readonly: i,
      segmentValues: S,
      isInvalid: $,
      segmentContents: T,
      elements: v,
      setFocusedElement: H,
      focusNext() {
        var z;
        (z = I.value) == null || z.focus();
      }
    }), t({
      /** Helper to set the focused element inside the DateField */
      setFocusedElement: H
    }), (z, F) => (g(), fe(xe, null, [
      j(o(O), k(z.$attrs, {
        ref_key: "primitiveElement",
        ref: c,
        role: "group",
        "aria-disabled": o(r) ? !0 : void 0,
        "data-disabled": o(r) ? "" : void 0,
        "data-readonly": o(i) ? "" : void 0,
        "data-invalid": $.value ? "" : void 0,
        onKeydown: he(X, ["left", "right"])
      }), {
        default: m(() => [
          C(z.$slots, "default", {
            modelValue: o(y),
            segments: E.value,
            isInvalid: $.value
          })
        ]),
        _: 3
      }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid"]),
      He("input", {
        id: z.id,
        type: "text",
        tabindex: "-1",
        "aria-hidden": "",
        value: o(y) ? o(y).toString() : "",
        name: z.name,
        disabled: o(r),
        required: z.required,
        style: ge({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }),
        onFocus: F[0] || (F[0] = (Y) => {
          var U, Z;
          return (Z = (U = Array.from(v.value)) == null ? void 0 : U[0]) == null ? void 0 : Z.focus();
        })
      }, null, 44, nd)
    ], 64));
  }
}), Pt = {
  role: "spinbutton",
  contenteditable: !0,
  tabindex: 0,
  spellcheck: !1,
  inputmode: "numeric",
  autocorrect: "off",
  enterkeyhint: "next",
  style: "caret-color: transparent;"
};
function rd(a) {
  const { segmentValues: t, placeholder: e } = a, n = t.day === null, l = t.day ? e.set({ day: t.day }) : e, s = l.day, r = 1, i = ba(l), u = n ? "Empty" : `${s}`;
  return {
    ...Pt,
    "aria-label": "day,",
    "aria-valuemin": r,
    "aria-valuemax": i,
    "aria-valuenow": s,
    "aria-valuetext": u
  };
}
function id(a) {
  const { segmentValues: t, placeholder: e, formatter: n } = a, l = t.month === null, s = t.month ? e.set({ month: t.month }) : e, r = s.month, i = 1, u = 12, d = l ? "Empty" : `${r} - ${n.fullMonth(Ve(s))}`;
  return {
    ...Pt,
    "aria-label": "month, ",
    contenteditable: !0,
    "aria-valuemin": i,
    "aria-valuemax": u,
    "aria-valuenow": r,
    "aria-valuetext": d
  };
}
function ud(a) {
  const { segmentValues: t, placeholder: e } = a, n = t.year === null, l = t.year ? e.set({ year: t.year }) : e, s = 1, r = 9999, i = l.year, u = n ? "Empty" : `${i}`;
  return {
    ...Pt,
    "aria-label": "year, ",
    "aria-valuemin": s,
    "aria-valuemax": r,
    "aria-valuenow": i,
    "aria-valuetext": u
  };
}
function dd(a) {
  const { segmentValues: t, hourCycle: e, placeholder: n } = a;
  if (!("hour" in t) || !("hour" in n))
    return {};
  const l = t.hour === null, s = t.hour ? n.set({ hour: t.hour }) : n, r = e === 12 ? 1 : 0, i = e === 12 ? 12 : 23, u = s.hour, d = l ? "Empty" : `${u} ${t.dayPeriod ?? ""}`;
  return {
    ...Pt,
    "aria-label": "hour, ",
    "aria-valuemin": r,
    "aria-valuemax": i,
    "aria-valuenow": u,
    "aria-valuetext": d
  };
}
function cd(a) {
  const { segmentValues: t, placeholder: e } = a;
  if (!("minute" in t) || !("minute" in e))
    return {};
  const n = t.minute === null, s = (t.minute ? e.set({ minute: t.minute }) : e).minute, r = 0, i = 59, u = n ? "Empty" : `${s}`;
  return {
    ...Pt,
    "aria-label": "minute, ",
    "aria-valuemin": r,
    "aria-valuemax": i,
    "aria-valuenow": s,
    "aria-valuetext": u
  };
}
function pd(a) {
  const { segmentValues: t, placeholder: e } = a;
  if (!("second" in t) || !("second" in e))
    return {};
  const n = t.second === null, s = (t.second ? e.set({ second: t.second }) : e).second, r = 0, i = 59, u = n ? "Empty" : `${s}`;
  return {
    ...Pt,
    "aria-label": "second, ",
    "aria-valuemin": r,
    "aria-valuemax": i,
    "aria-valuenow": s,
    "aria-valuetext": u
  };
}
function fd(a) {
  const { segmentValues: t } = a;
  if (!("dayPeriod" in t))
    return {};
  const e = 0, n = 12, l = t.hour ? t.hour > 12 ? t.hour - 12 : t.hour : 0, s = t.dayPeriod ?? "AM";
  return {
    ...Pt,
    inputmode: "text",
    "aria-label": "AM/PM",
    "aria-valuemin": e,
    "aria-valuemax": n,
    "aria-valuenow": l,
    "aria-valuetext": s
  };
}
function vd(a) {
  return {
    "aria-hidden": !0,
    "data-segment": "literal"
  };
}
function md(a) {
  return {
    role: "textbox",
    "aria-label": "timezone, ",
    "data-readonly": !0,
    "data-segment": "timeZoneName",
    tabindex: 0,
    style: "caret-color: transparent;"
  };
}
const hd = {
  day: {
    attrs: rd
  },
  month: {
    attrs: id
  },
  year: {
    attrs: ud
  },
  hour: {
    attrs: dd
  },
  minute: {
    attrs: cd
  },
  second: {
    attrs: pd
  },
  dayPeriod: {
    attrs: fd
  },
  literal: {
    attrs: vd
  },
  timeZoneName: {
    attrs: md
  }
};
function Bl(a) {
  const t = Ct();
  function e({ e: b, part: S, dateRef: D, prevValue: E }) {
    const T = b.key === t.ARROW_UP ? 1 : -1, M = 0, V = 59;
    if (E === null)
      return T > 0 ? M : V;
    const I = [S, T];
    return D.set({ [S]: E }).cycle(...I)[S];
  }
  function n(b) {
    if (a.hasLeftFocus.value = !1, b === null)
      return b;
    const S = b.toString();
    return S.length === 1 ? null : Number.parseInt(S.slice(0, -1));
  }
  function l({ e: b, part: S, dateRef: D, prevValue: E, hourCycle: T }) {
    const M = b.key === t.ARROW_UP ? 1 : -1;
    if (E === null)
      return D[S];
    if (S === "hour" && "hour" in D) {
      const I = [S, M, { hourCycle: T }];
      return D.set({ [S]: E }).cycle(...I)[S];
    }
    const V = [S, M];
    return S === "day" && a.segmentValues.value.month !== null ? D.set({ [S]: E, month: a.segmentValues.value.month }).cycle(...V)[S] : D.set({ [S]: E }).cycle(...V)[S];
  }
  function s(b, S, D) {
    let E = !1;
    const T = Math.floor(b / 10);
    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, D = null), D === null)
      return S === 0 ? (a.lastKeyZero.value = !0, { value: null, moveToNext: E }) : ((a.lastKeyZero.value || S > T) && (E = !0), a.lastKeyZero.value = !1, { value: S, moveToNext: E });
    const M = D.toString().length, V = Number.parseInt(D.toString() + S.toString());
    return M === 2 || V > b ? ((S > T || V > b) && (E = !0), { value: S, moveToNext: E }) : (E = !0, { value: V, moveToNext: E });
  }
  function r(b, S) {
    let E = !1;
    const T = Math.floor(59 / 10);
    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, S = null), S === null)
      return b === 0 ? (a.lastKeyZero.value = !0, { value: 0, moveToNext: E }) : ((a.lastKeyZero.value || b > T) && (E = !0), a.lastKeyZero.value = !1, { value: b, moveToNext: E });
    const M = S.toString().length, V = Number.parseInt(S.toString() + b.toString());
    return M === 2 || V > 59 ? (b > T && (E = !0), { value: b, moveToNext: E }) : (E = !0, { value: V, moveToNext: E });
  }
  function i(b, S) {
    let E = !1;
    const T = Math.floor(24 / 10);
    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, S = null), S === null)
      return b === 0 ? (a.lastKeyZero.value = !0, { value: null, moveToNext: E }) : ((a.lastKeyZero.value || b > T) && (E = !0), a.lastKeyZero.value = !1, { value: b, moveToNext: E });
    const M = S.toString().length, V = Number.parseInt(S.toString() + b.toString());
    return M === 2 || V > 24 ? (b > T && (E = !0), { value: b, moveToNext: E }) : (E = !0, { value: V, moveToNext: E });
  }
  function u(b, S) {
    let D = !1;
    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, S = null), S === null)
      return { value: b === 0 ? 1 : b, moveToNext: D };
    const E = S.toString() + b.toString();
    return E.length > 4 ? { value: b === 0 ? 1 : b, moveToNext: D } : (E.length === 4 && (D = !0), { value: Number.parseInt(E), moveToNext: D });
  }
  const d = A(() => hd[a.part].attrs({
    placeholder: a.placeholder.value,
    hourCycle: a.hourCycle,
    segmentValues: a.segmentValues.value,
    formatter: a.formatter
  }));
  function p(b) {
    if (!Ze(b.key) || Ke(b.key))
      return;
    const S = a.segmentValues.value.day;
    if (b.key === t.ARROW_DOWN || b.key === t.ARROW_UP) {
      a.segmentValues.value.day = l({ e: b, part: "day", dateRef: a.placeholder.value, prevValue: S });
      return;
    }
    if (vt(b.key)) {
      const D = Number.parseInt(b.key), E = a.segmentValues.value.month, T = ba(E ? a.placeholder.value.set({ month: E }) : a.placeholder.value), { value: M, moveToNext: V } = s(T, D, S);
      a.segmentValues.value.day = M, V && a.focusNext();
    }
    b.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.day = n(S));
  }
  function c(b) {
    if (!Ze(b.key) || Ke(b.key))
      return;
    const S = a.segmentValues.value.month;
    if (b.key === t.ARROW_DOWN || b.key === t.ARROW_UP) {
      a.segmentValues.value.month = l({ e: b, part: "month", dateRef: a.placeholder.value, prevValue: S });
      return;
    }
    if (vt(b.key)) {
      const D = Number.parseInt(b.key), { value: E, moveToNext: T } = s(12, D, S);
      a.segmentValues.value.month = E, T && a.focusNext();
    }
    b.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.month = n(S));
  }
  function f(b) {
    if (!Ze(b.key) || Ke(b.key))
      return;
    const S = a.segmentValues.value.year;
    if (b.key === t.ARROW_DOWN || b.key === t.ARROW_UP) {
      a.segmentValues.value.year = l({ e: b, part: "year", dateRef: a.placeholder.value, prevValue: S });
      return;
    }
    if (vt(b.key)) {
      const D = Number.parseInt(b.key), { value: E, moveToNext: T } = u(D, S);
      a.segmentValues.value.year = E, T && a.focusNext();
    }
    b.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.year = n(S));
  }
  function v(b) {
    const S = a.placeholder.value;
    if (!Ze(b.key) || Ke(b.key) || !("hour" in S) || !("hour" in a.segmentValues.value))
      return;
    const D = a.segmentValues.value.hour, E = a.hourCycle;
    if (b.key === t.ARROW_UP || b.key === t.ARROW_DOWN) {
      a.segmentValues.value.hour = l({ e: b, part: "hour", dateRef: a.placeholder.value, prevValue: D, hourCycle: E }), "dayPeriod" in a.segmentValues.value && (a.segmentValues.value.hour < 12 ? a.segmentValues.value.dayPeriod = "AM" : a.segmentValues.value.hour && (a.segmentValues.value.dayPeriod = "PM"));
      return;
    }
    if (vt(b.key)) {
      const T = Number.parseInt(b.key), { value: M, moveToNext: V } = i(T, D);
      "dayPeriod" in a.segmentValues.value && M && M > 12 ? a.segmentValues.value.dayPeriod = "PM" : "dayPeriod" in a.segmentValues.value && M && (a.segmentValues.value.dayPeriod = "AM"), a.segmentValues.value.hour = M, V && a.focusNext();
    }
    b.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.hour = n(D));
  }
  function y(b) {
    const S = a.placeholder.value;
    if (!Ze(b.key) || Ke(b.key) || !("minute" in S) || !("minute" in a.segmentValues.value))
      return;
    const D = a.segmentValues.value.minute;
    if (a.segmentValues.value.minute = e({ e: b, part: "minute", dateRef: a.placeholder.value, prevValue: D }), vt(b.key)) {
      const E = Number.parseInt(b.key), { value: T, moveToNext: M } = r(E, D);
      a.segmentValues.value.minute = T, M && a.focusNext();
    }
    b.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.minute = n(D));
  }
  function h(b) {
    const S = a.placeholder.value;
    if (!Ze(b.key) || Ke(b.key) || !("second" in S) || !("second" in a.segmentValues.value))
      return;
    const D = a.segmentValues.value.second;
    if (a.segmentValues.value.second = e({ e: b, part: "second", dateRef: a.placeholder.value, prevValue: D }), vt(b.key)) {
      const E = Number.parseInt(b.key), { value: T, moveToNext: M } = r(E, D);
      a.segmentValues.value.second = T, M && a.focusNext();
    }
    b.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.second = n(D));
  }
  function x(b) {
    if (!((!Ze(b.key) || Ke(b.key)) && b.key !== "a" && b.key !== "p" || !("hour" in a.placeholder.value) || !("dayPeriod" in a.segmentValues.value))) {
      if (b.key === t.ARROW_UP || b.key === t.ARROW_DOWN) {
        if (a.segmentValues.value.dayPeriod === "AM") {
          a.segmentValues.value.dayPeriod = "PM", a.segmentValues.value.hour = a.segmentValues.value.hour + 12;
          return;
        }
        a.segmentValues.value.dayPeriod = "AM", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;
        return;
      }
      if (b.key === "a") {
        a.segmentValues.value.dayPeriod = "AM", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;
        return;
      }
      b.key === "p" && (a.segmentValues.value.dayPeriod = "PM", a.segmentValues.value.hour = a.segmentValues.value.hour + 12);
    }
  }
  function P(b) {
    a.disabled.value && b.preventDefault();
  }
  function $(b) {
    const S = a.disabled.value, D = a.readonly.value;
    if (b.key !== t.TAB && b.preventDefault(), S || D)
      return;
    if ({
      day: p,
      month: c,
      year: f,
      hour: v,
      minute: y,
      second: h,
      dayPeriod: x,
      timeZoneName: () => {
      }
    }[a.part](b), !Ke(b.key) && b.key !== t.TAB && b.key !== t.SHIFT && Ze(b.key) && Object.values(a.segmentValues.value).every((T) => T !== null)) {
      let T = { ...a.segmentValues.value };
      "dayPeriod" in a.segmentValues.value && (T = {
        ...T,
        hour: a.segmentValues.value.dayPeriod === "PM" && !a.modelValue.value ? a.segmentValues.value.hour + 12 : a.segmentValues.value.hour
      });
      let M = a.placeholder.value.copy();
      Object.keys(T).forEach((V) => {
        const I = T[V];
        M = M.set({ [V]: I });
      }), a.modelValue.value = M.copy();
    }
  }
  return {
    handleSegmentClick: P,
    handleSegmentKeydown: $,
    attributes: d
  };
}
const yd = /* @__PURE__ */ _({
  __name: "DateFieldInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = od(), n = B(!0), l = B(!1), {
      handleSegmentClick: s,
      handleSegmentKeydown: r,
      attributes: i
    } = Bl({
      hasLeftFocus: n,
      lastKeyZero: l,
      placeholder: e.placeholder,
      hourCycle: e.hourCycle,
      segmentValues: e.segmentValues,
      formatter: e.formatter,
      part: t.part,
      disabled: e.disabled,
      readonly: e.readonly,
      focusNext: e.focusNext,
      modelValue: e.modelValue
    }), u = A(() => e.disabled.value), d = A(() => e.readonly.value), p = A(() => e.isInvalid.value);
    return (c, f) => (g(), w(o(O), k({
      as: c.as,
      "as-child": c.asChild
    }, o(i), {
      contenteditable: u.value || d.value ? !1 : c.part !== "literal",
      "data-radix-vue-date-field-segment": c.part,
      "aria-disabled": u.value ? !0 : void 0,
      "aria-readonly": d.value ? !0 : void 0,
      "data-disabled": u.value ? "" : void 0,
      "data-invalid": p.value ? "" : void 0,
      "aria-invalid": p.value ? !0 : void 0
    }, No(c.part !== "literal" ? {
      mousedown: o(s),
      keydown: o(r),
      focusout: () => {
        n.value = !0;
      },
      focusin: (v) => {
        o(e).setFocusedElement(v.target);
      }
    } : {})), {
      default: m(() => [
        C(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "contenteditable", "data-radix-vue-date-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-invalid", "aria-invalid"]));
  }
}), lv = /* @__PURE__ */ _({
  __name: "DatePickerHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(nu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sv = /* @__PURE__ */ _({
  __name: "DatePickerHeading",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ou), N(K(t)), {
      default: m(({ headingValue: l }) => [
        C(e.$slots, "default", { headingValue: l }, () => [
          me(ke(l), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), rv = /* @__PURE__ */ _({
  __name: "DatePickerGrid",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(lu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), iv = /* @__PURE__ */ _({
  __name: "DatePickerCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(su), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uv = /* @__PURE__ */ _({
  __name: "DatePickerHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ru), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dv = /* @__PURE__ */ _({
  __name: "DatePickerNext",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(iu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cv = /* @__PURE__ */ _({
  __name: "DatePickerPrev",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(uu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pv = /* @__PURE__ */ _({
  __name: "DatePickerGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(du), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fv = /* @__PURE__ */ _({
  __name: "DatePickerGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(cu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vv = /* @__PURE__ */ _({
  __name: "DatePickerGridRow",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(pu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mv = /* @__PURE__ */ _({
  __name: "DatePickerCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(fu), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hv = /* @__PURE__ */ _({
  __name: "DatePickerInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(yd), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Zn, gd] = q("DatePickerRoot"), yv = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "DatePickerRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    name: {},
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    fixedWeeks: { type: Boolean, default: !1 },
    numberOfMonths: { default: 1 },
    preventDeselect: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "update:placeholder", "update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, {
      locale: l,
      disabled: s,
      readonly: r,
      pagedNavigation: i,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: p,
      numberOfMonths: c,
      preventDeselect: f,
      isDateDisabled: v,
      isDateUnavailable: y,
      defaultOpen: h,
      modal: x,
      id: P,
      name: $,
      required: b,
      minValue: S,
      maxValue: D,
      granularity: E,
      hideTimeZone: T,
      hourCycle: M
    } = te(e), V = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? void 0,
      passive: e.modelValue === void 0
    }), I = A(() => Tt({
      defaultPlaceholder: e.placeholder,
      granularity: e.granularity,
      defaultValue: V.value
    })), L = Q(e, "placeholder", n, {
      defaultValue: e.defaultPlaceholder ?? I.value.copy(),
      passive: e.placeholder === void 0
    }), G = Q(e, "open", n, {
      defaultValue: h.value,
      passive: e.open === void 0
    }), X = B();
    return gd({
      isDateUnavailable: y.value,
      isDateDisabled: v.value,
      locale: l,
      disabled: s,
      pagedNavigation: i,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: p,
      numberOfMonths: c,
      readonly: r,
      preventDeselect: f,
      modelValue: V,
      placeholder: L,
      defaultOpen: h,
      modal: x,
      open: G,
      id: P,
      name: $,
      required: b,
      minValue: S,
      maxValue: D,
      granularity: E,
      hideTimeZone: T,
      hourCycle: M,
      dateFieldRef: X,
      onDateChange(H) {
        !H || !V.value ? V.value = H : !f.value && Se(V.value, H) ? V.value = void 0 : V.value = H.copy();
      },
      onPlaceholderChange(H) {
        Re(H, L.value) || (L.value = H.copy());
      }
    }), (H, z) => (g(), w(o(Ml), {
      open: o(G),
      "onUpdate:open": z[0] || (z[0] = (F) => yt(G) ? G.value = F : null),
      "default-open": o(h),
      modal: o(x)
    }, {
      default: m(() => [
        C(H.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "default-open", "modal"]));
  }
}), gv = /* @__PURE__ */ _({
  __name: "DatePickerCalendar",
  setup(a) {
    const t = Zn();
    return (e, n) => (g(), w(o(au), k({
      isDateDisabled: o(t).isDateDisabled,
      isDateUnavailable: o(t).isDateUnavailable,
      minValue: o(t).minValue.value,
      maxValue: o(t).maxValue.value,
      locale: o(t).locale.value,
      disabled: o(t).disabled.value,
      pagedNavigation: o(t).pagedNavigation.value,
      weekStartsOn: o(t).weekStartsOn.value,
      weekdayFormat: o(t).weekdayFormat.value,
      fixedWeeks: o(t).fixedWeeks.value,
      numberOfMonths: o(t).numberOfMonths.value,
      readonly: o(t).readonly.value,
      preventDeselect: o(t).preventDeselect.value
    }, {
      "model-value": o(t).modelValue.value,
      placeholder: o(t).placeholder.value,
      "initial-focus": "",
      multiple: !1,
      "onUpdate:modelValue": n[0] || (n[0] = (l) => {
        l && o(t).modelValue.value && o(Re)(l, o(t).modelValue.value) || o(t).onDateChange(l);
      }),
      "onUpdate:placeholder": n[1] || (n[1] = (l) => {
        o(Re)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);
      })
    }), {
      default: m(({ weekDays: l, grid: s, date: r, formatter: i }) => [
        C(e.$slots, "default", {
          date: r,
          grid: s,
          weekDays: l,
          formatter: i
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), bv = /* @__PURE__ */ _({
  __name: "DatePickerField",
  setup(a) {
    const t = Zn();
    return (e, n) => (g(), w(o(sd), k({
      ref: o(t).dateFieldRef,
      "model-value": o(t).modelValue.value,
      placeholder: o(t).placeholder.value
    }, {
      id: o(t).id.value,
      name: o(t).name.value,
      disabled: o(t).disabled.value,
      minValue: o(t).minValue.value,
      maxValue: o(t).maxValue.value,
      readonly: o(t).readonly.value,
      hourCycle: o(t).hourCycle.value,
      granularity: o(t).granularity.value,
      hideTimeZone: o(t).hideTimeZone.value,
      locale: o(t).locale.value,
      isDateUnavailable: o(t).isDateUnavailable,
      required: o(t).required.value
    }, {
      "onUpdate:modelValue": n[0] || (n[0] = (l) => {
        l && o(t).modelValue.value && o(Re)(o(t).modelValue.value, l) && l.compare(o(t).modelValue.value) === 0 || o(t).onDateChange(l);
      }),
      "onUpdate:placeholder": n[1] || (n[1] = (l) => {
        o(Re)(o(t).placeholder.value, l) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);
      })
    }), {
      default: m(({ segments: l }) => [
        C(e.$slots, "default", { segments: l })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), Cv = /* @__PURE__ */ _({
  __name: "DatePickerAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Hl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _v = /* @__PURE__ */ _({
  __name: "DatePickerArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(zl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wv = /* @__PURE__ */ _({
  __name: "DatePickerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Kl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), xv = /* @__PURE__ */ _({
  __name: "DatePickerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Zn();
    return (n, l) => (g(), w(o(Vl), k({ "data-radix-vue-date-field-segment": "trigger" }, t, {
      onFocusin: l[0] || (l[0] = (s) => {
        var r;
        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);
      })
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Pv = /* @__PURE__ */ _({
  __name: "DatePickerContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return (s, r) => (g(), w(o(Fl), null, {
      default: m(() => [
        j(o(Nl), N(K({ ...o(l), ...s.$attrs })), {
          default: m(() => [
            C(s.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), Sv = /* @__PURE__ */ _({
  __name: "DateRangePickerHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(sc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Dv = /* @__PURE__ */ _({
  __name: "DateRangePickerHeading",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(rc), N(K(t)), {
      default: m(({ headingValue: l }) => [
        C(e.$slots, "default", { headingValue: l }, () => [
          me(ke(l), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), $v = /* @__PURE__ */ _({
  __name: "DateRangePickerGrid",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ic), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ev = /* @__PURE__ */ _({
  __name: "DateRangePickerCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(uc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Bv = /* @__PURE__ */ _({
  __name: "DateRangePickerHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(dc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Rv = /* @__PURE__ */ _({
  __name: "DateRangePickerNext",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(cc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Av = /* @__PURE__ */ _({
  __name: "DateRangePickerPrev",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(pc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Tv = /* @__PURE__ */ _({
  __name: "DateRangePickerGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(fc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Iv = /* @__PURE__ */ _({
  __name: "DateRangePickerGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(vc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ov = /* @__PURE__ */ _({
  __name: "DateRangePickerGridRow",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(mc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), kv = /* @__PURE__ */ _({
  __name: "DateRangePickerCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(hc), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Mv = /* @__PURE__ */ _({
  __name: "DateRangePickerInput",
  props: {
    part: {},
    type: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Pd), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Jn, bd] = q("DateRangePickerRoot"), Vv = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "DateRangePickerRoot",
  props: {
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    name: {},
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    fixedWeeks: { type: Boolean, default: !1 },
    numberOfMonths: { default: 1 },
    preventDeselect: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "update:placeholder", "update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, {
      locale: l,
      disabled: s,
      readonly: r,
      pagedNavigation: i,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: p,
      numberOfMonths: c,
      preventDeselect: f,
      isDateDisabled: v,
      isDateUnavailable: y,
      defaultOpen: h,
      modal: x,
      id: P,
      name: $,
      required: b,
      minValue: S,
      maxValue: D,
      granularity: E,
      hideTimeZone: T,
      hourCycle: M
    } = te(e), V = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? { start: void 0, end: void 0 },
      passive: e.modelValue === void 0
    }), I = Tt({
      defaultPlaceholder: e.placeholder,
      granularity: e.granularity,
      defaultValue: V.value.start
    }), L = Q(e, "placeholder", n, {
      defaultValue: e.defaultPlaceholder ?? I.copy(),
      passive: e.placeholder === void 0
    }), G = Q(e, "open", n, {
      defaultValue: h.value,
      passive: e.open === void 0
    }), X = B();
    return bd({
      isDateUnavailable: y.value,
      isDateDisabled: v.value,
      locale: l,
      disabled: s,
      pagedNavigation: i,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: p,
      numberOfMonths: c,
      readonly: r,
      preventDeselect: f,
      modelValue: V,
      placeholder: L,
      defaultOpen: h,
      modal: x,
      open: G,
      id: P,
      name: $,
      required: b,
      minValue: S,
      maxValue: D,
      granularity: E,
      hideTimeZone: T,
      hourCycle: M,
      dateFieldRef: X,
      onDateChange(H) {
        var z, F;
        V.value = { start: (z = H.start) == null ? void 0 : z.copy(), end: (F = H.end) == null ? void 0 : F.copy() };
      },
      onPlaceholderChange(H) {
        L.value = H.copy();
      }
    }), (H, z) => (g(), w(o(Ml), {
      open: o(G),
      "onUpdate:open": z[0] || (z[0] = (F) => yt(G) ? G.value = F : null),
      "default-open": o(h),
      modal: o(x)
    }, {
      default: m(() => [
        C(H.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "default-open", "modal"]));
  }
}), Fv = /* @__PURE__ */ _({
  __name: "DateRangePickerCalendar",
  setup(a) {
    const t = Jn();
    return (e, n) => (g(), w(o(lc), k({
      isDateDisabled: o(t).isDateDisabled,
      isDateUnavailable: o(t).isDateUnavailable,
      locale: o(t).locale.value,
      disabled: o(t).disabled.value,
      pagedNavigation: o(t).pagedNavigation.value,
      weekStartsOn: o(t).weekStartsOn.value,
      weekdayFormat: o(t).weekdayFormat.value,
      fixedWeeks: o(t).fixedWeeks.value,
      numberOfMonths: o(t).numberOfMonths.value,
      readonly: o(t).readonly.value,
      preventDeselect: o(t).preventDeselect.value,
      minValue: o(t).minValue.value,
      maxValue: o(t).maxValue.value
    }, {
      "initial-focus": "",
      "model-value": o(t).modelValue.value,
      placeholder: o(t).placeholder.value,
      "onUpdate:modelValue": n[0] || (n[0] = (l) => {
        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && o(Re)(l.start, o(t).modelValue.value.start) && o(Re)(l.end, o(t).modelValue.value.end) || o(t).onDateChange(l);
      }),
      "onUpdate:placeholder": n[1] || (n[1] = (l) => {
        o(Re)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);
      })
    }), {
      default: m(({ weekDays: l, grid: s, date: r, formatter: i }) => [
        C(e.$slots, "default", {
          date: r,
          grid: s,
          weekDays: l,
          formatter: i
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), Lv = /* @__PURE__ */ _({
  __name: "DateRangePickerField",
  setup(a) {
    const t = Jn();
    return (e, n) => (g(), w(o(xd), k({
      ref: o(t).dateFieldRef,
      "model-value": o(t).modelValue.value,
      placeholder: o(t).placeholder.value
    }, {
      id: o(t).id.value,
      name: o(t).name.value,
      disabled: o(t).disabled.value,
      minValue: o(t).minValue.value,
      maxValue: o(t).maxValue.value,
      readonly: o(t).readonly.value,
      hourCycle: o(t).hourCycle.value,
      granularity: o(t).granularity.value,
      hideTimeZone: o(t).hideTimeZone.value,
      locale: o(t).locale.value,
      isDateUnavailable: o(t).isDateUnavailable,
      required: o(t).required.value
    }, {
      "onUpdate:modelValue": n[0] || (n[0] = (l) => {
        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && l.start.compare(o(t).modelValue.value.start) === 0 && l.end.compare(o(t).modelValue.value.end) === 0 || o(t).onDateChange(l);
      }),
      "onUpdate:placeholder": n[1] || (n[1] = (l) => {
        o(Re)(l, o(t).placeholder.value) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);
      })
    }), {
      default: m(({ segments: l, modelValue: s }) => [
        C(e.$slots, "default", {
          segments: l,
          modelValue: s
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), Nv = /* @__PURE__ */ _({
  __name: "DateRangePickerAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Hl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zv = /* @__PURE__ */ _({
  __name: "DateRangePickerArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(zl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Kv = /* @__PURE__ */ _({
  __name: "DateRangePickerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Kl), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hv = /* @__PURE__ */ _({
  __name: "DateRangePickerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Jn();
    return (n, l) => (g(), w(o(Vl), k({ "data-radix-vue-date-field-segment": "trigger" }, t, {
      onFocusin: l[0] || (l[0] = (s) => {
        var r;
        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);
      })
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Wv = /* @__PURE__ */ _({
  __name: "DateRangePickerContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return (s, r) => (g(), w(o(Fl), null, {
      default: m(() => [
        j(o(Nl), N(K({ ...o(l), ...s.$attrs })), {
          default: m(() => [
            C(s.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), Cd = ["id", "value", "name", "disabled", "required"], [_d, wd] = q("DateRangeFieldRoot"), xd = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "DateRangeFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    name: {},
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(a, { expose: t, emit: e }) {
    var oe, ee;
    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u } = te(n), d = xn(n.locale), { primitiveElement: p, currentElement: c } = it(), f = B(/* @__PURE__ */ new Set());
    ae(() => {
      Array.from(c.value.querySelectorAll("[data-radix-vue-date-field-segment]")).filter((W) => W.getAttribute("data-radix-vue-date-field-segment") !== "literal").forEach((W) => f.value.add(W));
    });
    const v = Q(n, "modelValue", l, {
      defaultValue: n.defaultValue ?? { start: void 0, end: void 0 },
      passive: n.modelValue === void 0
    }), y = Tt({
      defaultPlaceholder: n.placeholder,
      granularity: n.granularity,
      defaultValue: v.value.start
    }), h = Q(n, "placeholder", l, {
      defaultValue: n.defaultPlaceholder ?? y.copy(),
      passive: n.placeholder === void 0
    }), x = A(() => n.granularity ? qt(h.value) ? n.granularity : "day" : qt(h.value) ? "minute" : "day"), P = A(() => {
      var W;
      return v.value.start ? !!((W = u.value) != null && W.call(u, v.value.start) || n.minValue && Be(v.value.start, n.minValue) || n.maxValue && Be(n.maxValue, v.value.start)) : !1;
    }), $ = A(() => {
      var W;
      return v.value.end ? !!((W = u.value) != null && W.call(u, v.value.end) || n.minValue && Be(v.value.end, n.minValue) || n.maxValue && Be(n.maxValue, v.value.end)) : !1;
    }), b = A(() => P.value || $.value ? !0 : !v.value.start || !v.value.end ? !1 : !Be(v.value.start, v.value.end) || u.value !== void 0 && !Uo(
      v.value.start,
      v.value.end,
      u.value,
      void 0
    )), S = El(x.value), D = B(v.value.start ? { ...Et({ value: v.value.start, formatter: d }) } : { ...S }), E = B(v.value.end ? { ...Et({ value: v.value.end, formatter: d }) } : { ...S }), T = A(() => rn({
      granularity: x.value,
      dateRef: h.value,
      formatter: d,
      hideTimeZone: n.hideTimeZone,
      hourCycle: n.hourCycle,
      segmentValues: D.value,
      locale: s
    })), M = A(() => rn({
      granularity: x.value,
      dateRef: h.value,
      formatter: d,
      hideTimeZone: n.hideTimeZone,
      hourCycle: n.hourCycle,
      segmentValues: E.value,
      locale: s
    })), V = A(() => ({
      start: T.value.arr,
      end: M.value.arr
    })), I = A(() => ({ start: V.value.start.filter(({ part: W }) => W !== "literal"), end: V.value.end.filter(({ part: W }) => W !== "literal") })), L = B((oe = v.value.start) == null ? void 0 : oe.copy()), G = B((ee = v.value.end) == null ? void 0 : ee.copy());
    J([L, G], ([W, ce]) => {
      if (!(v.value.start && v.value.end && W && ce && v.value.start.compare(W) === 0 && v.value.end.compare(ce) === 0)) {
        if (W && ce) {
          v.value = { start: W.copy(), end: ce.copy() };
          return;
        }
        v.value = { start: void 0, end: void 0 };
      }
    }), J(v, (W) => {
      W.start && (L.value = W.start.copy()), W.end && (G.value = W.end.copy());
    }), J([L, s], ([W]) => {
      W !== void 0 ? D.value = { ...Et({ value: W, formatter: d }) } : D.value = { ...S };
    }), J(s, (W) => {
      d.getLocale() !== W && d.setLocale(W);
    }), J(v, (W) => {
      W.start !== void 0 && (!Re(h.value, W.start) || h.value.compare(W.start) !== 0) && (h.value = W.start.copy());
    }), J([G, s], ([W]) => {
      W !== void 0 ? E.value = { ...Et({ value: W, formatter: d }) } : E.value = { ...S };
    });
    const X = B(null), H = A(() => Array.from(f.value).findIndex((W) => {
      var ce, pe;
      return W.getAttribute("data-radix-vue-date-field-segment") === ((ce = X.value) == null ? void 0 : ce.getAttribute("data-radix-vue-date-field-segment")) && W.getAttribute("data-radix-vue-date-range-field-segment-type") === ((pe = X.value) == null ? void 0 : pe.getAttribute("data-radix-vue-date-range-field-segment-type"));
    })), z = A(() => H.value > f.value.size - 1 ? null : Array.from(f.value)[H.value + 1]), F = A(() => H.value < 0 ? null : Array.from(f.value)[H.value - 1]), Y = Ct();
    function U(W) {
      var ce, pe;
      Ke(W.key) && (W.key === Y.ARROW_LEFT && ((ce = F.value) == null || ce.focus()), W.key === Y.ARROW_RIGHT && ((pe = z.value) == null || pe.focus()));
    }
    function Z(W) {
      X.value = W;
    }
    return wd({
      isDateUnavailable: u.value,
      locale: s,
      startValue: L,
      endValue: G,
      placeholder: h,
      disabled: r,
      formatter: d,
      hourCycle: n.hourCycle,
      readonly: i,
      segmentValues: { start: D, end: E },
      isInvalid: b,
      segmentContents: I,
      elements: f,
      setFocusedElement: Z,
      focusNext() {
        var W;
        (W = z.value) == null || W.focus();
      }
    }), t({
      setFocusedElement: Z
    }), (W, ce) => {
      var pe, ue;
      return g(), fe(xe, null, [
        j(o(O), k(W.$attrs, {
          ref_key: "primitiveElement",
          ref: p,
          role: "group",
          "aria-disabled": o(r) ? !0 : void 0,
          "data-disabled": o(r) ? "" : void 0,
          "data-readonly": o(i) ? "" : void 0,
          "data-invalid": b.value ? "" : void 0,
          onKeydown: he(U, ["left", "right"])
        }), {
          default: m(() => [
            C(W.$slots, "default", {
              modelValue: o(v),
              segments: V.value
            })
          ]),
          _: 3
        }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid"]),
        He("input", {
          id: W.id,
          type: "text",
          tabindex: "-1",
          "aria-hidden": "",
          value: `${(pe = o(v).start) == null ? void 0 : pe.toString()} - ${(ue = o(v).end) == null ? void 0 : ue.toString()}`,
          name: W.name,
          disabled: o(r),
          required: W.required,
          style: ge({
            transform: "translateX(-100%)",
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
          }),
          onFocus: ce[0] || (ce[0] = (Ee) => {
            var se, ie;
            return (ie = (se = Array.from(f.value)) == null ? void 0 : se[0]) == null ? void 0 : ie.focus();
          })
        }, null, 44, Cd)
      ], 64);
    };
  }
}), Pd = /* @__PURE__ */ _({
  __name: "DateRangeFieldInput",
  props: {
    part: {},
    type: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = _d(), n = B(!0), l = B(!1), {
      handleSegmentClick: s,
      handleSegmentKeydown: r,
      attributes: i
    } = Bl({
      hasLeftFocus: n,
      lastKeyZero: l,
      placeholder: e.placeholder,
      hourCycle: e.hourCycle,
      segmentValues: e.segmentValues[t.type],
      formatter: e.formatter,
      part: t.part,
      disabled: e.disabled,
      readonly: e.readonly,
      focusNext: e.focusNext,
      modelValue: t.type === "start" ? e.startValue : e.endValue
    }), u = A(() => e.disabled.value), d = A(() => e.readonly.value), p = A(() => e.isInvalid.value);
    return (c, f) => (g(), w(o(O), k({
      as: c.as,
      "as-child": c.asChild
    }, o(i), {
      contenteditable: u.value || d.value ? !1 : c.part !== "literal",
      "data-radix-vue-date-field-segment": c.part,
      "aria-disabled": u.value ? !0 : void 0,
      "aria-readonly": d.value ? !0 : void 0,
      "data-disabled": u.value ? "" : void 0,
      "data-radix-vue-date-range-field-segment-type": c.type,
      "data-invalid": p.value ? "" : void 0,
      "aria-invalid": p.value ? !0 : void 0
    }, No(c.part !== "literal" ? {
      mousedown: o(s),
      keydown: o(r),
      focusout: () => {
        n.value = !0;
      },
      focusin: (v) => {
        o(e).setFocusedElement(v.target);
      }
    } : {})), {
      default: m(() => [
        C(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "contenteditable", "data-radix-vue-date-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-radix-vue-date-range-field-segment-type", "data-invalid", "aria-invalid"]));
  }
}), [Rl, Sd] = q("DropdownMenuRoot"), jv = /* @__PURE__ */ _({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    const l = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), s = B(), { modal: r, dir: i } = te(e), u = Pe(i);
    return Sd({
      open: l,
      onOpenChange: (d) => {
        l.value = d;
      },
      onOpenToggle: () => {
        l.value = !l.value;
      },
      triggerId: "",
      triggerElement: s,
      contentId: "",
      modal: r,
      dir: u
    }), (d, p) => (g(), w(o(Vn), {
      open: o(l),
      "onUpdate:open": p[0] || (p[0] = (c) => yt(l) ? l.value = c : null),
      dir: o(u),
      modal: o(r)
    }, {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), Gv = /* @__PURE__ */ _({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = Rl(), { forwardRef: n, currentElement: l } = R();
    return ae(() => {
      e.triggerElement = l;
    }), e.triggerId || (e.triggerId = ve(void 0, "radix-vue-dropdown-menu-trigger")), (s, r) => (g(), w(o(Ra), { "as-child": "" }, {
      default: m(() => [
        j(o(O), {
          id: o(e).triggerId,
          ref: o(n),
          type: s.as === "button" ? "button" : void 0,
          "as-child": t.asChild,
          as: s.as,
          "aria-haspopup": "menu",
          "aria-expanded": o(e).open.value,
          "aria-controls": o(e).open.value ? o(e).contentId : void 0,
          "data-disabled": s.disabled ? "" : void 0,
          disabled: s.disabled,
          "data-state": o(e).open.value ? "open" : "closed",
          onClick: r[0] || (r[0] = async (i) => {
            var u;
            !s.disabled && i.button === 0 && i.ctrlKey === !1 && ((u = o(e)) == null || u.onOpenToggle(), await ne(), o(e).open.value && i.preventDefault());
          }),
          onKeydown: r[1] || (r[1] = he(
            (i) => {
              s.disabled || (["Enter", " "].includes(i.key) && o(e).onOpenToggle(), i.key === "ArrowDown" && o(e).onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(i.key) && i.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: m(() => [
            C(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), Uv = /* @__PURE__ */ _({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Wn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qv = /* @__PURE__ */ _({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    R();
    const s = Rl(), r = B(!1);
    function i(u) {
      u.defaultPrevented || (r.value || setTimeout(() => {
        var d;
        (d = s.triggerElement.value) == null || d.focus();
      }, 0), r.value = !1, u.preventDefault());
    }
    return s.contentId || (s.contentId = ve(void 0, "radix-vue-dropdown-menu-content")), (u, d) => {
      var p;
      return g(), w(o(Kn), k(o(l), {
        id: o(s).contentId,
        "aria-labelledby": (p = o(s)) == null ? void 0 : p.triggerId,
        style: {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: i,
        onInteractOutside: d[0] || (d[0] = (c) => {
          var h;
          if (c.defaultPrevented)
            return;
          const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, y = f.button === 2 || v;
          (!o(s).modal.value || y) && (r.value = !0), (h = o(s).triggerElement.value) != null && h.contains(c.target) && c.preventDefault();
        })
      }), {
        default: m(() => [
          C(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "style"]);
    };
  }
}), Yv = /* @__PURE__ */ _({
  __name: "DropdownMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Mn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Xv = /* @__PURE__ */ _({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(ra), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zv = /* @__PURE__ */ _({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Aa), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jv = /* @__PURE__ */ _({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Un), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qv = /* @__PURE__ */ _({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(zn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), em = /* @__PURE__ */ _({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Nn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tm = /* @__PURE__ */ _({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Hn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), am = /* @__PURE__ */ _({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(jn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nm = /* @__PURE__ */ _({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return R(), (s, r) => (g(), w(o(Gn), N(K(o(l))), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), om = /* @__PURE__ */ _({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "open", t, {
      passive: e.open === void 0,
      defaultValue: e.defaultOpen ?? !1
    });
    return R(), (s, r) => (g(), w(o(qn), {
      open: o(l),
      "onUpdate:open": r[0] || (r[0] = (i) => yt(l) ? l.value = i : null)
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), lm = /* @__PURE__ */ _({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return R(), (s, r) => (g(), w(o(Yn), k(o(l), { style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), sm = /* @__PURE__ */ _({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Xn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Qn, Dd] = q("HoverCardRoot"), rm = /* @__PURE__ */ _({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, { openDelay: l, closeDelay: s } = te(e);
    R();
    const r = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), i = B(0), u = B(0), d = B(!1), p = B(!1), c = B(!1), f = B();
    function v() {
      clearTimeout(u.value), i.value = window.setTimeout(() => r.value = !0, l.value);
    }
    function y() {
      clearTimeout(i.value), !d.value && !p.value && (u.value = window.setTimeout(() => r.value = !1, s.value));
    }
    function h() {
      r.value = !1;
    }
    return Dd({
      open: r,
      onOpenChange(x) {
        r.value = x;
      },
      onOpen: v,
      onClose: y,
      onDismiss: h,
      hasSelectionRef: d,
      isPointerDownOnContentRef: p,
      isPointerInTransit: c,
      triggerElement: f
    }), (x, P) => (g(), w(o(_t), null, {
      default: m(() => [
        C(x.$slots, "default")
      ]),
      _: 3
    }));
  }
});
function Al(a) {
  return (t) => t.pointerType === "touch" ? void 0 : a();
}
function $d(a) {
  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
const im = /* @__PURE__ */ _({
  __name: "HoverCardTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(a) {
    const { forwardRef: t, currentElement: e } = R(), n = Qn();
    return n.triggerElement = e, (l, s) => (g(), w(o(wt), { "as-child": "" }, {
      default: m(() => [
        j(o(O), {
          ref: o(t),
          "as-child": l.asChild,
          as: l.as,
          "data-state": o(n).open.value ? "open" : "closed",
          onPointerenter: s[0] || (s[0] = (r) => o(Al)(o(n).onOpen)(r)),
          onFocus: s[1] || (s[1] = (r) => o(n).onOpen()),
          onBlur: s[2] || (s[2] = (r) => o(n).onClose())
        }, {
          default: m(() => [
            C(l.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "data-state"])
      ]),
      _: 3
    }));
  }
}), um = /* @__PURE__ */ _({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ed = /* @__PURE__ */ _({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = bt(e), { forwardRef: s, currentElement: r } = R(), i = Qn(), { isPointerInTransit: u, onPointerExit: d } = nl(i.triggerElement, r);
    i.isPointerInTransit = u, d(() => {
      i.onClose();
    });
    const p = B(!1);
    let c;
    de((v) => {
      if (p.value) {
        const y = document.body;
        c = y.style.userSelect || y.style.webkitUserSelect, y.style.userSelect = "none", y.style.webkitUserSelect = "none", v(() => {
          y.style.userSelect = c, y.style.webkitUserSelect = c;
        });
      }
    });
    function f() {
      p.value = !1, i.isPointerDownOnContentRef.value = !1, ne(() => {
        var y;
        ((y = document.getSelection()) == null ? void 0 : y.toString()) !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return ae(() => {
      r.value && (document.addEventListener("pointerup", f), $d(r.value).forEach((y) => y.setAttribute("tabindex", "-1")));
    }), De(() => {
      document.removeEventListener("pointerup", f), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (v, y) => (g(), w(o(dt), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: y[1] || (y[1] = (h) => n("escapeKeyDown", h)),
      onPointerDownOutside: y[2] || (y[2] = (h) => n("pointerDownOutside", h)),
      onFocusOutside: y[3] || (y[3] = ye((h) => n("focusOutside", h), ["prevent"])),
      onDismiss: o(i).onDismiss
    }, {
      default: m(() => [
        j(o(ht), k({ ...o(l), ...v.$attrs }, {
          ref: o(s),
          "data-state": o(i).open.value ? "open" : "closed",
          style: {
            userSelect: p.value ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: p.value ? "text" : void 0,
            // re-namespace exposed content custom properties
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          },
          onPointerdown: y[0] || (y[0] = (h) => {
            h.currentTarget.contains(h.target) && (p.value = !0), o(i).hasSelectionRef.value = !1, o(i).isPointerDownOnContentRef.value = !0;
          })
        }), {
          default: m(() => [
            C(v.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), dm = /* @__PURE__ */ _({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(a, { emit: t }) {
    const l = be(a, t), { forwardRef: s } = R(), r = Qn();
    return (i, u) => (g(), w(o(we), {
      present: i.forceMount || o(r).open.value
    }, {
      default: m(() => [
        j(Ed, k(o(l), {
          ref: o(s),
          onPointerenter: u[0] || (u[0] = (d) => o(Al)(o(r).onOpen)(d))
        }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), cm = /* @__PURE__ */ _({
  __name: "HoverCardArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Mt), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pm = /* @__PURE__ */ _({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(O), k(t, {
      onMousedown: n[0] || (n[0] = (l) => {
        !l.defaultPrevented && l.detail > 1 && l.preventDefault();
      })
    }), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Ta, Bd] = q("MenubarRoot"), fm = /* @__PURE__ */ _({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), { createCollection: r } = Te("menubar");
    r(s);
    const i = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), u = B(null), { dir: d, loop: p } = te(e), c = Pe(d);
    return Bd({
      modelValue: i,
      dir: c,
      loop: p,
      onMenuOpen: (f) => {
        i.value = f, u.value = f;
      },
      onMenuClose: () => {
        i.value = "";
      },
      onMenuToggle: (f) => {
        i.value = i.value ? "" : f, u.value = f;
      }
    }), (f, v) => (g(), w(o(Ft), {
      "current-tab-stop-id": u.value,
      "onUpdate:currentTabStopId": v[0] || (v[0] = (y) => u.value = y),
      orientation: "horizontal",
      loop: o(p),
      dir: o(c),
      "as-child": ""
    }, {
      default: m(() => [
        j(o(O), {
          ref: o(l),
          role: "menubar"
        }, {
          default: m(() => [
            C(f.$slots, "default")
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["current-tab-stop-id", "loop", "dir"]));
  }
}), [eo, Rd] = q("MenubarMenu"), vm = /* @__PURE__ */ _({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(a) {
    const e = ve(a.value), n = Ta();
    R();
    const l = B(), s = B(!1), r = A(() => n.modelValue.value === e);
    return J(r, () => {
      r.value || (s.value = !1);
    }), Rd({
      value: e,
      triggerElement: l,
      triggerId: e,
      contentId: "",
      wasKeyboardTriggerOpenRef: s
    }), (i, u) => (g(), w(o(Vn), {
      open: r.value,
      modal: !1,
      dir: o(n).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || o(n).onMenuClose();
      })
    }, {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), mm = /* @__PURE__ */ _({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = Ta(), e = eo(), { forwardRef: n, currentElement: l } = R(), s = B(!1), r = A(() => t.modelValue.value === e.value);
    return ae(() => {
      e.triggerElement = l;
    }), (i, u) => (g(), w(o(Lt), {
      "as-child": "",
      focusable: !i.disabled,
      "tab-stop-id": o(e).value
    }, {
      default: m(() => [
        j(o(Ra), { "as-child": "" }, {
          default: m(() => [
            j(o(O), {
              id: o(e).triggerId,
              ref: o(n),
              as: i.as,
              type: i.as === "button" ? "button" : void 0,
              role: "menuitem",
              "aria-haspopup": "menu",
              "aria-expanded": r.value,
              "aria-controls": r.value ? o(e).contentId : void 0,
              "data-highlighted": s.value ? "" : void 0,
              "data-state": r.value ? "open" : "closed",
              "data-disabled": i.disabled ? "" : void 0,
              disabled: i.disabled,
              "data-value": o(e).value,
              "data-radix-vue-collection-item": "",
              onPointerdown: u[0] || (u[0] = (d) => {
                !i.disabled && d.button === 0 && d.ctrlKey === !1 && (o(t).onMenuOpen(o(e).value), r.value || d.preventDefault());
              }),
              onPointerenter: u[1] || (u[1] = () => {
                var p;
                !!o(t).modelValue.value && !r.value && (o(t).onMenuOpen(o(e).value), (p = o(l)) == null || p.focus());
              }),
              onKeydown: u[2] || (u[2] = he((d) => {
                i.disabled || (["Enter", " "].includes(d.key) && o(t).onMenuToggle(o(e).value), d.key === "ArrowDown" && o(t).onMenuOpen(o(e).value), ["Enter", " ", "ArrowDown"].includes(d.key) && (o(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));
              }, ["enter", "space", "arrow-down"])),
              onFocus: u[3] || (u[3] = (d) => s.value = !0),
              onBlur: u[4] || (u[4] = (d) => s.value = !1)
            }, {
              default: m(() => [
                C(i.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), hm = /* @__PURE__ */ _({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(Wn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ym = /* @__PURE__ */ _({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    R();
    const s = Ta(), r = eo();
    r.contentId || (r.contentId = ve(void 0, "radix-vue-menubar-content"));
    const { injectCollection: i } = Te("menubar"), u = i(), d = B(!1);
    function p(c) {
      const v = c.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ), h = (s.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!h && v)
        return;
      let P = u.value.map((S) => S.dataset.value);
      h && P.reverse();
      const $ = P.indexOf(r.value);
      P = s.loop.value ? Dn(P, $ + 1) : P.slice($ + 1);
      const [b] = P;
      b && s.onMenuOpen(b);
    }
    return (c, f) => (g(), w(o(Kn), k(o(l), {
      id: o(r).contentId,
      "data-radix-menubar-content": "",
      "aria-labelledby": o(r).triggerId,
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (v) => {
        var h;
        !!!o(s).modelValue.value && !d.value && ((h = o(r).triggerElement.value) == null || h.focus()), d.value = !1, v.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (v) => {
        const y = v.target;
        o(u).some((x) => x.contains(y)) && v.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (v) => {
        d.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (v) => {
        o(r).wasKeyboardTriggerOpenRef.value || v.preventDefault();
      }),
      onKeydown: he(p, ["arrow-right", "arrow-left"])
    }), {
      default: m(() => [
        C(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "style"]));
  }
}), gm = /* @__PURE__ */ _({
  __name: "MenubarArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Mn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bm = /* @__PURE__ */ _({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(ra), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cm = /* @__PURE__ */ _({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Aa), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _m = /* @__PURE__ */ _({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Un), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wm = /* @__PURE__ */ _({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(zn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), xm = /* @__PURE__ */ _({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Nn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Pm = /* @__PURE__ */ _({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Hn), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Sm = /* @__PURE__ */ _({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, l = $e(t);
    return R(), (s, r) => (g(), w(o(jn), N(K({ ...e, ...o(l) })), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Dm = /* @__PURE__ */ _({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    return R(), (s, r) => (g(), w(o(Gn), N(K(o(l))), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $m = /* @__PURE__ */ _({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    const l = Q(e, "open", n, {
      defaultValue: e.defaultOpen ?? !1,
      passive: e.open === void 0
    });
    return (s, r) => (g(), w(o(qn), {
      open: o(l),
      "onUpdate:open": r[0] || (r[0] = (i) => yt(l) ? l.value = i : null)
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), Em = /* @__PURE__ */ _({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const l = be(a, t);
    R();
    const { injectCollection: s } = Te("menubar"), r = Ta(), i = eo(), u = s();
    function d(p) {
      if (p.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ))
        return;
      let v = u.value.map((x) => x.dataset.value);
      const y = v.indexOf(i.value);
      v = r.loop.value ? Dn(v, y + 1) : v.slice(y + 1);
      const [h] = v;
      h && r.onMenuOpen(h);
    }
    return (p, c) => (g(), w(o(Yn), k(o(l), {
      "data-radix-menubar-content": "",
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onKeydown: he(d, ["arrow-right"])
    }), {
      default: m(() => [
        C(p.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Bm = /* @__PURE__ */ _({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Xn), k(t, { "data-radix-menubar-subtrigger": "" }), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [ct, Tl] = q(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext"), Rm = /* @__PURE__ */ _({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: { default: void 0 },
    defaultValue: {},
    dir: {},
    orientation: { default: "horizontal" },
    delayDuration: { default: 200 },
    skipDelayDuration: { default: 300 },
    disableClickTrigger: { type: Boolean, default: !1 },
    disableHoverTrigger: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), s = B(""), { forwardRef: r, currentElement: i } = R(), u = B(), d = B(), { createCollection: p } = Te("nav");
    p(u);
    const { delayDuration: c, skipDelayDuration: f, dir: v, disableClickTrigger: y, disableHoverTrigger: h } = te(e), x = Pe(v), P = Sa(!1, f), $ = A(() => l.value !== "" || P.value ? 150 : c.value), b = bn((S) => {
      s.value = l.value, l.value = S;
    }, $);
    return Tl({
      isRootMenu: !0,
      modelValue: l,
      previousValue: s,
      baseId: ve(void 0, "radix-navigation-menu"),
      disableClickTrigger: y,
      disableHoverTrigger: h,
      dir: x,
      orientation: e.orientation,
      rootNavigationMenu: i,
      indicatorTrack: u,
      onIndicatorTrackChange: (S) => {
        u.value = S;
      },
      viewport: d,
      onViewportChange: (S) => {
        d.value = S;
      },
      onTriggerEnter: (S) => {
        b(S);
      },
      onTriggerLeave: () => {
        P.value = !0, b("");
      },
      onContentEnter: (S) => {
        b(S);
      },
      onContentLeave: () => {
        b("");
      },
      onItemSelect: (S) => {
        s.value = l.value, l.value = S;
      },
      onItemDismiss: () => {
        s.value = l.value, l.value = "";
      }
    }), (S, D) => (g(), w(o(O), {
      ref: o(r),
      "aria-label": "Main",
      as: S.as,
      "as-child": S.asChild,
      "data-orientation": S.orientation,
      dir: o(x)
    }, {
      default: m(() => [
        C(S.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "dir"]));
  }
});
function Ia(a) {
  return a ? "open" : "closed";
}
function Il(a, t) {
  return `${a}-trigger-${t}`;
}
function to(a, t) {
  return `${a}-content-${t}`;
}
const ga = "navigationMenu.rootContentDismiss";
function un(a) {
  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const l = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function Ol(a) {
  const t = document.activeElement;
  return a.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));
}
function Ad(a) {
  return a.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    a.forEach((t) => {
      const e = t.dataset.tabindex;
      t.setAttribute("tabindex", e);
    });
  };
}
function kl(a) {
  return (t) => t.pointerType === "mouse" ? a(t) : void 0;
}
const [ao, Td] = q("NavigationMenuItem"), Am = /* @__PURE__ */ _({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  setup(a) {
    const t = a;
    R();
    const { injectCollection: e } = Te("nav"), n = e(), l = ct(), s = ve(t.value), r = B(), i = B(), u = to(l.baseId, s);
    let d = () => ({});
    const p = B(!1);
    async function c(h = "start") {
      const x = document.getElementById(u);
      if (x) {
        d();
        const P = un(x);
        P.length && Ol(h === "start" ? P : P.reverse());
      }
    }
    function f() {
      const h = document.getElementById(u);
      if (h) {
        const x = un(h);
        x.length && (d = Ad(x));
      }
    }
    Td({
      value: s,
      contentId: u,
      triggerRef: r,
      focusProxyRef: i,
      wasEscapeCloseRef: p,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function v() {
      var h;
      l.onItemDismiss(), (h = r.value) == null || h.focus();
    }
    function y(h) {
      const x = document.activeElement;
      if (h.keyCode === 32 || h.key === "Enter")
        if (l.modelValue.value === s) {
          v(), h.preventDefault();
          return;
        } else {
          h.target.click(), h.preventDefault();
          return;
        }
      const P = n.value.filter(
        (b) => {
          var S;
          return (S = b.parentElement) == null ? void 0 : S.hasAttribute("data-menu-item");
        }
      ), $ = Ot(h, x, void 0, {
        itemsArray: P,
        loop: !1
      });
      $ && ($ == null || $.focus()), h.preventDefault(), h.stopPropagation();
    }
    return (h, x) => (g(), w(o(O), {
      "as-child": h.asChild,
      as: h.as,
      "data-menu-item": "",
      onKeydown: he(y, ["up", "down", "left", "right", "home", "end", "space"])
    }, {
      default: m(() => [
        C(h.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Id = /* @__PURE__ */ _({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, { injectCollection: l } = Te("nav"), s = l(), { forwardRef: r, currentElement: i } = R(), u = ct(), d = ao(), p = Il(u.baseId, d.value), c = to(u.baseId, d.value), f = B(null), v = A(() => {
      const S = s.value.map((I) => I.id.split("trigger-")[1]);
      u.dir.value === "rtl" && S.reverse();
      const D = S.indexOf(u.modelValue.value), E = S.indexOf(u.previousValue.value), T = d.value === u.modelValue.value, M = E === S.indexOf(d.value);
      if (!T && !M)
        return f.value;
      const V = (() => {
        if (D !== E) {
          if (T && E !== -1)
            return D > E ? "from-end" : "from-start";
          if (M && D !== -1)
            return D > E ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = V, V;
    });
    function y(b) {
      var S, D;
      if (n("focusOutside", b), n("interactOutside", b), !b.defaultPrevented) {
        d.onContentFocusOutside();
        const E = b.target;
        (D = (S = u.rootNavigationMenu) == null ? void 0 : S.value) != null && D.contains(E) && b.preventDefault();
      }
    }
    function h(b) {
      var S;
      if (n("pointerDownOutside", b), !b.defaultPrevented) {
        const D = b.target, E = s.value.some(
          (M) => M.contains(D)
        ), T = u.isRootMenu && ((S = u.viewport.value) == null ? void 0 : S.contains(D));
        (E || T || !u.isRootMenu) && b.preventDefault();
      }
    }
    de((b) => {
      const S = i.value;
      if (u.isRootMenu && S) {
        const D = () => {
          var E;
          u.onItemDismiss(), d.onRootContentClose(), S.contains(document.activeElement) && ((E = d.triggerRef.value) == null || E.focus());
        };
        S.addEventListener(ga, D), b(
          () => S.removeEventListener(ga, D)
        );
      }
    });
    function x(b) {
      var S, D;
      n("escapeKeyDown", b), b.defaultPrevented || (u.onItemDismiss(), (D = (S = d.triggerRef) == null ? void 0 : S.value) == null || D.focus(), d.wasEscapeCloseRef.value = !0);
    }
    function P(b) {
      var M;
      const S = b.altKey || b.ctrlKey || b.metaKey, D = b.key === "Tab" && !S, E = un(b.currentTarget);
      if (D) {
        const V = document.activeElement, I = E.findIndex(
          (X) => X === V
        ), G = b.shiftKey ? E.slice(0, I).reverse() : E.slice(I + 1, E.length);
        if (Ol(G))
          b.preventDefault();
        else {
          (M = d.focusProxyRef.value) == null || M.focus();
          return;
        }
      }
      const T = Ot(
        b,
        document.activeElement,
        void 0,
        { itemsArray: E, loop: !1, enableIgnoredElement: !0 }
      );
      T == null || T.focus();
    }
    function $() {
      var S;
      const b = new Event(ga, {
        bubbles: !0,
        cancelable: !0
      });
      (S = i.value) == null || S.dispatchEvent(b);
    }
    return (b, S) => (g(), w(o(dt), k({
      id: o(c),
      ref: o(r),
      "aria-labelledby": o(p),
      "data-motion": v.value,
      "data-state": o(Ia)(o(u).modelValue.value === o(d).value),
      "data-orientation": o(u).orientation
    }, e, {
      onKeydown: P,
      onEscapeKeyDown: x,
      onPointerDownOutside: h,
      onFocusOutside: y,
      onDismiss: $
    }), {
      default: m(() => [
        C(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "data-motion", "data-state", "data-orientation"]));
  }
}), Tm = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = $e(n), { forwardRef: s } = R(), r = Da(), i = ct(), u = ao(), d = A(() => u.value === i.modelValue.value), p = A(() => i.viewport.value && !i.modelValue.value && i.previousValue.value ? i.previousValue.value === u.value : !1);
    return (c, f) => o(r) ? (g(), w(At, {
      key: 0,
      to: o(i).viewport.value,
      disabled: !o(i).viewport.value
    }, [
      j(o(we), {
        present: c.forceMount || d.value || p.value
      }, {
        default: m(() => [
          j(Id, k({
            ref: o(s),
            "data-state": o(Ia)(d.value),
            style: {
              pointerEvents: !d.value && o(i).isRootMenu ? "none" : void 0
            }
          }, { ...c.$attrs, ...e, ...o(l) }, {
            onPointerenter: f[0] || (f[0] = (v) => o(i).onContentEnter(o(u).value)),
            onPointerleave: f[1] || (f[1] = (v) => o(kl)(() => o(i).onContentLeave())(v)),
            onPointerDownOutside: f[2] || (f[2] = (v) => n("pointerDownOutside", v)),
            onFocusOutside: f[3] || (f[3] = (v) => n("focusOutside", v)),
            onInteractOutside: f[4] || (f[4] = (v) => n("interactOutside", v))
          }), {
            default: m(() => [
              C(c.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "style"])
        ]),
        _: 3
      }, 8, ["present"])
    ], 8, ["to", "disabled"])) : re("", !0);
  }
}), Im = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e } = R(), { injectCollection: n } = Te("nav"), l = n(), s = ct(), r = B(), i = A(() => s.orientation === "horizontal"), u = A(() => !!s.modelValue.value), d = B();
    function p() {
      d.value && (r.value = {
        size: i.value ? d.value.offsetWidth : d.value.offsetHeight,
        offset: i.value ? d.value.offsetLeft : d.value.offsetTop
      });
    }
    return de(() => {
      if (!s.modelValue.value) {
        r.value = void 0;
        return;
      }
      const c = l.value;
      d.value = c.find(
        (f) => f.id.includes(s.modelValue.value)
      ), p();
    }), We(d, p), We(s.indicatorTrack, p), (c, f) => o(s).indicatorTrack.value ? (g(), w(At, {
      key: 0,
      to: o(s).indicatorTrack.value
    }, [
      j(o(we), {
        present: c.forceMount || u.value
      }, {
        default: m(() => {
          var v, y, h, x;
          return [
            j(o(O), k({
              ref: o(e),
              "aria-hidden": "",
              "data-state": u.value ? "visible" : "hidden",
              "data-orientation": o(s).orientation,
              "as-child": t.asChild,
              as: c.as,
              style: {
                position: "absolute",
                ...i.value ? {
                  left: 0,
                  width: `${(v = r.value) == null ? void 0 : v.size}px`,
                  transform: `translateX(${(y = r.value) == null ? void 0 : y.offset}px)`
                } : {
                  top: 0,
                  height: `${(h = r.value) == null ? void 0 : h.size}px`,
                  transform: `translateY(${(x = r.value) == null ? void 0 : x.offset}px)`
                }
              }
            }, c.$attrs), {
              default: m(() => [
                C(c.$slots, "default")
              ]),
              _: 3
            }, 16, ["data-state", "data-orientation", "as-child", "as", "style"])
          ];
        }),
        _: 3
      }, 8, ["present"])
    ], 8, ["to"])) : re("", !0);
  }
}), Om = /* @__PURE__ */ _({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  emits: ["select"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    async function l(s) {
      var r;
      if (n("select", s), await ne(), !s.defaultPrevented && !s.metaKey) {
        const i = new CustomEvent(
          ga,
          {
            bubbles: !0,
            cancelable: !0
          }
        );
        (r = s.target) == null || r.dispatchEvent(i);
      }
    }
    return (s, r) => (g(), w(o(O), {
      as: s.as,
      "data-active": s.active ? "" : void 0,
      "aria-current": s.active ? "page" : void 0,
      "as-child": e.asChild,
      "data-radix-vue-collection-item": "",
      onClick: l
    }, {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "data-active", "aria-current", "as-child"]));
  }
}), km = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: { default: "ul" }
  },
  setup(a) {
    const t = a, e = ct(), { forwardRef: n, currentElement: l } = R();
    return ae(() => {
      e.onIndicatorTrackChange(l.value);
    }), (s, r) => (g(), w(o(O), {
      ref: o(n),
      style: { position: "relative" }
    }, {
      default: m(() => [
        j(o(O), k(s.$attrs, {
          "as-child": t.asChild,
          as: s.as,
          "data-orientation": o(e).orientation
        }), {
          default: m(() => [
            C(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-orientation"])
      ]),
      _: 3
    }, 512));
  }
}), Mm = /* @__PURE__ */ _({
  __name: "NavigationMenuSub",
  props: {
    modelValue: {},
    defaultValue: {},
    orientation: { default: "horizontal" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), s = B(""), r = ct(), { forwardRef: i, currentElement: u } = R(), d = B(), p = B(), { createCollection: c } = Te("nav");
    return c(d), Tl({
      ...r,
      isRootMenu: !1,
      modelValue: l,
      previousValue: s,
      orientation: e.orientation,
      rootNavigationMenu: u,
      indicatorTrack: d,
      onIndicatorTrackChange: (f) => {
        d.value = f;
      },
      viewport: p,
      onViewportChange: (f) => {
        p.value = f;
      },
      onTriggerEnter: (f) => {
        l.value = f;
      },
      onTriggerLeave: () => {
      },
      onContentEnter: () => {
      },
      onContentLeave: () => {
      },
      onItemSelect: (f) => {
        l.value = f;
      },
      onItemDismiss: () => {
        l.value = "";
      }
    }), (f, v) => (g(), w(o(O), {
      ref: o(i),
      "data-orientation": f.orientation,
      "as-child": e.asChild,
      as: f.as
    }, {
      default: m(() => [
        C(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as-child", "as"]));
  }
}), Od = ["aria-owns"], Vm = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = ct(), n = ao(), { forwardRef: l, currentElement: s } = R(), r = B(""), i = B(""), u = Sa(!1, 300), d = B(!1), p = A(() => n.value === e.modelValue.value);
    ae(() => {
      n.triggerRef = s, r.value = Il(e.baseId, n.value), i.value = to(e.baseId, n.value);
    });
    function c() {
      e.disableHoverTrigger.value || (d.value = !1, n.wasEscapeCloseRef.value = !1);
    }
    function f($) {
      if (!e.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)
          return;
        e.onTriggerEnter(n.value), u.value = !0;
      }
    }
    function v($) {
      if (!e.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled)
          return;
        e.onTriggerLeave(), u.value = !1;
      }
    }
    function y($) {
      $.pointerType === "mouse" && e.disableClickTrigger.value || u.value || (p.value ? e.onItemSelect("") : e.onItemSelect(n.value), d.value = p.value);
    }
    function h($) {
      const S = { horizontal: "ArrowDown", vertical: e.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight" }[e.orientation];
      p.value && $.key === S && (n.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());
    }
    function x($) {
      n.focusProxyRef.value = Ae($);
    }
    function P($) {
      const b = document.getElementById(n.contentId), S = $.relatedTarget, D = S === s.value, E = b == null ? void 0 : b.contains(S);
      (D || !E) && n.onFocusProxyEnter(D ? "start" : "end");
    }
    return ($, b) => (g(), fe(xe, null, [
      j(o(O), k({
        id: r.value,
        ref: o(l),
        disabled: $.disabled,
        "data-disabled": $.disabled ? "" : void 0,
        "data-state": o(Ia)(p.value),
        "aria-expanded": p.value,
        "aria-controls": i.value,
        "as-child": t.asChild,
        as: $.as
      }, $.$attrs, {
        "data-radix-vue-collection-item": "",
        onPointerenter: c,
        onPointermove: f,
        onPointerleave: v,
        onClick: y,
        onKeydown: h
      }), {
        default: m(() => [
          C($.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "disabled", "data-disabled", "data-state", "aria-expanded", "aria-controls", "as-child", "as"]),
      p.value ? (g(), fe(xe, { key: 0 }, [
        j(o(Vt), {
          ref: x,
          "aria-hidden": "",
          tabindex: 0,
          onFocus: P
        }),
        o(e).viewport ? (g(), fe("span", {
          key: 0,
          "aria-owns": i.value
        }, null, 8, Od)) : re("", !0)
      ], 64)) : re("", !0)
    ], 64));
  }
}), Fm = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const { forwardRef: t, currentElement: e } = R(), n = ct(), l = B(), s = A(() => !!n.modelValue.value), r = A(() => n.modelValue.value);
    J(e, () => {
      e.value && n.onViewportChange(e.value);
    });
    const i = B();
    return J([r, s], async () => {
      var d, p;
      if (await ne(), !e.value)
        return;
      const u = (p = (d = e.value.querySelector("[data-state=open]")) == null ? void 0 : d.children) == null ? void 0 : p[0];
      i.value = u;
    }, { immediate: !0 }), We(i, () => {
      i.value && (l.value = {
        width: i.value.offsetWidth,
        height: i.value.offsetHeight
      });
    }), (u, d) => (g(), w(o(we), {
      present: u.forceMount || s.value
    }, {
      default: m(() => {
        var p, c;
        return [
          j(o(O), k(u.$attrs, {
            ref: o(t),
            as: u.as,
            "as-child": u.asChild,
            "data-state": o(Ia)(s.value),
            "data-orientation": o(n).orientation,
            style: {
              // Prevent interaction when animating out
              pointerEvents: !s.value && o(n).isRootMenu ? "none" : void 0,
              "--radix-navigation-menu-viewport-width": l.value ? `${(p = l.value) == null ? void 0 : p.width}px` : void 0,
              "--radix-navigation-menu-viewport-height": l.value ? `${(c = l.value) == null ? void 0 : c.height}px` : void 0
            },
            onPointerenter: d[0] || (d[0] = (f) => o(n).onContentEnter(o(n).modelValue.value)),
            onPointerleave: d[1] || (d[1] = (f) => o(kl)(() => o(n).onContentLeave())(f))
          }), {
            default: m(() => [
              C(u.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "data-state", "data-orientation", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), [Nt, kd] = q("PaginationRoot"), Lm = /* @__PURE__ */ _({
  __name: "PaginationRoot",
  props: {
    page: {},
    defaultPage: { default: 1 },
    itemsPerPage: { default: 10 },
    total: { default: 0 },
    siblingCount: { default: 2 },
    disabled: { type: Boolean },
    showEdges: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:page"],
  setup(a, { emit: t }) {
    const e = a, n = t, { siblingCount: l, disabled: s, showEdges: r } = te(e);
    R();
    const i = Q(e, "page", n, {
      defaultValue: e.defaultPage,
      passive: e.page === void 0
    }), u = A(() => Math.ceil(e.total / e.itemsPerPage));
    return kd({
      page: i,
      onPageChange(d) {
        i.value = d;
      },
      pageCount: u,
      siblingCount: l,
      disabled: s,
      showEdges: r
    }), (d, p) => (g(), w(o(O), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: m(() => [
        C(d.$slots, "default", {
          page: o(i),
          pageCount: u.value
        })
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Nm = /* @__PURE__ */ _({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(O), k(t, { "data-type": "ellipsis" }), {
      default: m(() => [
        C(e.$slots, "default", {}, () => [
          me("…")
        ])
      ]),
      _: 3
    }, 16));
  }
}), zm = /* @__PURE__ */ _({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = Nt();
    return R(), (n, l) => (g(), w(o(O), k(t, {
      "aria-label": "First Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: o(e).page.value === 1 || o(e).disabled.value,
      onClick: l[0] || (l[0] = (s) => o(e).onPageChange(1))
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("First page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), Km = /* @__PURE__ */ _({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = Nt();
    return R(), (n, l) => (g(), w(o(O), k(t, {
      "aria-label": "Last Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: o(e).page.value === o(e).pageCount.value || o(e).disabled.value,
      onClick: l[0] || (l[0] = (s) => o(e).onPageChange(o(e).pageCount.value))
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("Last page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
});
function Je(a, t) {
  const e = t - a + 1;
  return Array.from({ length: e }, (n, l) => l + a);
}
function Md(a) {
  return a.map((t) => typeof t == "number" ? { type: "page", value: t } : { type: "ellipsis" });
}
const pa = "ellipsis";
function Vd(a, t, e, n) {
  const s = t, r = Math.max(a - e, 1), i = Math.min(a + e, s), u = r > 1 + 2, d = i < s - 2;
  if (n) {
    const c = Math.min(2 * e + 5, t) - 2;
    if (!u && d)
      return [...Je(1, c), pa, s];
    if (u && !d) {
      const v = Je(s - c + 1, s);
      return [1, pa, ...v];
    }
    if (u && d) {
      const v = Je(r, i);
      return [1, pa, ...v, pa, s];
    }
    return Je(1, s);
  } else {
    const p = e * 2 + 1;
    return t < p ? Je(1, s) : a <= e + 1 ? Je(1, p) : t - a <= e ? Je(t - p + 1, s) : Je(r, i);
  }
}
const Hm = /* @__PURE__ */ _({
  __name: "PaginationList",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    R();
    const e = Nt(), n = A(() => Md(
      Vd(
        e.page.value,
        e.pageCount.value,
        e.siblingCount.value,
        e.showEdges.value
      )
    ));
    return (l, s) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(l.$slots, "default", { items: n.value })
      ]),
      _: 3
    }, 16));
  }
}), Wm = /* @__PURE__ */ _({
  __name: "PaginationListItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = Nt(), n = A(() => e.page.value === t.value);
    return (l, s) => (g(), w(o(O), k(t, {
      "data-type": "page",
      "aria-label": `Page ${l.value}`,
      "aria-current": n.value ? "page" : void 0,
      "data-selected": n.value ? "true" : void 0,
      disabled: o(e).disabled.value,
      type: l.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (r) => o(e).onPageChange(l.value))
    }), {
      default: m(() => [
        C(l.$slots, "default", {}, () => [
          me(ke(l.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-current", "data-selected", "disabled", "type"]));
  }
}), jm = /* @__PURE__ */ _({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = Nt();
    return (n, l) => (g(), w(o(O), k(t, {
      "aria-label": "Next Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: o(e).page.value === o(e).pageCount.value || o(e).disabled.value,
      onClick: l[0] || (l[0] = (s) => o(e).onPageChange(o(e).page.value + 1))
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("Next page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), Gm = /* @__PURE__ */ _({
  __name: "PaginationPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = Nt();
    return (n, l) => {
      var s;
      return g(), w(o(O), k(t, {
        "aria-label": "Previous Page",
        type: n.as === "button" ? "button" : void 0,
        disabled: o(e).page.value === 1 || ((s = o(e).disabled) == null ? void 0 : s.value),
        onClick: l[0] || (l[0] = (r) => o(e).onPageChange(o(e).page.value - 1))
      }), {
        default: m(() => [
          C(n.$slots, "default", {}, () => [
            me("Prev page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
}), Fd = ["id", "value", "name", "disabled", "required"], [Ld, Nd] = q("PinInputRoot"), Um = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    placeholder: { default: "" },
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: { default: "text" },
    dir: {},
    name: {},
    disabled: { type: Boolean },
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(a, { emit: t }) {
    const e = a, n = t, { mask: l, otp: s, placeholder: r, type: i, disabled: u, dir: d } = te(e), { forwardRef: p } = R(), c = Pe(d), f = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? [],
      passive: e.modelValue === void 0
    }), v = B(/* @__PURE__ */ new Set());
    function y(x) {
      v.value.add(x);
    }
    const h = A(() => f.value.filter((P) => !!P).length === v.value.size);
    return J(f, () => {
      h.value && n("complete", f.value);
    }, { deep: !0 }), Nd({
      modelValue: f,
      mask: l,
      otp: s,
      placeholder: r,
      type: i,
      dir: c,
      disabled: u,
      isCompleted: h,
      inputElements: v,
      onInputElementChange: y
    }), (x, P) => (g(), fe(xe, null, [
      j(o(O), k(x.$attrs, {
        ref: o(p),
        dir: o(c),
        "data-complete": h.value ? "" : void 0,
        "data-disabled": o(u) ? "" : void 0
      }), {
        default: m(() => [
          C(x.$slots, "default", { modelValue: o(f) })
        ]),
        _: 3
      }, 16, ["dir", "data-complete", "data-disabled"]),
      He("input", {
        id: x.id,
        type: "text",
        tabindex: "-1",
        "aria-hidden": "",
        value: o(f).join(""),
        name: x.name,
        disabled: o(u),
        required: x.required,
        style: ge({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }),
        onFocus: P[0] || (P[0] = ($) => {
          var b, S;
          return (S = (b = Array.from(v.value)) == null ? void 0 : b[0]) == null ? void 0 : S.focus();
        })
      }, null, 44, Fd)
    ], 64));
  }
}), zd = ["autocomplete", "type", "inputmode", "pattern", "placeholder", "value", "disabled", "data-disabled", "data-complete", "aria-label"], qm = /* @__PURE__ */ _({
  __name: "PinInputInput",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(a) {
    const t = a, e = Ld(), n = A(() => Array.from(e.inputElements.value)), l = A(() => t.disabled || e.disabled.value), s = A(() => e.otp.value), r = A(() => e.type.value === "number"), i = A(() => e.mask.value), u = B();
    function d(b) {
      var E;
      const S = b.target;
      if ((((E = b.data) == null ? void 0 : E.length) ?? 0) > 1) {
        x(S.value);
        return;
      }
      if (r.value && !/^[0-9]*$/.test(S.value)) {
        S.value = S.value.replace(/\D/g, "");
        return;
      }
      S.value = S.value.slice(-1), $(t.index, S.value);
      const D = n.value[t.index + 1];
      D && D.focus();
    }
    function p(b) {
      Ot(b, document.activeElement, void 0, {
        itemsArray: n.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: e.dir.value
      });
    }
    function c(b) {
      if (b.preventDefault(), b.target.value)
        $(t.index, "");
      else {
        const E = n.value[t.index - 1];
        E && (E.focus(), $(t.index - 1, ""));
      }
    }
    function f(b) {
      b.key === "Delete" && (b.preventDefault(), $(t.index, ""));
    }
    function v(b) {
      const S = b.target;
      S.setSelectionRange(1, 1), S.value || (S.placeholder = "");
    }
    function y(b) {
      const S = b.target;
      ne(() => {
        S.value || (S.placeholder = e.placeholder.value);
      });
    }
    function h(b) {
      b.preventDefault();
      const S = b.clipboardData;
      if (!S)
        return;
      const D = S.getData("text");
      x(D);
    }
    function x(b) {
      var T;
      const S = [...e.modelValue.value], D = b.length >= n.value.length ? 0 : t.index, E = Math.min(D + b.length, n.value.length);
      for (let M = D; M < E; M++) {
        const V = n.value[M], I = b[M - D];
        r.value && !/^[0-9]*$/.test(I) || (S[M] = I, V.focus());
      }
      e.modelValue.value = S, (T = n.value[E]) == null || T.focus();
    }
    function P(b) {
      let S = b.length - 1;
      for (; S >= 0 && b[S] === ""; )
        b.pop(), S--;
      return b;
    }
    function $(b, S) {
      const D = [...e.modelValue.value];
      D[b] = S, e.modelValue.value = P(D);
    }
    return ae(() => {
      e.onInputElementChange(u.value);
    }), De(() => {
      var b;
      (b = e.inputElements) == null || b.value.delete(u.value);
    }), (b, S) => (g(), fe("input", {
      ref_key: "inputRef",
      ref: u,
      autocapitalize: "none",
      autocomplete: s.value ? "one-time-code" : "false",
      type: i.value ? "password" : "text",
      inputmode: r.value ? "numeric" : "text",
      pattern: r.value ? "[0-9]*" : void 0,
      placeholder: o(e).placeholder.value,
      value: o(e).modelValue.value.at(b.index),
      disabled: l.value,
      "data-disabled": l.value ? "" : void 0,
      "data-complete": o(e).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${b.index + 1} of ${n.value.length}`,
      onInput: S[0] || (S[0] = (D) => d(D)),
      onKeydown: [
        he(p, ["left", "right", "up", "down", "home", "end"]),
        he(c, ["backspace"]),
        he(f, ["delete"])
      ],
      onFocus: v,
      onBlur: y,
      onPaste: h
    }, null, 40, zd));
  }
}), [St, Kd] = q("PopoverRoot"), Ml = /* @__PURE__ */ _({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, { modal: l } = te(e), s = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), r = B(), i = B(!1);
    return Kd({
      contentId: "",
      modal: l,
      open: s,
      onOpenChange: (u) => {
        s.value = u;
      },
      onOpenToggle: () => {
        s.value = !s.value;
      },
      triggerElement: r,
      hasCustomAnchor: i
    }), (u, d) => (g(), w(o(_t), null, {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Vl = /* @__PURE__ */ _({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = St(), { forwardRef: n, currentElement: l } = R();
    return ae(() => {
      e.triggerElement.value = l.value;
    }), (s, r) => (g(), w(Ge(o(e).hasCustomAnchor.value ? o(O) : o(wt)), { "as-child": "" }, {
      default: m(() => [
        j(o(O), {
          ref: o(n),
          type: s.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": o(e).open.value,
          "aria-controls": o(e).contentId,
          "data-state": o(e).open.value ? "open" : "closed",
          as: s.as,
          "as-child": t.asChild,
          onClick: o(e).onOpenToggle
        }, {
          default: m(() => [
            C(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
}), Fl = /* @__PURE__ */ _({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ll = /* @__PURE__ */ _({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = bt(e), { forwardRef: s } = R(), r = St();
    return Pn(), (i, u) => (g(), w(o(Ba), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => n("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => n("closeAutoFocus", d))
    }, {
      default: m(() => [
        j(o(dt), {
          "as-child": "",
          "disable-outside-pointer-events": i.disableOutsidePointerEvents,
          onPointerDownOutside: u[0] || (u[0] = (d) => n("pointerDownOutside", d)),
          onInteractOutside: u[1] || (u[1] = (d) => n("interactOutside", d)),
          onEscapeKeyDown: u[2] || (u[2] = (d) => n("escapeKeyDown", d)),
          onFocusOutside: u[3] || (u[3] = (d) => n("focusOutside", d)),
          onDismiss: u[4] || (u[4] = (d) => o(r).onOpenChange(!1))
        }, {
          default: m(() => [
            j(o(ht), k(o(l), {
              id: o(r).contentId,
              ref: o(s),
              "data-state": o(r).open.value ? "open" : "closed",
              role: "dialog",
              style: {
                "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
              }
            }), {
              default: m(() => [
                C(i.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Hd = /* @__PURE__ */ _({
  __name: "PopoverContentModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = St(), s = B(!1);
    oa(!0);
    const r = be(e, n), { forwardRef: i, currentElement: u } = R();
    return la(u), (d, p) => (g(), w(Ll, k(o(r), {
      ref: o(i),
      "trap-focus": o(l).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: p[0] || (p[0] = ye(
        (c) => {
          var f;
          n("closeAutoFocus", c), s.value || (f = o(l).triggerElement.value) == null || f.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: p[1] || (p[1] = (c) => {
        n("pointerDownOutside", c);
        const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, y = f.button === 2 || v;
        s.value = y;
      }),
      onFocusOutside: p[2] || (p[2] = ye(() => {
      }, ["prevent"]))
    }), {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Wd = /* @__PURE__ */ _({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = St(), s = B(!1), r = B(!1), i = be(e, n);
    return (u, d) => (g(), w(Ll, k(o(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (p) => {
        var c;
        n("closeAutoFocus", p), p.defaultPrevented || (s.value || (c = o(l).triggerElement.value) == null || c.focus(), p.preventDefault()), s.value = !1, r.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (p) => {
        var v;
        n("interactOutside", p), p.defaultPrevented || (s.value = !0, p.detail.originalEvent.type === "pointerdown" && (r.value = !0));
        const c = p.target;
        ((v = o(l).triggerElement.value) == null ? void 0 : v.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === "focusin" && r.value && p.preventDefault();
      })
    }), {
      default: m(() => [
        C(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Nl = /* @__PURE__ */ _({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = St(), s = be(e, n), { forwardRef: r } = R();
    return l.contentId || (l.contentId = ve(void 0, "radix-vue-popover-content")), (i, u) => (g(), w(o(we), {
      present: i.forceMount || o(l).open.value
    }, {
      default: m(() => [
        o(l).modal.value ? (g(), w(Hd, k({ key: 0 }, o(s), { ref: o(r) }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (g(), w(Wd, k({ key: 1 }, o(s), { ref: o(r) }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), zl = /* @__PURE__ */ _({
  __name: "PopoverArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Mt), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Kl = /* @__PURE__ */ _({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = St();
    return (n, l) => (g(), w(o(O), {
      type: n.as === "button" ? "button" : void 0,
      as: n.as,
      "as-child": t.asChild,
      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))
    }, {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as", "as-child"]));
  }
}), Hl = /* @__PURE__ */ _({
  __name: "PopoverAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    R();
    const e = St();
    return zo(() => {
      e.hasCustomAnchor.value = !0;
    }), De(() => {
      e.hasCustomAnchor.value = !1;
    }), (n, l) => (g(), w(o(wt), N(K(t)), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zt = 100, [jd, Gd] = q("ProgressRoot"), no = (a) => typeof a == "number";
function Ud(a, t) {
  return a === null || no(a) && !Number.isNaN(a) && a <= t && a >= 0 ? a : (console.error(`Invalid prop \`value\` of value \`${a}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Zt} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function qd(a) {
  return no(a) && !Number.isNaN(a) && a > 0 ? a : (console.error(
    `Invalid prop \`max\` of value \`${a}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Zt}\`.`
  ), Zt);
}
const Ym = /* @__PURE__ */ _({
  __name: "ProgressRoot",
  props: {
    modelValue: {},
    max: { default: Zt },
    getValueLabel: { type: Function, default: (a, t) => `${Math.round(a / t * Zt)}%` },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:max"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    const l = Q(e, "modelValue", n, {
      passive: e.modelValue === void 0
    }), s = Q(e, "max", n, {
      passive: e.max === void 0
    });
    J(
      () => l.value,
      async (i) => {
        const u = Ud(i, e.max);
        u !== i && (await ne(), l.value = u);
      },
      { immediate: !0 }
    ), J(
      () => e.max,
      (i) => {
        const u = qd(e.max);
        u !== i && (s.value = u);
      },
      { immediate: !0 }
    );
    const r = A(() => l.value ? l.value === s.value ? "complete" : "loading" : "indeterminate");
    return Gd({
      modelValue: l,
      max: s,
      progressState: r
    }), (i, u) => (g(), w(o(O), {
      "as-child": i.asChild,
      as: i.as,
      "aria-valuemax": o(s),
      "aria-valuemin": 0,
      "aria-valuenow": no(o(l)) ? o(l) : void 0,
      "aria-valuetext": i.getValueLabel(o(l), o(s)),
      "aria-label": i.getValueLabel(o(l), o(s)),
      role: "progressbar",
      "data-state": r.value,
      "data-value": o(l) ?? void 0,
      "data-max": o(s)
    }, {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"]));
  }
}), Xm = /* @__PURE__ */ _({
  __name: "ProgressIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = jd();
    return R(), (n, l) => {
      var s;
      return g(), w(o(O), k(t, {
        "data-state": o(e).progressState.value,
        "data-value": ((s = o(e).modelValue) == null ? void 0 : s.value) ?? void 0,
        "data-max": o(e).max.value
      }), {
        default: m(() => [
          C(n.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-state", "data-value", "data-max"]);
    };
  }
}), [Yd, Xd] = q("RadioGroupRoot"), Zm = /* @__PURE__ */ _({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean, default: !1 },
    name: {},
    required: { type: Boolean, default: !1 },
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l } = R(), s = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), { disabled: r, loop: i, orientation: u, name: d, required: p, dir: c } = te(e), f = Pe(c);
    return Xd({
      modelValue: s,
      changeModelValue: (v) => {
        s.value = v;
      },
      disabled: r,
      loop: i,
      orientation: u,
      name: d == null ? void 0 : d.value,
      required: p
    }), (v, y) => (g(), w(o(Ft), {
      "as-child": "",
      orientation: o(u),
      dir: o(f),
      loop: o(i)
    }, {
      default: m(() => [
        j(o(O), {
          ref: o(l),
          role: "radiogroup",
          "data-disabled": o(r) ? "" : void 0,
          "as-child": v.asChild,
          as: v.as,
          required: o(p),
          "aria-orientation": o(u),
          "aria-required": o(p),
          dir: o(f),
          name: o(d)
        }, {
          default: m(() => [
            C(v.$slots, "default")
          ]),
          _: 3
        }, 8, ["data-disabled", "as-child", "as", "required", "aria-orientation", "aria-required", "dir", "name"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), Zd = ["value", "checked", "name", "disabled", "required"], Jd = /* @__PURE__ */ _({
  __name: "Radio",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    name: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(a, { emit: t }) {
    const e = a, l = Q(e, "checked", t, {
      passive: e.checked === void 0
    }), { value: s } = te(e), { forwardRef: r, currentElement: i } = R(), u = gt(i), d = A(() => {
      var c;
      return e.id && i.value ? ((c = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : c.innerText) ?? e.value : void 0;
    });
    function p(c) {
      l.value = !0, u.value && c.stopPropagation();
    }
    return (c, f) => (g(), w(o(O), k(c.$attrs, {
      id: c.id,
      ref: o(r),
      role: "radio",
      type: c.as === "button" ? "button" : void 0,
      as: c.as,
      "aria-checked": o(l),
      "aria-label": d.value,
      "as-child": c.asChild,
      disabled: c.disabled ? !0 : void 0,
      "data-state": o(l) ? "checked" : "unchecked",
      "data-disabled": c.disabled ? "" : void 0,
      value: o(s),
      required: c.required,
      name: c.name,
      onClick: ye(p, ["stop"])
    }), {
      default: m(() => [
        C(c.$slots, "default"),
        o(u) ? (g(), fe("input", {
          key: 0,
          type: "radio",
          tabindex: "-1",
          "aria-hidden": "",
          value: o(s),
          checked: !!o(l),
          name: c.name,
          disabled: c.disabled,
          required: c.required,
          style: ge({
            transform: "translateX(-100%)",
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
          })
        }, null, 12, Zd)) : re("", !0)
      ]),
      _: 3
    }, 16, ["id", "type", "as", "aria-checked", "aria-label", "as-child", "disabled", "data-state", "data-disabled", "value", "required", "name"]));
  }
}), [Qd, ec] = q("RadioGroupItem"), Jm = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    name: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, { forwardRef: e, currentElement: n } = R(), l = Yd(), s = A(() => l.disabled.value || t.disabled), r = A(() => l.required.value || t.required), i = A(() => {
      var c;
      return ((c = l.modelValue) == null ? void 0 : c.value) === t.value;
    });
    ec({ disabled: s, checked: i });
    const u = B(!1), d = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    ot("keydown", (c) => {
      d.includes(c.key) && (u.value = !0);
    }), ot("keyup", () => {
      u.value = !1;
    });
    function p() {
      setTimeout(() => {
        var c;
        u.value && ((c = n.value) == null || c.click());
      }, 0);
    }
    return (c, f) => (g(), w(o(Lt), {
      checked: i.value,
      disabled: s.value,
      "as-child": "",
      focusable: !s.value,
      active: i.value
    }, {
      default: m(() => [
        j(Jd, k({ ...c.$attrs, ...t }, {
          ref: o(e),
          checked: i.value,
          required: r.value,
          "onUpdate:checked": f[0] || (f[0] = (v) => o(l).changeModelValue(c.value)),
          onKeydown: f[1] || (f[1] = he(ye(() => {
          }, ["prevent"]), ["enter"])),
          onFocus: p
        }), {
          default: m(() => [
            C(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["checked", "required"])
      ]),
      _: 3
    }, 8, ["checked", "disabled", "focusable", "active"]));
  }
}), Qm = /* @__PURE__ */ _({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const { forwardRef: t } = R(), e = Qd();
    return (n, l) => (g(), w(o(we), {
      present: n.forceMount || o(e).checked.value
    }, {
      default: m(() => [
        j(o(O), k({
          ref: o(t),
          "data-state": o(e).checked.value ? "checked" : "unchecked",
          "data-disabled": o(e).disabled.value ? "" : void 0,
          "as-child": n.asChild,
          as: n.as
        }, n.$attrs), {
          default: m(() => [
            C(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
function tc(a) {
  const t = A(() => a.start.value ? !!a.isDateDisabled(a.start.value) : !1), e = A(() => a.end.value ? !!a.isDateDisabled(a.end.value) : !1), n = A(
    () => t.value || e.value ? !1 : !!(a.start.value && a.end.value && Be(a.end.value, a.start.value))
  ), l = (u) => a.start.value ? Se(a.start.value, u) : !1, s = (u) => a.end.value ? Se(a.end.value, u) : !1, r = (u) => a.start.value && Se(a.start.value, u) || a.end.value && Se(a.end.value, u) ? !0 : a.end.value && a.start.value ? ur(u, a.start.value, a.end.value) : !1, i = A(() => {
    if (a.start.value && a.end.value || !a.start.value || !a.focusedValue.value)
      return null;
    const u = Be(a.start.value, a.focusedValue.value), d = u ? a.start.value : a.focusedValue.value, p = u ? a.focusedValue.value : a.start.value;
    return Se(d.add({ days: 1 }), p) ? {
      start: d,
      end: p
    } : Uo(d, p, a.isDateUnavailable, a.isDateDisabled) ? {
      start: d,
      end: p
    } : null;
  });
  return {
    isInvalid: n,
    isSelected: r,
    highlightedRange: i,
    isSelectionStart: l,
    isSelectionEnd: s
  };
}
const ac = { style: { border: "0px", clip: "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(50%)", height: "1px", margin: "-1px", overflow: "hidden", padding: "0px", position: "absolute", "white-space": "nowrap", width: "1px" } }, nc = {
  role: "heading",
  "aria-level": "2"
}, [zt, oc] = q("RangeCalendarRoot"), lc = /* @__PURE__ */ _({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {},
    defaultValue: { default: void 0 },
    modelValue: {},
    placeholder: { default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    preventDeselect: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    calendarLabel: {},
    fixedWeeks: { type: Boolean, default: !1 },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    numberOfMonths: { default: 1 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    initialFocus: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    isDateUnavailable: { type: Function, default: void 0 },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(a, { emit: t }) {
    const e = a, n = t, {
      disabled: l,
      readonly: s,
      initialFocus: r,
      pagedNavigation: i,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: p,
      numberOfMonths: c,
      preventDeselect: f,
      isDateUnavailable: v,
      isDateDisabled: y,
      calendarLabel: h,
      maxValue: x,
      minValue: P,
      locale: $
    } = te(e), { primitiveElement: b, currentElement: S } = it(), D = B(), E = B(), T = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? { start: void 0, end: void 0 },
      passive: e.modelValue === void 0
    }), M = Tt({
      defaultPlaceholder: e.placeholder,
      defaultValue: T.value.start
    }), V = B(T.value.start), I = B(T.value.end), L = Q(e, "placeholder", n, {
      defaultValue: e.defaultPlaceholder ?? M.copy(),
      passive: e.placeholder === void 0
    });
    function G(_e) {
      L.value = _e.copy();
    }
    const {
      fullCalendarLabel: X,
      headingValue: H,
      isDateDisabled: z,
      isDateUnavailable: F,
      isNextButtonDisabled: Y,
      isPrevButtonDisabled: U,
      grid: Z,
      weekdays: oe,
      isOutsideVisibleView: ee,
      nextPage: W,
      prevPage: ce,
      formatter: pe
    } = ml({
      locale: $,
      placeholder: L,
      weekStartsOn: e.weekStartsOn,
      fixedWeeks: e.fixedWeeks,
      numberOfMonths: e.numberOfMonths,
      minValue: P,
      maxValue: x,
      disabled: l,
      weekdayFormat: e.weekdayFormat,
      pagedNavigation: e.pagedNavigation,
      isDateDisabled: y.value,
      isDateUnavailable: v.value,
      calendarLabel: h.value
    }), {
      isInvalid: ue,
      isSelected: Ee,
      highlightedRange: se,
      isSelectionStart: ie,
      isSelectionEnd: Ce
    } = tc({
      start: V,
      end: I,
      isDateDisabled: z,
      isDateUnavailable: F,
      focusedValue: E
    });
    J(T, () => {
      T.value.start && T.value.end && (V.value && T.value.start.compare(V.value) !== 0 && (V.value = T.value.start.copy()), I.value && T.value.end.compare(I.value) !== 0 && (I.value = T.value.end.copy()));
    }), J(V, (_e) => {
      _e && !Re(_e, L.value) && G(_e);
    }), J([V, I], () => {
      T.value && T.value.start && T.value.end && V.value && I.value && Se(T.value.start, V.value) && Se(T.value.end, I.value) || V.value && I.value && (Be(I.value, V.value) ? T.value = {
        start: I.value.copy(),
        end: V.value.copy()
      } : T.value = {
        start: V.value.copy(),
        end: I.value.copy()
      });
    });
    const Ie = A(() => {
      const _e = L.value.copy();
      return Yo({
        dateObj: _e,
        minValue: P.value,
        maxValue: x.value,
        numberOfMonths: c.value,
        pagedNavigation: i.value
      });
    }), Oe = tl(({ startIndex: _e, endIndex: Ye }) => {
      const Ht = L.value.copy();
      return qo({
        dateObj: Ht,
        startIndex: _e,
        endIndex: Ye,
        minValue: P.value,
        maxValue: x.value
      });
    });
    return oc({
      isDateUnavailable: F,
      startValue: V,
      endValue: I,
      formatter: pe,
      modelValue: T,
      placeholder: L,
      disabled: l,
      initialFocus: r,
      pagedNavigation: i,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: p,
      numberOfMonths: c,
      readonly: s,
      preventDeselect: f,
      fullCalendarLabel: X,
      headingValue: H,
      isInvalid: ue,
      isDateDisabled: z,
      highlightedRange: se,
      focusedValue: E,
      lastPressedDateValue: D,
      isSelected: Ee,
      isSelectionEnd: Ce,
      isSelectionStart: ie,
      isNextButtonDisabled: Y,
      isPrevButtonDisabled: U,
      isOutsideVisibleView: ee,
      nextPage: W,
      prevPage: ce,
      parentElement: S,
      onPlaceholderChange: G,
      locale: $
    }), ae(() => {
      r.value && Qo(S.value);
    }), (_e, Ye) => (g(), w(o(O), {
      ref_key: "primitiveElement",
      ref: b,
      as: _e.as,
      "as-child": _e.asChild,
      role: "application",
      "aria-label": o(X),
      "data-readonly": o(s) ? "" : void 0,
      "data-disabled": o(l) ? "" : void 0,
      "data-invalid": o(ue) ? "" : void 0
    }, {
      default: m(() => [
        He("div", ac, [
          He("div", nc, ke(o(X)), 1)
        ]),
        C(_e.$slots, "default", {
          date: o(L),
          grid: o(Z),
          weekDays: o(oe),
          formatter: o(pe),
          getMonths: Ie.value,
          getYears: o(Oe)
        })
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-label", "data-readonly", "data-disabled", "data-invalid"]));
  }
}), sc = /* @__PURE__ */ _({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), rc = /* @__PURE__ */ _({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a, e = zt();
    return (n, l) => (g(), w(o(O), k(t, {
      "data-disabled": o(e).disabled.value ? "" : void 0
    }), {
      default: m(() => [
        C(n.$slots, "default", {
          headingValue: o(e).headingValue.value
        }, () => [
          me(ke(o(e).headingValue.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), ic = /* @__PURE__ */ _({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: { default: "table" }
  },
  setup(a) {
    const t = a, e = zt();
    return (n, l) => (g(), w(o(O), k(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": o(e).readonly ? !0 : void 0,
      "aria-disabled": o(e).disabled ? !0 : void 0,
      "data-readonly": o(e).readonly ? "" : void 0,
      "data-disabled": o(e).disabled ? "" : void 0
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-readonly", "aria-disabled", "data-readonly", "data-disabled"]));
  }
}), uc = /* @__PURE__ */ _({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: { default: "td" }
  },
  setup(a) {
    const t = zt();
    return (e, n) => {
      var l, s;
      return g(), w(o(O), {
        as: e.as,
        "as-child": e.asChild,
        role: "gridcell",
        "aria-selected": o(t).isSelected(e.date) ? !0 : void 0,
        "aria-disabled": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),
        "data-disabled": o(t).isDateDisabled(e.date) ? "" : void 0
      }, {
        default: m(() => [
          C(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "aria-selected", "aria-disabled", "data-disabled"]);
    };
  }
}), dc = /* @__PURE__ */ _({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: { default: "th" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cc = /* @__PURE__ */ _({
  __name: "RangeCalendarNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = zt();
    return (n, l) => (g(), w(o(O), k(t, {
      "aria-label": "Next page",
      type: n.as === "button" ? "button" : void 0,
      "aria-disabled": o(e).isNextButtonDisabled.value || void 0,
      "data-disabled": o(e).isNextButtonDisabled.value || void 0,
      disabled: o(e).isNextButtonDisabled.value,
      onClick: o(e).nextPage
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("Next page")
        ])
      ]),
      _: 3
    }, 16, ["type", "aria-disabled", "data-disabled", "disabled", "onClick"]));
  }
}), pc = /* @__PURE__ */ _({
  __name: "RangeCalendarPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = zt();
    return (n, l) => (g(), w(o(O), k(t, {
      "aria-label": "Previous page",
      type: n.as === "button" ? "button" : void 0,
      "aria-disabled": o(e).isPrevButtonDisabled.value || void 0,
      "data-disabled": o(e).isPrevButtonDisabled.value || void 0,
      disabled: o(e).isPrevButtonDisabled.value,
      onClick: o(e).prevPage
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me("Prev page")
        ])
      ]),
      _: 3
    }, 16, ["type", "aria-disabled", "data-disabled", "disabled", "onClick"]));
  }
}), fc = /* @__PURE__ */ _({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: { default: "thead" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), k(t, { "aria-hidden": "true" }), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vc = /* @__PURE__ */ _({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: { default: "tbody" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mc = /* @__PURE__ */ _({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: { default: "tr" }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hc = /* @__PURE__ */ _({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a, e = zt(), n = Ct(), { primitiveElement: l, currentElement: s } = it(), r = A(() => e.formatter.custom(Ve(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = A(() => e.isDateDisabled(t.day)), u = A(() => {
      var E;
      return (E = e.isDateUnavailable) == null ? void 0 : E.call(e, t.day);
    }), d = A(() => e.isSelected(t.day)), p = A(() => e.isSelectionStart(t.day)), c = A(() => e.isSelectionEnd(t.day)), f = A(() => e.highlightedRange.value ? ir(t.day, e.highlightedRange.value.start, e.highlightedRange.value.end) : !1), v = "[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-month]):not([data-outside-visible-months])", y = A(() => jo(t.day, Pa())), h = A(() => !hn(t.day, t.month)), x = A(
      () => e.isOutsideVisibleView(t.day)
    ), P = A(() => Se(t.day, e.placeholder.value));
    function $(E) {
      var T;
      if (!e.readonly.value && !(e.isDateDisabled(E) || (T = e.isDateUnavailable) != null && T.call(e, E))) {
        if (e.lastPressedDateValue.value = E.copy(), e.startValue.value && e.highlightedRange.value === null) {
          if (Se(E, e.startValue.value) && !e.preventDeselect.value && !e.endValue.value) {
            e.startValue.value = void 0, e.onPlaceholderChange(E);
            return;
          } else if (!e.endValue.value) {
            e.lastPressedDateValue.value && Se(e.lastPressedDateValue.value, E) && (e.startValue.value = E.copy());
            return;
          }
        }
        if (e.startValue.value && Se(e.startValue.value, E) && !e.preventDeselect.value && !e.endValue.value) {
          e.startValue.value = void 0, e.onPlaceholderChange(E);
          return;
        }
        e.startValue.value ? e.endValue.value ? e.endValue.value && e.startValue.value && (e.endValue.value = void 0, e.startValue.value = E.copy()) : e.endValue.value = E.copy() : e.startValue.value = E.copy();
      }
    }
    function b(E) {
      var M;
      const T = Ut(E.target.getAttribute("data-value"), e.placeholder.value);
      e.isDateDisabled(T) || (M = e.isDateUnavailable) != null && M.call(e, T) || $(T);
    }
    function S(E) {
      var M;
      const T = Ut(E.target.getAttribute("data-value"), e.placeholder.value);
      e.isDateDisabled(T) || (M = e.isDateUnavailable) != null && M.call(e, T) || (e.focusedValue.value = T.copy());
    }
    function D(E) {
      const T = E.target;
      E.preventDefault(), E.stopPropagation();
      const M = e.parentElement.value, V = M ? Array.from(M.querySelectorAll(v)) : [];
      let L = V.indexOf(s.value);
      const G = 7;
      switch (E.code) {
        case n.ARROW_RIGHT:
          L++;
          break;
        case n.ARROW_LEFT:
          L--;
          break;
        case n.ARROW_UP:
          L -= G;
          break;
        case n.ARROW_DOWN:
          L += G;
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          $(Ut(T.getAttribute("data-value"), e.placeholder.value));
          return;
        default:
          return;
      }
      if (L >= 0 && L < V.length) {
        V[L].focus();
        return;
      }
      if (L < 0) {
        if (e.isPrevButtonDisabled.value)
          return;
        e.prevPage(), ne(() => {
          const X = M ? Array.from(M.querySelectorAll(v)) : [];
          X[X.length - Math.abs(L)].focus();
        });
        return;
      }
      if (L >= V.length) {
        if (e.isNextButtonDisabled.value)
          return;
        e.nextPage(), ne(() => {
          (M ? Array.from(M.querySelectorAll(v)) : [])[L - V.length].focus();
        });
      }
    }
    return (E, T) => (g(), w(o(O), k({
      ref_key: "primitiveElement",
      ref: l
    }, t, {
      role: "button",
      "aria-label": r.value,
      "data-radix-vue-calendar-cell-trigger": "",
      "aria-selected": d.value ? !0 : void 0,
      "aria-disabled": h.value || i.value || u.value ? !0 : void 0,
      "data-highlighted": f.value ? "" : void 0,
      "data-selection-start": p.value ? !0 : void 0,
      "data-selection-end": c.value ? !0 : void 0,
      "data-selected": d.value ? !0 : void 0,
      "data-outside-visible-view": x.value ? "" : void 0,
      "data-value": E.day.toString(),
      "data-disabled": i.value || h.value ? "" : void 0,
      "data-unavailable": u.value ? "" : void 0,
      "data-today": y.value ? "" : void 0,
      "data-outside-month": h.value ? "" : void 0,
      "data-focused": P.value ? "" : void 0,
      tabindex: P.value ? 0 : h.value || i.value ? void 0 : -1,
      onClick: b,
      onFocusin: S,
      onMouseenter: S,
      onKeydown: he(D, ["up", "down", "left", "right", "enter", "space"])
    }), {
      default: m(() => [
        C(E.$slots, "default", {}, () => [
          me(ke(E.day.day.toLocaleString(o(e).locale.value)), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-selected", "aria-disabled", "data-highlighted", "data-selection-start", "data-selection-end", "data-selected", "data-outside-visible-view", "data-value", "data-disabled", "data-unavailable", "data-today", "data-outside-month", "data-focused", "tabindex"]));
  }
}), [Fe, yc] = q("ScrollAreaRoot"), eh = /* @__PURE__ */ _({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: {},
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e, currentElement: n } = R(), l = B(0), s = B(0), r = B(), i = B(), u = B(), d = B(), p = B(!1), c = B(!1), { type: f, dir: v, scrollHideDelay: y } = te(t), h = Pe(v);
    return yc({
      type: f,
      dir: h,
      scrollHideDelay: y,
      scrollArea: n,
      viewport: r,
      onViewportChange: (x) => {
        r.value = x || void 0;
      },
      content: i,
      onContentChange: (x) => {
        i.value = x;
      },
      scrollbarX: u,
      scrollbarXEnabled: p,
      scrollbarY: d,
      scrollbarYEnabled: c,
      onScrollbarXChange: (x) => {
        u.value = x || void 0;
      },
      onScrollbarYChange: (x) => {
        d.value = x || void 0;
      },
      onScrollbarXEnabledChange: (x) => {
        p.value = x;
      },
      onScrollbarYEnabledChange: (x) => {
        c.value = x;
      },
      onCornerWidthChange: (x) => {
        l.value = x;
      },
      onCornerHeightChange: (x) => {
        s.value = x;
      }
    }), (x, P) => (g(), w(o(O), {
      ref: o(e),
      "as-child": t.asChild,
      as: x.as,
      dir: o(h),
      style: ge({
        position: "relative",
        // Pass corner sizes as CSS vars to reduce re-renders of context consumers
        "--radix-scroll-area-corner-width": `${l.value}px`,
        "--radix-scroll-area-corner-height": `${s.value}px`
      })
    }, {
      default: m(() => [
        C(x.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]));
  }
}), th = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a, { expose: t }) {
    const e = a, n = Fe(), l = B();
    ae(() => {
      n.onViewportChange(l.value), n.onContentChange(r.value);
    }), t({
      viewportElement: l
    });
    const { forwardRef: s, currentElement: r } = R();
    return (i, u) => (g(), fe(xe, null, [
      He("div", k({
        ref_key: "viewportElement",
        ref: l,
        "data-radix-scroll-area-viewport": "",
        style: {
          /**
           * We don't support `visible` because the intention is to have at least one scrollbar
           * if this component is used and `visible` will behave like `auto` in that case
           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
           *
           * We don't handle `auto` because the intention is for the native implementation
           * to be hidden if using this component. We just want to ensure the node is scrollable
           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
           * the browser from having to work out whether to render native scrollbars or not,
           * we tell it to with the intention of hiding them in CSS.
           */
          overflowX: o(n).scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: o(n).scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      }, i.$attrs, { tabindex: 0 }), [
        j(o(O), {
          ref: o(s),
          style: { minWidth: "100%", display: "table" },
          "as-child": e.asChild,
          as: i.as
        }, {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ], 16),
      j(o(O), {
        as: "style",
        nonce: i.nonce
      }, {
        default: m(() => [
          me(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
        ]),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
});
function gc(a, [t, e]) {
  return Math.min(e, Math.max(t, a));
}
function Wl(a, t) {
  return (e) => {
    if (a[0] === a[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (a[1] - a[0]);
    return t[0] + n * (e - a[0]);
  };
}
function Oa(a) {
  const t = jl(a.viewport, a.content), e = a.scrollbar.paddingStart + a.scrollbar.paddingEnd, n = (a.scrollbar.size - e) * t;
  return Math.max(n, 18);
}
function jl(a, t) {
  const e = a / t;
  return Number.isNaN(e) ? 0 : e;
}
function bc(a, t = () => {
}) {
  let e = { left: a.scrollLeft, top: a.scrollTop }, n = 0;
  return function l() {
    const s = { left: a.scrollLeft, top: a.scrollTop }, r = e.left !== s.left, i = e.top !== s.top;
    (r || i) && t(), e = s, n = window.requestAnimationFrame(l);
  }(), () => window.cancelAnimationFrame(n);
}
function xo(a, t, e = "ltr") {
  const n = Oa(t), l = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - l, r = t.content - t.viewport, i = s - n, u = e === "ltr" ? [0, r] : [r * -1, 0], d = gc(
    a,
    u
  );
  return Wl([0, r], [0, i])(d);
}
function fa(a) {
  return a ? Number.parseInt(a, 10) : 0;
}
function Cc(a, t, e, n = "ltr") {
  const l = Oa(e), s = l / 2, r = t || s, i = l - r, u = e.scrollbar.paddingStart + r, d = e.scrollbar.size - e.scrollbar.paddingEnd - i, p = e.content - e.viewport, c = n === "ltr" ? [0, p] : [p * -1, 0];
  return Wl(
    [u, d],
    c
  )(a);
}
function Po(a, t) {
  return a > 0 && a < t;
}
const Gl = /* @__PURE__ */ _({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = Fe(), s = ka(), r = Ma(), { forwardRef: i, currentElement: u } = R(), d = B(""), p = B();
    function c(P) {
      var $, b;
      if (p.value) {
        const S = P.clientX - (($ = p.value) == null ? void 0 : $.left), D = P.clientY - ((b = p.value) == null ? void 0 : b.top);
        n("onDragScroll", { x: S, y: D });
      }
    }
    function f(P) {
      P.button === 0 && (P.target.setPointerCapture(P.pointerId), p.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", l.viewport && (l.viewport.value.style.scrollBehavior = "auto"), c(P));
    }
    function v(P) {
      c(P);
    }
    function y(P) {
      const $ = P.target;
      $.hasPointerCapture(P.pointerId) && $.releasePointerCapture(P.pointerId), document.body.style.webkitUserSelect = d.value, l.viewport && (l.viewport.value.style.scrollBehavior = ""), p.value = void 0;
    }
    function h(P) {
      var D;
      const $ = P.target, b = (D = u.value) == null ? void 0 : D.contains($), S = s.sizes.value.content - s.sizes.value.viewport;
      b && s.handleWheelScroll(P, S);
    }
    ae(() => {
      document.addEventListener("wheel", h, { passive: !1 });
    }), De(() => {
      document.removeEventListener("wheel", h);
    });
    function x() {
      var P, $, b, S, D;
      u.value && (e.isHorizontal ? s.handleSizeChange({
        content: ((P = l.viewport.value) == null ? void 0 : P.scrollWidth) ?? 0,
        viewport: (($ = l.viewport.value) == null ? void 0 : $.offsetWidth) ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: fa(getComputedStyle(u.value).paddingLeft),
          paddingEnd: fa(getComputedStyle(u.value).paddingRight)
        }
      }) : s.handleSizeChange({
        content: ((b = l.viewport.value) == null ? void 0 : b.scrollHeight) ?? 0,
        viewport: ((S = l.viewport.value) == null ? void 0 : S.offsetHeight) ?? 0,
        scrollbar: {
          size: ((D = u.value) == null ? void 0 : D.clientHeight) ?? 0,
          paddingStart: fa(getComputedStyle(u.value).paddingLeft),
          paddingEnd: fa(getComputedStyle(u.value).paddingRight)
        }
      }));
    }
    return We(u, x), We(l.content, x), (P, $) => (g(), w(o(O), {
      ref: o(i),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: o(r).as.value,
      "as-child": o(r).asChild.value,
      onPointerdown: f,
      onPointermove: v,
      onPointerup: y
    }, {
      default: m(() => [
        C(P.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), _c = /* @__PURE__ */ _({
  __name: "ScrollAreaScrollbarX",
  setup(a) {
    const t = Fe(), e = ka(), { forwardRef: n, currentElement: l } = R();
    ae(() => {
      l.value && t.onScrollbarXChange(l.value);
    });
    const s = A(() => e.sizes.value);
    return (r, i) => (g(), w(Gl, {
      ref: o(n),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: ge({
        bottom: 0,
        left: o(t).dir.value === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: o(t).dir.value === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": s.value ? `${o(Oa)(s.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.x))
    }, {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), wc = /* @__PURE__ */ _({
  __name: "ScrollAreaScrollbarY",
  setup(a) {
    const t = Fe(), e = ka(), { forwardRef: n, currentElement: l } = R();
    ae(() => {
      l.value && t.onScrollbarYChange(l.value);
    });
    const s = A(() => e.sizes.value);
    return (r, i) => (g(), w(Gl, {
      ref: o(n),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: ge({
        top: 0,
        right: o(t).dir.value === "ltr" ? 0 : void 0,
        left: o(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": s.value ? `${o(Oa)(s.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.y))
    }, {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), [ka, xc] = q("ScrollAreaScrollbarVisible"), oo = /* @__PURE__ */ _({
  __name: "ScrollAreaScrollbarVisible",
  setup(a) {
    const t = Fe(), e = Ma(), { forwardRef: n } = R(), l = B({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }), s = A(() => {
      const P = jl(l.value.viewport, l.value.content);
      return P > 0 && P < 1;
    }), r = B(), i = B(0);
    function u(P, $) {
      if (v.value) {
        const b = t.viewport.value.scrollLeft + P.deltaY;
        t.viewport.value.scrollLeft = b, Po(b, $) && P.preventDefault();
      } else {
        const b = t.viewport.value.scrollTop + P.deltaY;
        t.viewport.value.scrollTop = b, Po(b, $) && P.preventDefault();
      }
    }
    function d(P, $) {
      v.value ? i.value = $.x : i.value = $.y;
    }
    function p(P) {
      i.value = 0;
    }
    function c(P) {
      l.value = P;
    }
    function f(P, $) {
      return Cc(
        P,
        i.value,
        l.value,
        $
      );
    }
    const v = A(
      () => e.isHorizontal.value
    );
    function y(P) {
      v.value ? t.viewport.value.scrollLeft = f(
        P,
        t.dir.value
      ) : t.viewport.value.scrollTop = f(P);
    }
    function h() {
      if (v.value) {
        if (t.viewport.value && r.value) {
          const P = t.viewport.value.scrollLeft, $ = xo(
            P,
            l.value,
            t.dir.value
          );
          r.value.style.transform = `translate3d(${$}px, 0, 0)`;
        }
      } else if (t.viewport.value && r.value) {
        const P = t.viewport.value.scrollTop, $ = xo(P, l.value);
        r.value.style.transform = `translate3d(0, ${$}px, 0)`;
      }
    }
    function x(P) {
      r.value = P;
    }
    return xc({
      sizes: l,
      hasThumb: s,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: p,
      handleSizeChange: c,
      onThumbPositionChange: h,
      onThumbChange: x,
      onDragScroll: y
    }), (P, $) => v.value ? (g(), w(_c, k({ key: 0 }, P.$attrs, { ref: o(n) }), {
      default: m(() => [
        C(P.$slots, "default")
      ]),
      _: 3
    }, 16)) : (g(), w(wc, k({ key: 1 }, P.$attrs, { ref: o(n) }), {
      default: m(() => [
        C(P.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ul = /* @__PURE__ */ _({
  __name: "ScrollAreaScrollbarAuto",
  props: {
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = Fe(), e = Ma(), { forwardRef: n } = R(), l = B(!1), s = bn(() => {
      if (t.viewport.value) {
        const r = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        l.value = e.isHorizontal.value ? r : i;
      }
    }, 10);
    return ae(() => s()), We(t.viewport, s), We(t.content, s), (r, i) => (g(), w(o(we), {
      present: r.forceMount || l.value
    }, {
      default: m(() => [
        j(oo, k(r.$attrs, {
          ref: o(n),
          "data-state": l.value ? "visible" : "hidden"
        }), {
          default: m(() => [
            C(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Pc = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: {
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = Fe(), { forwardRef: e } = R();
    let n;
    const l = B(!1);
    function s() {
      window.clearTimeout(n), l.value = !0;
    }
    function r() {
      n = window.setTimeout(() => {
        l.value = !1;
      }, t.scrollHideDelay.value);
    }
    return ae(() => {
      const i = t.scrollArea.value;
      i && (i.addEventListener("pointerenter", s), i.addEventListener("pointerleave", r));
    }), De(() => {
      const i = t.scrollArea.value;
      i && (window.clearTimeout(n), i.removeEventListener("pointerenter", s), i.removeEventListener("pointerleave", r));
    }), (i, u) => (g(), w(o(we), {
      present: i.forceMount || l.value
    }, {
      default: m(() => [
        j(Ul, k(i.$attrs, {
          ref: o(e),
          "data-state": l.value ? "visible" : "hidden"
        }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Sc = /* @__PURE__ */ _({
  __name: "ScrollAreaScrollbarScroll",
  props: {
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = Fe(), e = Ma(), { forwardRef: n } = R(), { state: l, dispatch: s } = sl("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    de((i) => {
      if (l.value === "idle") {
        const u = window.setTimeout(
          () => s("HIDE"),
          t.scrollHideDelay.value
        );
        i(() => {
          window.clearTimeout(u);
        });
      }
    });
    const r = bn(() => s("SCROLL_END"), 100);
    return de((i) => {
      const u = t.viewport.value, d = e.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (u) {
        let p = u[d];
        const c = () => {
          const f = u[d];
          p !== f && (s("SCROLL"), r()), p = f;
        };
        u.addEventListener("scroll", c), i(() => {
          u.removeEventListener("scroll", c);
        });
      }
    }), (i, u) => (g(), w(o(we), {
      present: i.forceMount || o(l) !== "hidden"
    }, {
      default: m(() => [
        j(oo, k(i.$attrs, { ref: o(n) }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Ma, Dc] = q("ScrollAreaScrollbar"), ah = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a, { forwardRef: e } = R(), n = Fe(), l = A(() => t.orientation === "horizontal");
    J(
      l,
      () => {
        l.value ? n.onScrollbarXEnabledChange(!0) : n.onScrollbarYEnabledChange(!0);
      },
      { immediate: !0 }
    ), De(() => {
      n.onScrollbarXEnabledChange(!1), n.onScrollbarYEnabledChange(!1);
    });
    const { orientation: s, forceMount: r, asChild: i, as: u } = te(t);
    return Dc({
      orientation: s,
      forceMount: r,
      isHorizontal: l,
      as: u,
      asChild: i
    }), (d, p) => o(n).type.value === "hover" ? (g(), w(Pc, k({ key: 0 }, d.$attrs, {
      ref: o(e),
      "force-mount": o(r)
    }), {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : o(n).type.value === "scroll" ? (g(), w(Sc, k({ key: 1 }, d.$attrs, {
      ref: o(e),
      "force-mount": o(r)
    }), {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : o(n).type.value === "auto" ? (g(), w(Ul, k({ key: 2 }, d.$attrs, {
      ref: o(e),
      "force-mount": o(r)
    }), {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : o(n).type.value === "always" ? (g(), w(oo, k({ key: 3 }, d.$attrs, {
      ref: o(e),
      "data-state": "visible"
    }), {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), nh = /* @__PURE__ */ _({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Fe(), n = ka();
    function l(f) {
      const y = f.target.getBoundingClientRect(), h = f.clientX - y.left, x = f.clientY - y.top;
      n.handleThumbDown(f, { x: h, y: x });
    }
    function s(f) {
      n.handleThumbUp(f);
    }
    const { forwardRef: r, currentElement: i } = R(), u = B(), d = A(() => e.viewport.value);
    function p() {
      if (!u.value) {
        const f = bc(
          d.value,
          n.onThumbPositionChange
        );
        u.value = f, n.onThumbPositionChange();
      }
    }
    const c = A(() => n.sizes.value);
    return Mr(c, () => {
      n.onThumbChange(i.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener("scroll", p));
    }), De(() => {
      var f;
      d.value.removeEventListener("scroll", p), (f = e.viewport.value) == null || f.removeEventListener("scroll", p);
    }), (f, v) => (g(), w(o(O), {
      ref: o(r),
      "data-state": o(n).hasThumb ? "visible" : "hidden",
      style: ge({
        width: "var(--radix-scroll-area-thumb-width)",
        height: "var(--radix-scroll-area-thumb-height)"
      }),
      "as-child": t.asChild,
      as: f.as,
      onPointerdown: l,
      onPointerup: s
    }, {
      default: m(() => [
        C(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "style", "as-child", "as"]));
  }
}), $c = /* @__PURE__ */ _({
  __name: "ScrollAreaCornerImpl",
  setup(a) {
    const t = Fe(), e = B(0), n = B(0), l = A(() => !!e.value && !!n.value);
    function s() {
      var u;
      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;
      t.onCornerHeightChange(i), n.value = i;
    }
    function r() {
      var u;
      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;
      t.onCornerWidthChange(i), e.value = i;
    }
    return We(t.scrollbarX.value, s), We(t.scrollbarY.value, r), J(() => t.scrollbarX.value, s), J(() => t.scrollbarY.value, r), (i, u) => {
      var d;
      return l.value ? (g(), w(o(O), k({
        key: 0,
        style: {
          width: `${e.value}px`,
          height: `${n.value}px`,
          position: "absolute",
          right: o(t).dir.value === "ltr" ? 0 : void 0,
          left: o(t).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (d = i.$parent) == null ? void 0 : d.$props), {
        default: m(() => [
          C(i.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : re("", !0);
    };
  }
}), oh = /* @__PURE__ */ _({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e } = R(), n = Fe(), l = A(
      () => !!n.scrollbarX.value && !!n.scrollbarY.value
    ), s = A(
      () => n.type.value !== "scroll" && l.value
    );
    return (r, i) => s.value ? (g(), w($c, k({ key: 0 }, t, { ref: o(e) }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), Ec = ["default-value"], Bc = /* @__PURE__ */ _({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(a) {
    const t = a, { value: e } = te(t);
    Hr(e);
    const n = B();
    return (l, s) => (g(), w(o(Vt), { "as-child": "" }, {
      default: m(() => [
        xa(He("select", k({
          ref_key: "selectElement",
          ref: n
        }, t, {
          "onUpdate:modelValue": s[0] || (s[0] = (r) => yt(e) ? e.value = r : null),
          "default-value": o(e)
        }), [
          C(l.$slots, "default")
        ], 16, Ec), [
          [Ns, o(e)]
        ])
      ]),
      _: 3
    }));
  }
}), Rc = {
  key: 0,
  value: ""
}, [pt, ql] = q("SelectRoot"), [Ac, Tc] = q("SelectRoot"), lh = /* @__PURE__ */ _({
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: { default: "" },
    modelValue: { default: void 0 },
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), s = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), r = B(), i = B(), u = B({
      x: 0,
      y: 0
    }), d = B(!1), { required: p, disabled: c, dir: f } = te(e), v = Pe(f);
    ql({
      triggerElement: r,
      onTriggerChange: (P) => {
        r.value = P;
      },
      valueElement: i,
      onValueElementChange: (P) => {
        i.value = P;
      },
      valueElementHasChildren: d,
      onValueElementHasChildrenChange: (P) => {
        d.value = P;
      },
      contentId: "",
      modelValue: l,
      onValueChange: (P) => {
        l.value = P;
      },
      open: s,
      required: p,
      onOpenChange: (P) => {
        s.value = P;
      },
      dir: v,
      triggerPointerDownPosRef: u,
      disabled: c
    });
    const y = gt(r), h = B(/* @__PURE__ */ new Set()), x = A(() => Array.from(h.value).map((P) => {
      var $;
      return ($ = P.props) == null ? void 0 : $.value;
    }).join(";"));
    return Tc({
      onNativeOptionAdd: (P) => {
        h.value.add(P);
      },
      onNativeOptionRemove: (P) => {
        h.value.delete(P);
      }
    }), (P, $) => (g(), w(o(_t), null, {
      default: m(() => [
        C(P.$slots, "default"),
        o(y) ? (g(), w(Bc, k({ key: x.value }, P.$attrs, {
          "aria-hidden": "",
          tabindex: "-1",
          required: o(p),
          name: P.name,
          autocomplete: P.autocomplete,
          disabled: o(c),
          value: o(l),
          onChange: $[0] || ($[0] = (b) => l.value = b.target.value)
        }), {
          default: m(() => [
            o(l) === void 0 ? (g(), fe("option", Rc)) : re("", !0),
            (g(!0), fe(xe, null, mn(Array.from(h.value), (b) => (g(), w(Ge(b), k(b.props, {
              key: b.key ?? ""
            }), null, 16))), 128))
          ]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : re("", !0)
      ]),
      _: 3
    }));
  }
}), Ic = [" ", "Enter", "ArrowUp", "ArrowDown"], Oc = [" ", "Enter"], je = 10;
function Yl(a) {
  return a === "" || a === void 0;
}
const sh = /* @__PURE__ */ _({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = pt(), n = A(() => {
      var f;
      return ((f = e.disabled) == null ? void 0 : f.value) || t.disabled;
    }), { forwardRef: l, currentElement: s } = R();
    e.contentId || (e.contentId = ve(void 0, "radix-vue-select-content")), ae(() => {
      e.triggerElement = s;
    });
    const { injectCollection: r } = Te(), i = r(), { search: u, handleTypeaheadSearch: d, resetTypeahead: p } = Sn(i);
    function c() {
      n.value || (e.onOpenChange(!0), p());
    }
    return (f, v) => (g(), w(o(wt), { "as-child": "" }, {
      default: m(() => {
        var y, h, x, P;
        return [
          j(o(O), {
            ref: o(l),
            role: "combobox",
            type: f.as === "button" ? "button" : void 0,
            "aria-controls": o(e).contentId,
            "aria-expanded": o(e).open.value || !1,
            "aria-required": (y = o(e).required) == null ? void 0 : y.value,
            "aria-autocomplete": "none",
            disabled: n.value,
            dir: (h = o(e)) == null ? void 0 : h.dir.value,
            "data-state": (x = o(e)) != null && x.open.value ? "open" : "closed",
            "data-disabled": n.value ? "" : void 0,
            "data-placeholder": o(Yl)((P = o(e).modelValue) == null ? void 0 : P.value) ? "" : void 0,
            "as-child": f.asChild,
            as: f.as,
            onClick: v[0] || (v[0] = ($) => {
              var b;
              (b = $ == null ? void 0 : $.currentTarget) == null || b.focus();
            }),
            onPointerdown: v[1] || (v[1] = ($) => {
              const b = $.target;
              b.hasPointerCapture($.pointerId) && b.releasePointerCapture($.pointerId), $.button === 0 && $.ctrlKey === !1 && (c(), o(e).triggerPointerDownPosRef.value = {
                x: Math.round($.pageX),
                y: Math.round($.pageY)
              }, $.preventDefault());
            }),
            onPointerup: v[2] || (v[2] = ye(() => {
            }, ["prevent"])),
            onKeydown: v[3] || (v[3] = ($) => {
              const b = o(u) !== "";
              !($.ctrlKey || $.altKey || $.metaKey) && $.key.length === 1 && b && $.key === " " || (o(d)($.key), o(Ic).includes($.key) && (c(), $.preventDefault()));
            })
          }, {
            default: m(() => [
              C(f.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }));
  }
}), rh = /* @__PURE__ */ _({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [lo, kc] = q("SelectItemAlignedPosition"), Mc = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(a, { emit: t }) {
    const e = a, n = t, { injectCollection: l } = Te(), s = pt(), r = ft(), i = l(), u = B(!1), d = B(!0), p = B(), { forwardRef: c, currentElement: f } = R(), { viewport: v, selectedItem: y, selectedItemText: h, focusSelectedItem: x } = r;
    function P() {
      if (s.triggerElement.value && s.valueElement.value && p.value && f.value && (v != null && v.value) && (y != null && y.value) && (h != null && h.value)) {
        const S = s.triggerElement.value.getBoundingClientRect(), D = f.value.getBoundingClientRect(), E = s.valueElement.value.getBoundingClientRect(), T = h.value.getBoundingClientRect();
        if (s.dir.value !== "rtl") {
          const ie = T.left - D.left, Ce = E.left - ie, Ie = S.left - Ce, Oe = S.width + Ie, _e = Math.max(Oe, D.width), Ye = window.innerWidth - je, Ht = ho(Ce, je, Ye - _e);
          p.value.style.minWidth = `${Oe}px`, p.value.style.left = `${Ht}px`;
        } else {
          const ie = D.right - T.right, Ce = window.innerWidth - E.right - ie, Ie = window.innerWidth - S.right - Ce, Oe = S.width + Ie, _e = Math.max(Oe, D.width), Ye = window.innerWidth - je, Ht = ho(
            Ce,
            je,
            Ye - _e
          );
          p.value.style.minWidth = `${Oe}px`, p.value.style.right = `${Ht}px`;
        }
        const M = i.value, V = window.innerHeight - je * 2, I = v.value.scrollHeight, L = window.getComputedStyle(f.value), G = Number.parseInt(
          L.borderTopWidth,
          10
        ), X = Number.parseInt(L.paddingTop, 10), H = Number.parseInt(
          L.borderBottomWidth,
          10
        ), z = Number.parseInt(
          L.paddingBottom,
          10
        ), F = G + X + I + z + H, Y = Math.min(
          y.value.offsetHeight * 5,
          F
        ), U = window.getComputedStyle(v.value), Z = Number.parseInt(U.paddingTop, 10), oe = Number.parseInt(
          U.paddingBottom,
          10
        ), ee = S.top + S.height / 2 - je, W = V - ee, ce = y.value.offsetHeight / 2, pe = y.value.offsetTop + ce, ue = G + X + pe, Ee = F - ue;
        if (ue <= ee) {
          const ie = y.value === M[M.length - 1];
          p.value.style.bottom = "0px";
          const Ce = f.value.clientHeight - v.value.offsetTop - v.value.offsetHeight, Ie = Math.max(
            W,
            ce + (ie ? oe : 0) + Ce + H
          ), Oe = ue + Ie;
          p.value.style.height = `${Oe}px`;
        } else {
          const ie = y.value === M[0];
          p.value.style.top = "0px";
          const Ie = Math.max(
            ee,
            G + v.value.offsetTop + (ie ? Z : 0) + ce
          ) + Ee;
          p.value.style.height = `${Ie}px`, v.value.scrollTop = ue - ee + v.value.offsetTop;
        }
        p.value.style.margin = `${je}px 0`, p.value.style.minHeight = `${Y}px`, p.value.style.maxHeight = `${V}px`, n("placed"), requestAnimationFrame(() => u.value = !0);
      }
    }
    const $ = B("");
    ae(async () => {
      await ne(), P(), f.value && ($.value = window.getComputedStyle(f.value).zIndex);
    });
    function b(S) {
      S && d.value === !0 && (P(), x == null || x(), d.value = !1);
    }
    return kc({
      contentWrapper: p,
      shouldExpandOnScrollRef: u,
      onScrollButtonChange: b
    }), (S, D) => (g(), fe("div", {
      ref_key: "contentWrapperElement",
      ref: p,
      style: ge({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: $.value
      })
    }, [
      j(o(O), k({
        ref: o(c),
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...S.$attrs, ...e }), {
        default: m(() => [
          C(S.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 4));
  }
}), Vc = /* @__PURE__ */ _({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: je },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const e = bt(a);
    return (n, l) => (g(), w(o(ht), k(o(e), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-select-content-available-width": "var(--radix-popper-available-width)",
      "--radix-select-content-available-height": "var(--radix-popper-available-height)",
      "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Kt = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [ft, Fc] = q("SelectContent"), Lc = /* @__PURE__ */ _({
  __name: "SelectContentImpl",
  props: {
    position: { default: "item-aligned" },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = pt();
    Pn(), oa(!0);
    const { createCollection: s } = Te(), r = B();
    la(r);
    const i = s(r), { search: u, handleTypeaheadSearch: d } = Sn(i), p = B(), c = B(), f = B(), v = B(!1), y = B(!1);
    function h() {
      c.value && r.value && ln([c.value, r.value]);
    }
    J(v, () => {
      h();
    });
    const { onOpenChange: x, triggerPointerDownPosRef: P } = l;
    de((D) => {
      if (!r.value)
        return;
      let E = { x: 0, y: 0 };
      const T = (V) => {
        var I, L;
        E = {
          x: Math.abs(
            Math.round(V.pageX) - (((I = P.value) == null ? void 0 : I.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(V.pageY) - (((L = P.value) == null ? void 0 : L.y) ?? 0)
          )
        };
      }, M = (V) => {
        var I;
        E.x <= 10 && E.y <= 10 ? V.preventDefault() : (I = r.value) != null && I.contains(V.target) || x(!1), document.removeEventListener("pointermove", T), P.value = null;
      };
      P.value !== null && (document.addEventListener("pointermove", T), document.addEventListener("pointerup", M, {
        capture: !0,
        once: !0
      })), D(() => {
        document.removeEventListener("pointermove", T), document.removeEventListener("pointerup", M, {
          capture: !0
        });
      });
    });
    function $(D) {
      const E = D.ctrlKey || D.altKey || D.metaKey;
      if (D.key === "Tab" && D.preventDefault(), !E && D.key.length === 1 && d(D.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(D.key)) {
        let T = i.value;
        if (["ArrowUp", "End"].includes(D.key) && (T = T.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(D.key)) {
          const M = D.target, V = T.indexOf(M);
          T = T.slice(V + 1);
        }
        setTimeout(() => ln(T)), D.preventDefault();
      }
    }
    const b = A(() => e.position === "popper" ? e : {}), S = bt(b.value);
    return Fc({
      content: r,
      viewport: p,
      onViewportChange: (D) => {
        p.value = D;
      },
      itemRefCallback: (D, E, T) => {
        var I, L;
        const M = !y.value && !T;
        (((I = l.modelValue) == null ? void 0 : I.value) !== void 0 && ((L = l.modelValue) == null ? void 0 : L.value) === E || M) && (c.value = D, M && (y.value = !0));
      },
      selectedItem: c,
      selectedItemText: f,
      onItemLeave: () => {
        var D;
        (D = r.value) == null || D.focus();
      },
      itemTextRefCallback: (D, E, T) => {
        var I, L;
        const M = !y.value && !T;
        (((I = l.modelValue) == null ? void 0 : I.value) !== void 0 && ((L = l.modelValue) == null ? void 0 : L.value) === E || M) && (f.value = D);
      },
      focusSelectedItem: h,
      position: e.position,
      isPositioned: v,
      searchRef: u
    }), (D, E) => (g(), w(o(Ba), {
      "as-child": "",
      onMountAutoFocus: E[6] || (E[6] = ye(() => {
      }, ["prevent"])),
      onUnmountAutoFocus: E[7] || (E[7] = (T) => {
        var M;
        n("closeAutoFocus", T), !T.defaultPrevented && ((M = o(l).triggerElement.value) == null || M.focus({ preventScroll: !0 }), T.preventDefault());
      })
    }, {
      default: m(() => [
        j(o(dt), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: E[2] || (E[2] = ye(() => {
          }, ["prevent"])),
          onDismiss: E[3] || (E[3] = (T) => o(l).onOpenChange(!1)),
          onEscapeKeyDown: E[4] || (E[4] = (T) => n("escapeKeyDown", T)),
          onPointerDownOutside: E[5] || (E[5] = (T) => n("pointerDownOutside", T))
        }, {
          default: m(() => [
            (g(), w(Ge(
              D.position === "popper" ? Vc : Mc
            ), k({ ...D.$attrs, ...o(S) }, {
              id: o(l).contentId,
              ref: (T) => {
                r.value = o(Ae)(T);
              },
              role: "listbox",
              "data-state": o(l).open.value ? "open" : "closed",
              dir: o(l).dir.value,
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none"
              },
              onContextmenu: E[0] || (E[0] = ye(() => {
              }, ["prevent"])),
              onPlaced: E[1] || (E[1] = (T) => v.value = !0),
              onKeydown: $
            }), {
              default: m(() => [
                C(D.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "dir", "onKeydown"]))
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), Nc = /* @__PURE__ */ _({
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(a) {
    return ql(a.context), (e, n) => C(e.$slots, "default");
  }
}), zc = { key: 1 }, ih = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(a, { emit: t }) {
    const e = a, l = be(e, t), s = pt(), r = B();
    ae(() => {
      r.value = new DocumentFragment();
    });
    const i = B(), u = A(() => e.forceMount || s.open.value);
    return (d, p) => {
      var c;
      return u.value ? (g(), w(o(we), {
        key: 0,
        ref_key: "presenceRef",
        ref: i,
        present: !0
      }, {
        default: m(() => [
          j(Lc, N(K({ ...o(l), ...d.$attrs })), {
            default: m(() => [
              C(d.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 512)) : !((c = i.value) != null && c.present) && r.value ? (g(), fe("div", zc, [
        (g(), w(At, { to: r.value }, [
          j(Nc, { context: o(s) }, {
            default: m(() => [
              C(d.$slots, "default")
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"]))
      ])) : re("", !0);
    };
  }
}), uh = /* @__PURE__ */ _({
  __name: "SelectArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a, e = pt(), n = ft();
    return (l, s) => o(e).open.value && o(n).position === "popper" ? (g(), w(o(Mt), N(k({ key: 0 }, t)), {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), dh = /* @__PURE__ */ _({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(O), k({ "aria-hidden": "" }, t), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Xl, Kc] = q("SelectItem"), ch = /* @__PURE__ */ _({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { disabled: e } = te(t), n = pt(), l = ft(Kt), { forwardRef: s, currentElement: r } = R(), i = A(() => {
      var h;
      return ((h = n.modelValue) == null ? void 0 : h.value) === t.value;
    }), u = B(!1), d = B(t.textValue ?? ""), p = ve(void 0, "radix-vue-select-item-text");
    async function c(h) {
      await ne(), !(h != null && h.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(!1)));
    }
    async function f(h) {
      var x;
      await ne(), !h.defaultPrevented && (e.value ? (x = l.onItemLeave) == null || x.call(l) : h.currentTarget.focus({ preventScroll: !0 }));
    }
    async function v(h) {
      var x;
      await ne(), !h.defaultPrevented && h.currentTarget === document.activeElement && ((x = l.onItemLeave) == null || x.call(l));
    }
    async function y(h) {
      var P;
      await ne(), !(h.defaultPrevented || ((P = l.searchRef) == null ? void 0 : P.value) !== "" && h.key === " ") && (Oc.includes(h.key) && c(), h.key === " " && h.preventDefault());
    }
    if (t.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return ae(() => {
      r.value && l.itemRefCallback(
        r.value,
        t.value,
        t.disabled
      );
    }), Kc({
      value: t.value,
      disabled: e,
      textId: p,
      isSelected: i,
      onItemTextChange: (h) => {
        d.value = ((d.value || (h == null ? void 0 : h.textContent)) ?? "").trim();
      }
    }), (h, x) => (g(), w(o(O), {
      ref: o(s),
      role: "option",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": o(p),
      "data-highlighted": u.value ? "" : void 0,
      "aria-selected": i.value && u.value,
      "data-state": i.value ? "checked" : "unchecked",
      "aria-disabled": o(e) || void 0,
      "data-disabled": o(e) ? "" : void 0,
      tabindex: o(e) ? void 0 : -1,
      as: h.as,
      "as-child": h.asChild,
      onFocus: x[0] || (x[0] = (P) => u.value = !0),
      onBlur: x[1] || (x[1] = (P) => u.value = !1),
      onPointerup: c,
      onTouchend: x[2] || (x[2] = ye(() => {
      }, ["prevent", "stop"])),
      onPointermove: f,
      onPointerleave: v,
      onKeydown: y
    }, {
      default: m(() => [
        C(h.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]));
  }
}), ph = /* @__PURE__ */ _({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a, e = Xl();
    return (n, l) => o(e).isSelected.value ? (g(), w(o(O), k({
      key: 0,
      "aria-hidden": ""
    }, t), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), [Hc, Wc] = q("SelectGroup"), fh = /* @__PURE__ */ _({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = ve(void 0, "radix-vue-select-group");
    return Wc({ id: e }), (n, l) => (g(), w(o(O), k({ role: "group" }, t, { "aria-labelledby": o(e) }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), vh = /* @__PURE__ */ _({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(a) {
    const t = a, e = Hc({ id: "" });
    return (n, l) => (g(), w(o(O), k(t, {
      id: o(e).id
    }), {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), mh = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a, e = pt(), n = ft(Kt), l = Ac(), s = Xl(), { forwardRef: r, currentElement: i } = R(), u = A(() => {
      var d;
      return nt("option", {
        key: s.value,
        value: s.value,
        disabled: s.disabled.value,
        innerHTML: (d = i.value) == null ? void 0 : d.textContent
      });
    });
    return ae(() => {
      i.value && (s.onItemTextChange(i.value), n.itemTextRefCallback(
        i.value,
        s.value,
        s.disabled.value
      ), l.onNativeOptionAdd(u.value));
    }), fn(() => {
      l.onNativeOptionRemove(u.value);
    }), (d, p) => (g(), fe(xe, null, [
      j(o(O), k({
        id: o(s).textId,
        ref: o(r)
      }, { ...t, ...d.$attrs }), {
        default: m(() => [
          C(d.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]),
      o(s).isSelected.value && o(e).valueElement.value && !o(e).valueElementHasChildren.value ? (g(), w(At, {
        key: 0,
        to: o(e).valueElement.value
      }, [
        C(d.$slots, "default")
      ], 8, ["to"])) : re("", !0)
    ], 64));
  }
}), hh = /* @__PURE__ */ _({
  __name: "SelectViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = ft(Kt), n = e.position === "item-aligned" ? lo() : void 0, { forwardRef: l, currentElement: s } = R();
    ae(() => {
      e == null || e.onViewportChange(s.value);
    });
    const r = B(0);
    function i(u) {
      const d = u.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: c } = n ?? {};
      if (p != null && p.value && (c != null && c.value)) {
        const f = Math.abs(r.value - d.scrollTop);
        if (f > 0) {
          const v = window.innerHeight - je * 2, y = Number.parseFloat(
            c.value.style.minHeight
          ), h = Number.parseFloat(c.value.style.height), x = Math.max(y, h);
          if (x < v) {
            const P = x + f, $ = Math.min(v, P), b = P - $;
            c.value.style.height = `${$}px`, c.value.style.bottom === "0px" && (d.scrollTop = b > 0 ? b : 0, c.value.style.justifyContent = "flex-end");
          }
        }
      }
      r.value = d.scrollTop;
    }
    return (u, d) => (g(), fe(xe, null, [
      j(o(O), k({
        ref: o(l),
        "data-radix-select-viewport": "",
        role: "presentation"
      }, { ...u.$attrs, ...t }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        },
        onScroll: i
      }), {
        default: m(() => [
          C(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"]),
      j(o(O), {
        as: "style",
        nonce: u.nonce
      }, {
        default: m(() => [
          me(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
}), Zl = /* @__PURE__ */ _({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(a, { emit: t }) {
    const e = t, { injectCollection: n } = Te(), l = n(), s = ft(Kt), r = B(null);
    function i() {
      r.value !== null && (window.clearInterval(r.value), r.value = null);
    }
    de(() => {
      const p = l.value.find(
        (c) => c === document.activeElement
      );
      p == null || p.scrollIntoView({ block: "nearest" });
    });
    function u() {
      r.value === null && (r.value = window.setInterval(() => {
        e("autoScroll");
      }, 50));
    }
    function d() {
      var p;
      (p = s.onItemLeave) == null || p.call(s), r.value === null && (r.value = window.setInterval(() => {
        e("autoScroll");
      }, 50));
    }
    return fn(() => i()), (p, c) => {
      var f;
      return g(), w(o(O), k({
        "aria-hidden": "",
        style: {
          flexShrink: 0
        }
      }, (f = p.$parent) == null ? void 0 : f.$props, {
        onPointerdown: u,
        onPointermove: d,
        onPointerleave: c[0] || (c[0] = () => {
          i();
        })
      }), {
        default: m(() => [
          C(p.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
}), yh = /* @__PURE__ */ _({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = ft(Kt), e = t.position === "item-aligned" ? lo() : void 0, { forwardRef: n, currentElement: l } = R(), s = B(!1);
    return de((r) => {
      var i, u;
      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          s.value = p.scrollTop > 0;
        };
        const p = t.viewport.value;
        d(), p.addEventListener("scroll", d), r(() => p.removeEventListener("scroll", d));
      }
    }), J(l, () => {
      l.value && (e == null || e.onScrollButtonChange(l.value));
    }), (r, i) => s.value ? (g(), w(Zl, {
      key: 0,
      ref: o(n),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = o(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 512)) : re("", !0);
  }
}), gh = /* @__PURE__ */ _({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = ft(Kt), e = t.position === "item-aligned" ? lo() : void 0, { forwardRef: n, currentElement: l } = R(), s = B(!1);
    return de((r) => {
      var i, u;
      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          const c = p.scrollHeight - p.clientHeight;
          s.value = Math.ceil(p.scrollTop) < c;
        };
        const p = t.viewport.value;
        d(), p.addEventListener("scroll", d), r(() => p.removeEventListener("scroll", d));
      }
    }), J(l, () => {
      l.value && (e == null || e.onScrollButtonChange(l.value));
    }), (r, i) => s.value ? (g(), w(Zl, {
      key: 0,
      ref: o(n),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = o(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 512)) : re("", !0);
  }
}), bh = /* @__PURE__ */ _({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const { forwardRef: t, currentElement: e } = R(), n = pt(), l = Ko();
    return zo(() => {
      var r;
      const s = !!$a((r = l == null ? void 0 : l.default) == null ? void 0 : r.call(l)).length;
      n.onValueElementHasChildrenChange(s);
    }), ae(() => {
      n.valueElement = e;
    }), (s, r) => (g(), w(o(O), {
      ref: o(t),
      as: s.as,
      "as-child": s.asChild,
      style: { pointerEvents: "none" }
    }, {
      default: m(() => {
        var i;
        return [
          o(Yl)((i = o(n).modelValue) == null ? void 0 : i.value) ? (g(), fe(xe, { key: 0 }, [
            me(ke(s.placeholder), 1)
          ], 64)) : C(s.$slots, "default", { key: 1 })
        ];
      }),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Ch = /* @__PURE__ */ _({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    return (t, e) => (g(), w(o(O), {
      "aria-hidden": "",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: m(() => [
        C(t.$slots, "default", {}, () => [
          me("▼")
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Jl = /* @__PURE__ */ _({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = ["horizontal", "vertical"];
    function n(i) {
      return e.includes(i);
    }
    const l = A(
      () => n(t.orientation) ? t.orientation : "horizontal"
    ), s = A(
      () => l.value === "vertical" ? t.orientation : void 0
    ), r = A(
      () => t.decorative ? { role: "none" } : { "aria-orientation": s.value, role: "separator" }
    );
    return (i, u) => (g(), w(o(O), k({
      as: i.as,
      "as-child": i.asChild,
      "data-orientation": l.value
    }, r.value), {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "data-orientation"]));
  }
}), _h = /* @__PURE__ */ _({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(Jl, N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function Ql(a, [t, e]) {
  return Math.min(e, Math.max(t, a));
}
function jc(a = [], t, e) {
  const n = [...a];
  return n[e] = t, n.sort((l, s) => l - s);
}
function es(a, t, e) {
  const s = 100 / (e - t) * (a - t);
  return Ql(s, [0, 100]);
}
function Gc(a, t) {
  return t > 2 ? `Value ${a + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][a] : void 0;
}
function Uc(a, t) {
  if (a.length === 1)
    return 0;
  const e = a.map((l) => Math.abs(l - t)), n = Math.min(...e);
  return e.indexOf(n);
}
function qc(a, t, e) {
  const n = a / 2, s = so([0, 50], [0, n]);
  return (n - s(t) * e) * e;
}
function Yc(a) {
  return a.slice(0, -1).map((t, e) => a[e + 1] - t);
}
function Xc(a, t) {
  if (t > 0) {
    const e = Yc(a);
    return Math.min(...e) >= t;
  }
  return !0;
}
function so(a, t) {
  return (e) => {
    if (a[0] === a[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (a[1] - a[0]);
    return t[0] + n * (e - a[0]);
  };
}
function Zc(a) {
  return (String(a).split(".")[1] || "").length;
}
function Jc(a, t) {
  const e = 10 ** t;
  return Math.round(a * e) / e;
}
const ts = ["PageUp", "PageDown"], as = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], ns = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, [os, ls] = q(["SliderVertical", "SliderHorizontal"]), ss = /* @__PURE__ */ _({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = Va();
    return (s, r) => (g(), w(o(O), k({ "data-slider-impl": "" }, e, {
      onKeydown: r[0] || (r[0] = (i) => {
        i.key === "Home" ? (n("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (n("endKeyDown", i), i.preventDefault()) : o(ts).concat(o(as)).includes(i.key) && (n("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: r[1] || (r[1] = (i) => {
        const u = i.target;
        u.setPointerCapture(i.pointerId), i.preventDefault(), o(l).thumbElements.value.includes(u) ? u.focus() : n("slideStart", i);
      }),
      onPointermove: r[2] || (r[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && n("slideMove", i);
      }),
      onPointerup: r[3] || (r[3] = (i) => {
        const u = i.target;
        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), n("slideEnd", i));
      })
    }), {
      default: m(() => [
        C(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qc = /* @__PURE__ */ _({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(a, { emit: t }) {
    const e = a, n = t, { max: l, min: s, dir: r, inverted: i } = te(e), { forwardRef: u, currentElement: d } = R(), p = B(), c = A(() => (r == null ? void 0 : r.value) === "ltr" && !i.value || (r == null ? void 0 : r.value) !== "ltr" && i.value);
    function f(v) {
      const y = p.value || d.value.getBoundingClientRect(), h = [0, y.width], x = c.value ? [s.value, l.value] : [l.value, s.value], P = so(h, x);
      return p.value = y, P(v - y.left);
    }
    return ls({
      startEdge: c.value ? "left" : "right",
      endEdge: c.value ? "right" : "left",
      direction: c.value ? 1 : -1,
      size: "width"
    }), (v, y) => (g(), w(ss, {
      ref: o(u),
      dir: o(r),
      "data-orientation": "horizontal",
      style: ge({
        "--radix-slider-thumb-transform": "translateX(-50%)"
      }),
      onSlideStart: y[0] || (y[0] = (h) => {
        const x = f(h.clientX);
        n("slideStart", x);
      }),
      onSlideMove: y[1] || (y[1] = (h) => {
        const x = f(h.clientX);
        n("slideMove", x);
      }),
      onSlideEnd: y[2] || (y[2] = () => {
        p.value = void 0, n("slideEnd");
      }),
      onStepKeyDown: y[3] || (y[3] = (h) => {
        const x = c.value ? "from-left" : "from-right", P = o(ns)[x].includes(h.key);
        n("stepKeyDown", h, P ? -1 : 1);
      }),
      onEndKeyDown: y[4] || (y[4] = (h) => n("endKeyDown", h)),
      onHomeKeyDown: y[5] || (y[5] = (h) => n("homeKeyDown", h))
    }, {
      default: m(() => [
        C(v.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), ep = /* @__PURE__ */ _({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(a, { emit: t }) {
    const e = a, n = t, { max: l, min: s, inverted: r } = te(e), { forwardRef: i, currentElement: u } = R(), d = B(), p = A(() => !r.value);
    function c(f) {
      const v = d.value || u.value.getBoundingClientRect(), y = [0, v.height], h = p.value ? [l.value, s.value] : [s.value, l.value], x = so(y, h);
      return d.value = v, x(f - v.top);
    }
    return ls({
      startEdge: p.value ? "bottom" : "top",
      endEdge: p.value ? "top" : "bottom",
      size: "height",
      direction: p.value ? 1 : -1
    }), (f, v) => (g(), w(ss, {
      ref: o(i),
      "data-orientation": "vertical",
      style: ge({
        "--radix-slider-thumb-transform": "translateY(50%)"
      }),
      onSlideStart: v[0] || (v[0] = (y) => {
        const h = c(y.clientY);
        n("slideStart", h);
      }),
      onSlideMove: v[1] || (v[1] = (y) => {
        const h = c(y.clientY);
        n("slideMove", h);
      }),
      onSlideEnd: v[2] || (v[2] = () => {
        d.value = void 0, n("slideEnd");
      }),
      onStepKeyDown: v[3] || (v[3] = (y) => {
        const h = p.value ? "from-bottom" : "from-top", x = o(ns)[h].includes(y.key);
        n("stepKeyDown", y, x ? -1 : 1);
      }),
      onEndKeyDown: v[4] || (v[4] = (y) => n("endKeyDown", y)),
      onHomeKeyDown: v[5] || (v[5] = (y) => n("homeKeyDown", y))
    }, {
      default: m(() => [
        C(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), tp = ["value", "name", "disabled", "step"], [Va, ap] = q("SliderRoot"), wh = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    name: {},
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: !1 },
    orientation: { default: "horizontal" },
    dir: {},
    inverted: { type: Boolean, default: !1 },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(a, { emit: t }) {
    const e = a, n = t, { min: l, max: s, step: r, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: p } = te(e), c = Pe(p), { forwardRef: f, currentElement: v } = R(), y = gt(v);
    In();
    const h = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), x = B(0), P = B(h.value);
    function $(T) {
      const M = Uc(h.value, T);
      D(T, M);
    }
    function b(T) {
      D(T, x.value);
    }
    function S() {
      const T = P.value[x.value];
      h.value[x.value] !== T && n("valueCommit", zs(h.value));
    }
    function D(T, M, { commit: V } = { commit: !1 }) {
      var H;
      const I = Zc(r.value), L = Jc(Math.round((T - l.value) / r.value) * r.value + l.value, I), G = Ql(L, [l.value, s.value]), X = jc(h.value, G, M);
      if (Xc(X, i.value * r.value)) {
        x.value = X.indexOf(G);
        const z = String(X) !== String(h.value);
        z && V && n("valueCommit", X), z && ((H = E.value[x.value]) == null || H.focus(), h.value = X);
      }
    }
    const E = B([]);
    return ap({
      modelValue: h,
      valueIndexToChangeRef: x,
      thumbElements: E,
      orientation: u,
      min: l,
      max: s,
      disabled: d
    }), (T, M) => (g(), fe(xe, null, [
      j(o(On), null, {
        default: m(() => [
          (g(), w(Ge(o(u) === "horizontal" ? Qc : ep), k(T.$attrs, {
            ref: o(f),
            "as-child": T.asChild,
            as: T.as,
            min: o(l),
            max: o(s),
            dir: o(c),
            inverted: T.inverted,
            "aria-disabled": o(d),
            "data-disabled": o(d) ? "" : void 0,
            onPointerdown: M[0] || (M[0] = () => {
              o(d) || (P.value = o(h));
            }),
            onSlideStart: M[1] || (M[1] = (V) => !o(d) && $(V)),
            onSlideMove: M[2] || (M[2] = (V) => !o(d) && b(V)),
            onSlideEnd: M[3] || (M[3] = (V) => !o(d) && S()),
            onHomeKeyDown: M[4] || (M[4] = (V) => !o(d) && D(o(l), 0, { commit: !0 })),
            onEndKeyDown: M[5] || (M[5] = (V) => !o(d) && D(o(s), o(h).length - 1, { commit: !0 })),
            onStepKeyDown: M[6] || (M[6] = (V, I) => {
              if (!o(d)) {
                const X = o(ts).includes(V.key) || V.shiftKey && o(as).includes(V.key) ? 10 : 1, H = x.value, z = o(h)[H], F = o(r) * X * I;
                D(z + F, H, { commit: !0 });
              }
            })
          }), {
            default: m(() => [
              C(T.$slots, "default", { modelValue: o(h) })
            ]),
            _: 3
          }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"]))
        ]),
        _: 3
      }),
      o(y) ? (g(!0), fe(xe, { key: 0 }, mn(o(h), (V, I) => (g(), fe("input", {
        key: I,
        value: V,
        type: "number",
        style: { display: "none" },
        name: T.name ? T.name + (o(h).length > 1 ? "[]" : "") : void 0,
        disabled: o(d),
        step: o(r)
      }, null, 8, tp))), 128)) : re("", !0)
    ], 64));
  }
}), np = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Va(), n = os(), { forwardRef: l, currentElement: s } = R(), r = A(() => {
      var v, y;
      return (y = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : y[t.index];
    }), i = A(() => r.value === void 0 ? 0 : es(r.value, e.min.value ?? 0, e.max.value ?? 100)), u = A(() => {
      var v, y;
      return Gc(t.index, ((y = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : y.length) ?? 0);
    }), d = ll(s), p = A(() => d[n.size].value), c = A(() => p.value ? qc(p.value, i.value, n.direction) : 0), f = Da();
    return ae(() => {
      e.thumbElements.value.push(s.value);
    }), De(() => {
      const v = e.thumbElements.value.findIndex((y) => y === s.value) ?? -1;
      e.thumbElements.value.splice(v, 1);
    }), (v, y) => (g(), w(o(kn), null, {
      default: m(() => [
        j(o(O), k(v.$attrs, {
          ref: o(l),
          role: "slider",
          "data-radix-vue-collection-item": "",
          tabindex: o(e).disabled.value ? void 0 : 0,
          "aria-label": v.$attrs["aria-label"] || u.value,
          "data-disabled": o(e).disabled.value ? "" : void 0,
          "data-orientation": o(e).orientation.value,
          "aria-valuenow": r.value,
          "aria-valuemin": o(e).min.value,
          "aria-valuemax": o(e).max.value,
          "aria-orientation": o(e).orientation.value,
          "as-child": v.asChild,
          as: v.as,
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [o(n).startEdge]: `calc(${i.value}% + ${c.value}px)`,
            /**
             * There will be no value on initial render while we work out the index so we hide thumbs
             * without a value, otherwise SSR will render them in the wrong position before they
             * snap into the correct position during hydration which would be visually jarring for
             * slower connections.
             */
            display: !o(f) && r.value === void 0 ? "none" : void 0
          },
          onFocus: y[0] || (y[0] = () => {
            o(e).valueIndexToChangeRef.value = v.index;
          })
        }), {
          default: m(() => [
            C(v.$slots, "default")
          ]),
          _: 3
        }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"])
      ]),
      _: 3
    }));
  }
}), xh = /* @__PURE__ */ _({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { getItems: e } = Cl(), { forwardRef: n, currentElement: l } = R(), s = A(() => l.value ? e().findIndex((r) => r.ref === l.value) : -1);
    return (r, i) => (g(), w(np, k({ ref: o(n) }, t, { index: s.value }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["index"]));
  }
}), Ph = /* @__PURE__ */ _({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = Va();
    return R(), (e, n) => (g(), w(o(O), {
      "as-child": e.asChild,
      as: e.as,
      "data-disabled": o(t).disabled.value ? "" : void 0,
      "data-orientation": o(t).orientation.value
    }, {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "data-disabled", "data-orientation"]));
  }
}), Sh = /* @__PURE__ */ _({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = Va(), e = os();
    R();
    const n = A(() => {
      var r, i;
      return (i = (r = t.modelValue) == null ? void 0 : r.value) == null ? void 0 : i.map(
        (u) => es(u, t.min.value, t.max.value)
      );
    }), l = A(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), s = A(() => 100 - Math.max(...n.value));
    return (r, i) => (g(), w(o(O), {
      "data-disabled": o(t).disabled.value ? "" : void 0,
      "data-orientation": o(t).orientation.value,
      "as-child": r.asChild,
      as: r.as,
      style: ge({
        [o(e).startEdge]: `${l.value}%`,
        [o(e).endEdge]: `${s.value}%`
      })
    }, {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]));
  }
});
let dn = null, mt = null;
function op(a, t) {
  if (t) {
    const e = (t & ps) !== 0, n = (t & fs) !== 0, l = (t & vs) !== 0, s = (t & ms) !== 0;
    if (e)
      return l ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (n)
      return l ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (l)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (a) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function lp() {
  mt !== null && (document.head.removeChild(mt), dn = null, mt = null);
}
function en(a, t) {
  const e = op(a, t);
  dn !== e && (dn = e, mt === null && (mt = document.createElement("style"), document.head.appendChild(mt)), mt.innerHTML = `*{cursor: ${e}!important;}`);
}
function sp({
  defaultSize: a,
  dragState: t,
  layout: e,
  panelData: n,
  panelIndex: l,
  precision: s = 3
}) {
  const r = e[l];
  let i;
  return r == null ? i = a !== void 0 ? a.toPrecision(s) : "1" : n.length === 1 ? i = "1" : i = r.toPrecision(s), {
    flexBasis: 0,
    flexGrow: i,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function rs(a) {
  return a.type === "keydown";
}
function is(a) {
  return a.type.startsWith("mouse");
}
function us(a) {
  return a.type.startsWith("touch");
}
function Fa(a) {
  if (is(a))
    return {
      x: a.clientX,
      y: a.clientY
    };
  if (us(a)) {
    const t = a.touches[0];
    if (t && t.clientX && t.clientY)
      return {
        x: t.clientX,
        y: t.clientY
      };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function ds(a, t) {
  const e = a === "horizontal", { x: n, y: l } = Fa(t);
  return e ? n : l;
}
function rp(a, t, e) {
  return e ? a.x < t.x + t.width && a.x + a.width > t.x && a.y < t.y + t.height && a.y + a.height > t.y : a.x <= t.x + t.width && a.x + a.width >= t.x && a.y <= t.y + t.height && a.y + a.height >= t.y;
}
function le(a, t = "Assertion failed!") {
  if (!a)
    throw console.error(t), new Error(t);
}
function ip(a, t) {
  if (a === t)
    throw new Error("Cannot compare node with itself");
  const e = {
    a: $o(a),
    b: $o(t)
  };
  let n;
  for (; e.a.at(-1) === e.b.at(-1); )
    a = e.a.pop(), t = e.b.pop(), n = a;
  le(n);
  const l = {
    a: Do(So(e.a)),
    b: Do(So(e.b))
  };
  if (l.a === l.b) {
    const s = n.childNodes, r = {
      a: e.a.at(-1),
      b: e.b.at(-1)
    };
    let i = s.length;
    for (; i--; ) {
      const u = s[i];
      if (u === r.a)
        return 1;
      if (u === r.b)
        return -1;
    }
  }
  return Math.sign(l.a - l.b);
}
const up = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function dp(a) {
  const t = getComputedStyle(cs(a)).display;
  return t === "flex" || t === "inline-flex";
}
function cp(a) {
  const t = getComputedStyle(a);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || dp(a)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || up.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function So(a) {
  let t = a.length;
  for (; t--; ) {
    const e = a[t];
    if (le(e), cp(e))
      return e;
  }
  return null;
}
function Do(a) {
  return a && Number(getComputedStyle(a).zIndex) || 0;
}
function $o(a) {
  const t = [];
  for (; a; )
    t.push(a), a = cs(a);
  return t;
}
function cs(a) {
  var t;
  return ((t = a.parentNode) == null ? void 0 : t.host) || a.parentNode;
}
const ps = 1, fs = 2, vs = 4, ms = 8;
function pp() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const fp = pp() === "coarse", lt = [];
let La = !1;
const at = /* @__PURE__ */ new Map(), Na = /* @__PURE__ */ new Map(), Jt = /* @__PURE__ */ new Set();
function vp(a, t, e, n, l) {
  const { ownerDocument: s } = t, r = {
    direction: e,
    element: t,
    hitAreaMargins: n,
    setResizeHandlerState: l
  }, i = at.get(s) ?? 0;
  return at.set(s, i + 1), Jt.add(r), wa(), function() {
    Na.delete(a), Jt.delete(r);
    const d = at.get(s) ?? 1;
    at.set(s, d - 1), wa(), d === 1 && at.delete(s);
  };
}
function va(a) {
  const { target: t } = a, { x: e, y: n } = Fa(a);
  La = !0, ro({ target: t, x: e, y: n }), wa(), lt.length > 0 && (io("down", a), a.preventDefault());
}
function Qe(a) {
  const { x: t, y: e } = Fa(a);
  if (!La) {
    const { target: n } = a;
    ro({ target: n, x: t, y: e });
  }
  io("move", a), hs(), lt.length > 0 && a.preventDefault();
}
function et(a) {
  const { target: t } = a, { x: e, y: n } = Fa(a);
  Na.clear(), La = !1, lt.length > 0 && a.preventDefault(), io("up", a), ro({ target: t, x: e, y: n }), hs(), wa();
}
function ro({
  target: a,
  x: t,
  y: e
}) {
  lt.splice(0);
  let n = null;
  a instanceof HTMLElement && (n = a), Jt.forEach((l) => {
    const { element: s, hitAreaMargins: r } = l, i = s.getBoundingClientRect(), { bottom: u, left: d, right: p, top: c } = i, f = fp ? r.coarse : r.fine;
    if (t >= d - f && t <= p + f && e >= c - f && e <= u + f) {
      if (n !== null && s !== n && !s.contains(n) && !n.contains(s) && ip(n, s) > 0) {
        let y = n, h = !1;
        for (; y && !y.contains(s); ) {
          if (rp(
            y.getBoundingClientRect(),
            i,
            !0
          )) {
            h = !0;
            break;
          }
          y = y.parentElement;
        }
        if (h)
          return;
      }
      lt.push(l);
    }
  });
}
function tn(a, t) {
  Na.set(a, t);
}
function hs() {
  let a = !1, t = !1;
  lt.forEach((n) => {
    const { direction: l } = n;
    l === "horizontal" ? a = !0 : t = !0;
  });
  let e = 0;
  Na.forEach((n) => {
    e |= n;
  }), a && t ? en("intersection", e) : a ? en("horizontal", e) : t ? en("vertical", e) : lp();
}
function wa() {
  at.forEach((a, t) => {
    const { body: e } = t;
    e.removeEventListener("contextmenu", et), e.removeEventListener("mousedown", va), e.removeEventListener("mouseleave", Qe), e.removeEventListener("mousemove", Qe), e.removeEventListener("touchmove", Qe), e.removeEventListener("touchstart", va);
  }), window.removeEventListener("mouseup", et), window.removeEventListener("touchcancel", et), window.removeEventListener("touchend", et), Jt.size > 0 && (La ? (lt.length > 0 && at.forEach((a, t) => {
    const { body: e } = t;
    a > 0 && (e.addEventListener("contextmenu", et), e.addEventListener("mouseleave", Qe), e.addEventListener("mousemove", Qe), e.addEventListener("touchmove", Qe, {
      passive: !1
    }));
  }), window.addEventListener("mouseup", et), window.addEventListener("touchcancel", et), window.addEventListener("touchend", et)) : at.forEach((a, t) => {
    const { body: e } = t;
    a > 0 && (e.addEventListener("mousedown", va), e.addEventListener("mousemove", Qe), e.addEventListener("touchmove", Qe, {
      passive: !1
    }), e.addEventListener("touchstart", va));
  }));
}
function io(a, t) {
  Jt.forEach((e) => {
    const { setResizeHandlerState: n } = e, l = lt.includes(e);
    n(a, l, t);
  });
}
const ys = 10;
function Qt(a, t, e = ys) {
  a = Number.parseFloat(a.toFixed(e)), t = Number.parseFloat(t.toFixed(e));
  const n = a - t;
  return n === 0 ? 0 : n > 0 ? 1 : -1;
}
function Me(a, t, e) {
  return Qt(a, t, e) === 0;
}
function Bt({
  panelConstraints: a,
  panelIndex: t,
  size: e
}) {
  const n = a[t];
  le(n != null);
  const { collapsedSize: l = 0, collapsible: s, maxSize: r = 100, minSize: i = 0 } = n;
  if (Qt(e, i) < 0)
    if (s) {
      const u = (l + i) / 2;
      Qt(e, u) < 0 ? e = l : e = i;
    } else
      e = i;
  return e = Math.min(r, e), e = Number.parseFloat(e.toFixed(ys)), e;
}
function ma(a, t) {
  if (a.length !== t.length)
    return !1;
  for (let e = 0; e < a.length; e++)
    if (a[e] !== t[e])
      return !1;
  return !0;
}
function jt({
  delta: a,
  layout: t,
  panelConstraints: e,
  pivotIndices: n,
  trigger: l
}) {
  if (Me(a, 0))
    return t;
  const s = [...t], [r, i] = n;
  le(r != null), le(i != null);
  let u = 0;
  if (l === "keyboard") {
    {
      const p = a < 0 ? i : r, c = e[p];
      if (le(c), c.collapsible) {
        const f = t[p];
        le(f != null);
        const v = e[p];
        le(v);
        const { collapsedSize: y = 0, minSize: h = 0 } = v;
        if (Me(f, y)) {
          const x = h - f;
          Qt(x, Math.abs(a)) > 0 && (a = a < 0 ? 0 - x : x);
        }
      }
    }
    {
      const p = a < 0 ? r : i, c = e[p];
      le(c);
      const { collapsible: f } = c;
      if (f) {
        const v = t[p];
        le(v != null);
        const y = e[p];
        le(y);
        const { collapsedSize: h = 0, minSize: x = 0 } = y;
        if (Me(v, x)) {
          const P = v - h;
          Qt(P, Math.abs(a)) > 0 && (a = a < 0 ? 0 - P : P);
        }
      }
    }
  }
  {
    const p = a < 0 ? 1 : -1;
    let c = a < 0 ? i : r, f = 0;
    for (; ; ) {
      const y = t[c];
      le(y != null);
      const x = Bt({
        panelConstraints: e,
        panelIndex: c,
        size: 100
      }) - y;
      if (f += x, c += p, c < 0 || c >= e.length)
        break;
    }
    const v = Math.min(Math.abs(a), Math.abs(f));
    a = a < 0 ? 0 - v : v;
  }
  {
    let c = a < 0 ? r : i;
    for (; c >= 0 && c < e.length; ) {
      const f = Math.abs(a) - Math.abs(u), v = t[c];
      le(v != null);
      const y = v - f, h = Bt({
        panelConstraints: e,
        panelIndex: c,
        size: y
      });
      if (!Me(v, h) && (u += v - h, s[c] = h, u.toPrecision(3).localeCompare(Math.abs(a).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      a < 0 ? c-- : c++;
    }
  }
  if (Me(u, 0))
    return t;
  {
    const p = a < 0 ? i : r, c = t[p];
    le(c != null);
    const f = c + u, v = Bt({
      panelConstraints: e,
      panelIndex: p,
      size: f
    });
    if (s[p] = v, !Me(v, f)) {
      let y = f - v, x = a < 0 ? i : r;
      for (; x >= 0 && x < e.length; ) {
        const P = s[x];
        le(P != null);
        const $ = P + y, b = Bt({
          panelConstraints: e,
          panelIndex: x,
          size: $
        });
        if (Me(P, b) || (y -= b - P, s[x] = b), Me(y, 0))
          break;
        a > 0 ? x-- : x++;
      }
    }
  }
  const d = s.reduce((p, c) => c + p, 0);
  return Me(d, 100) ? s : t;
}
function gs(a, t = document) {
  var n;
  if (!aa)
    return null;
  if (t instanceof HTMLElement && ((n = t == null ? void 0 : t.dataset) == null ? void 0 : n.panelGroupId) === a)
    return t;
  const e = t.querySelector(
    `[data-panel-group][data-panel-group-id="${a}"]`
  );
  return e || null;
}
function za(a, t = document) {
  if (!aa)
    return null;
  const e = t.querySelector(`[data-panel-resize-handle-id="${a}"]`);
  return e || null;
}
function bs(a, t, e = document) {
  return aa ? ea(a, e).findIndex(
    (s) => s.getAttribute("data-panel-resize-handle-id") === t
  ) ?? null : null;
}
function ea(a, t = document) {
  return aa ? Array.from(
    t.querySelectorAll(
      `[data-panel-resize-handle-id][data-panel-group-id="${a}"]`
    )
  ) : [];
}
function mp(a, t, e, n = document) {
  var d, p;
  const l = za(t, n), s = ea(a, n), r = l ? s.indexOf(l) : -1, i = ((d = e[r]) == null ? void 0 : d.id) ?? null, u = ((p = e[r + 1]) == null ? void 0 : p.id) ?? null;
  return [i, u];
}
function hp(a, t, e, n, l) {
  const s = e === "horizontal", r = za(t, l);
  le(r);
  const i = r.getAttribute("data-panel-group-id");
  le(i);
  const { initialCursorPosition: u } = n, d = ds(e, a), p = gs(i, l);
  le(p);
  const c = p.getBoundingClientRect(), f = s ? c.width : c.height;
  return (d - u) / f * 100;
}
function yp(a, t, e, n, l, s) {
  if (rs(a)) {
    const r = e === "horizontal";
    let i = 0;
    a.shiftKey ? i = 100 : i = l ?? 10;
    let u = 0;
    switch (a.key) {
      case "ArrowDown":
        u = r ? 0 : i;
        break;
      case "ArrowLeft":
        u = r ? -i : 0;
        break;
      case "ArrowRight":
        u = r ? i : 0;
        break;
      case "ArrowUp":
        u = r ? 0 : -i;
        break;
      case "End":
        u = 100;
        break;
      case "Home":
        u = -100;
        break;
    }
    return u;
  } else
    return n == null ? 0 : hp(
      a,
      t,
      e,
      n,
      s
    );
}
function gp({
  layout: a,
  panelsArray: t,
  pivotIndices: e
}) {
  let n = 0, l = 100, s = 0, r = 0;
  const i = e[0];
  le(i != null), t.forEach((c, f) => {
    const { constraints: v } = c, { maxSize: y = 100, minSize: h = 0 } = v;
    f === i ? (n = h, l = y) : (s += h, r += y);
  });
  const u = Math.min(l, 100 - s), d = Math.max(n, 100 - r), p = a[i];
  return {
    valueMax: u,
    valueMin: d,
    valueNow: p
  };
}
function bp({
  panelDataArray: a
}) {
  const t = Array(a.length), e = a.map(
    (s) => s.constraints
  );
  let n = 0, l = 100;
  for (let s = 0; s < a.length; s++) {
    const r = e[s];
    le(r);
    const { defaultSize: i } = r;
    i != null && (n++, t[s] = i, l -= i);
  }
  for (let s = 0; s < a.length; s++) {
    const r = e[s];
    le(r);
    const { defaultSize: i } = r;
    if (i != null)
      continue;
    const u = a.length - n, d = l / u;
    n++, t[s] = d, l -= d;
  }
  return t;
}
function Wt(a, t, e) {
  t.forEach((n, l) => {
    const s = a[l];
    le(s);
    const { callbacks: r, constraints: i, id: u } = s, { collapsedSize: d = 0, collapsible: p } = i, c = e[u];
    if (c == null || n !== c) {
      e[u] = n;
      const { onCollapse: f, onExpand: v, onResize: y } = r;
      y && y(n, c), p && (f || v) && (v && (c == null || c === d) && n !== d && v(), f && (c == null || c !== d) && n === d && f());
    }
  });
}
function Cp(a, t = 10) {
  let e = null;
  return (...l) => {
    e !== null && clearTimeout(e), e = setTimeout(() => {
      a(...l);
    }, t);
  };
}
function Cs(a, t, e) {
  const n = bs(
    a,
    t,
    e
  );
  return n != null ? [n, n + 1] : [-1, -1];
}
function _p({
  layout: a,
  panelConstraints: t
}) {
  const e = [...a], n = e.reduce(
    (s, r) => s + r,
    0
  );
  if (e.length !== t.length)
    throw new Error(
      `Invalid ${t.length} panel layout: ${e.map((s) => `${s}%`).join(", ")}`
    );
  if (!Me(n, 100)) {
    console.warn(
      `WARNING: Invalid layout total size: ${e.map((s) => `${s}%`).join(", ")}. Layout normalization will be applied.`
    );
    for (let s = 0; s < t.length; s++) {
      const r = e[s];
      le(r != null);
      const i = 100 / n * r;
      e[s] = i;
    }
  }
  let l = 0;
  for (let s = 0; s < t.length; s++) {
    const r = e[s];
    le(r != null);
    const i = Bt({
      panelConstraints: t,
      panelIndex: s,
      size: r
    });
    r !== i && (l += r - i, e[s] = i);
  }
  if (!Me(l, 0))
    for (let s = 0; s < t.length; s++) {
      const r = e[s];
      le(r != null);
      const i = r + l, u = Bt({
        panelConstraints: t,
        panelIndex: s,
        size: i
      });
      if (r !== u && (l -= u - r, e[s] = u, Me(l, 0)))
        break;
    }
  return e;
}
function Eo(a) {
  try {
    if (typeof localStorage < "u")
      a.getItem = (t) => localStorage.getItem(t), a.setItem = (t, e) => {
        localStorage.setItem(t, e);
      };
    else
      throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), a.getItem = () => null, a.setItem = () => {
    };
  }
}
function _s(a) {
  return `radix-vue:${a}`;
}
function ws(a) {
  return a.map((t) => {
    const { constraints: e, id: n, idIsFromProps: l, order: s } = t;
    return l ? n : s ? `${s}:${JSON.stringify(e)}` : JSON.stringify(e);
  }).sort((t, e) => t.localeCompare(e)).join(",");
}
function xs(a, t) {
  try {
    const e = _s(a), n = t.getItem(e);
    if (n) {
      const l = JSON.parse(n);
      if (typeof l == "object" && l != null)
        return l;
    }
  } catch {
  }
  return null;
}
function wp(a, t, e) {
  const n = xs(a, e) ?? {}, l = ws(t);
  return n[l] ?? null;
}
function xp(a, t, e, n, l) {
  const s = _s(a), r = ws(t), i = xs(a, l) ?? {};
  i[r] = {
    expandToSizes: Object.fromEntries(e.entries()),
    layout: n
  };
  try {
    l.setItem(s, JSON.stringify(i));
  } catch (u) {
    console.error(u);
  }
}
function Pp({
  eagerValuesRef: a,
  groupId: t,
  layout: e,
  panelDataArray: n,
  panelGroupElement: l,
  setLayout: s
}) {
  de((r) => {
    const i = l.value;
    if (!i)
      return;
    const u = ea(
      t,
      i
    );
    for (let d = 0; d < n.length - 1; d++) {
      const { valueMax: p, valueMin: c, valueNow: f } = gp({
        layout: e.value,
        panelsArray: n,
        pivotIndices: [d, d + 1]
      }), v = u[d];
      if (v != null) {
        const y = n[d];
        le(y), v.setAttribute("aria-controls", y.id), v.setAttribute(
          "aria-valuemax",
          `${Math.round(p)}`
        ), v.setAttribute(
          "aria-valuemin",
          `${Math.round(c)}`
        ), v.setAttribute(
          "aria-valuenow",
          f != null ? `${Math.round(f)}` : ""
        );
      }
    }
    r(() => {
      u.forEach((d) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    });
  }), de((r) => {
    const i = l.value;
    if (!i)
      return;
    const u = a.value;
    le(u);
    const { panelDataArray: d } = u, p = gs(t, i);
    le(p != null, `No group found for id "${t}"`);
    const c = ea(t, i);
    le(c);
    const f = c.map((v) => {
      const y = v.getAttribute("data-panel-resize-handle-id");
      le(y);
      const [h, x] = mp(
        t,
        y,
        d,
        i
      );
      if (h == null || x == null)
        return () => {
        };
      const P = ($) => {
        if (!$.defaultPrevented)
          switch ($.key) {
            case "Enter": {
              $.preventDefault();
              const b = d.findIndex(
                (S) => S.id === h
              );
              if (b >= 0) {
                const S = d[b];
                le(S);
                const D = e.value[b], {
                  collapsedSize: E = 0,
                  collapsible: T,
                  minSize: M = 0
                } = S.constraints;
                if (D != null && T) {
                  const V = jt({
                    delta: Me(D, E) ? M - E : E - D,
                    layout: e.value,
                    panelConstraints: d.map(
                      (I) => I.constraints
                    ),
                    pivotIndices: Cs(
                      t,
                      y,
                      i
                    ),
                    trigger: "keyboard"
                  });
                  e.value !== V && s(V);
                }
              }
              break;
            }
          }
      };
      return v.addEventListener("keydown", P), () => {
        v.removeEventListener("keydown", P);
      };
    });
    r(() => {
      f.forEach((v) => v());
    });
  });
}
const Sp = 100, Gt = {
  getItem: (a) => (Eo(Gt), Gt.getItem(a)),
  setItem: (a, t) => {
    Eo(Gt), Gt.setItem(a, t);
  }
}, [Ps, Dp] = q("PanelGroup"), Dh = /* @__PURE__ */ _({
  __name: "SplitterGroup",
  props: {
    id: {},
    autoSaveId: { default: null },
    direction: {},
    keyboardResizeBy: { default: 10 },
    storage: { default: () => Gt },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["layout"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = {}, s = ve(e.id, "radix-vue-splitter-group"), r = Pe(), { forwardRef: i, currentElement: u } = R(), d = B(null), p = B([]), c = B({}), f = B(/* @__PURE__ */ new Map()), v = B(0), y = A(() => ({
      autoSaveId: e.autoSaveId,
      direction: e.direction,
      dragState: d.value,
      id: s,
      keyboardResizeBy: e.keyboardResizeBy,
      storage: e.storage
    })), h = B({
      layout: p.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), x = (F) => p.value = F;
    Pp({
      eagerValuesRef: h,
      groupId: s,
      layout: p,
      panelDataArray: h.value.panelDataArray,
      setLayout: x,
      panelGroupElement: u
    }), de(() => {
      const { panelDataArray: F } = h.value, { autoSaveId: Y } = e;
      if (Y) {
        if (p.value.length === 0 || p.value.length !== F.length)
          return;
        let U = l[Y];
        U || (U = Cp(
          xp,
          Sp
        ), l[Y] = U);
        const Z = [...F], oe = new Map(
          f.value
        );
        U(
          Y,
          Z,
          oe,
          p.value,
          e.storage
        );
      }
    });
    function P(F, Y) {
      const { panelDataArray: U } = h.value, Z = H(U, F);
      return sp({
        defaultSize: Y,
        dragState: d.value,
        layout: p.value,
        panelData: U,
        panelIndex: Z
      });
    }
    function $(F) {
      const { panelDataArray: Y } = h.value;
      Y.push(F), Y.sort((U, Z) => {
        const oe = U.order, ee = Z.order;
        return oe == null && ee == null ? 0 : oe == null ? -1 : ee == null ? 1 : oe - ee;
      }), h.value.panelDataArrayChanged = !0;
    }
    J(() => h.value.panelDataArrayChanged, () => {
      if (h.value.panelDataArrayChanged) {
        h.value.panelDataArrayChanged = !1;
        const { autoSaveId: F, storage: Y } = y.value, { layout: U, panelDataArray: Z } = h.value;
        let oe = null;
        if (F) {
          const W = wp(F, Z, Y);
          W && (f.value = new Map(
            Object.entries(W.expandToSizes)
          ), oe = W.layout);
        }
        oe === null && (oe = bp({
          panelDataArray: Z
        }));
        const ee = _p({
          layout: oe,
          panelConstraints: Z.map(
            (W) => W.constraints
          )
        });
        or(U, ee) || (x(ee), h.value.layout = ee, n("layout", ee), Wt(
          Z,
          ee,
          c.value
        ));
      }
    });
    function b(F) {
      return function(U) {
        U.preventDefault();
        const Z = u.value;
        if (!Z)
          return () => null;
        const { direction: oe, dragState: ee, id: W, keyboardResizeBy: ce } = y.value, { layout: pe, panelDataArray: ue } = h.value, { initialLayout: Ee } = ee ?? {}, se = Cs(
          W,
          F,
          Z
        );
        let ie = yp(
          U,
          F,
          oe,
          ee,
          ce,
          Z
        );
        if (ie === 0)
          return;
        const Ce = oe === "horizontal";
        r.value === "rtl" && Ce && (ie = -ie);
        const Ie = ue.map((Ye) => Ye.constraints), Oe = jt({
          delta: ie,
          layout: Ee ?? pe,
          panelConstraints: Ie,
          pivotIndices: se,
          trigger: rs(U) ? "keyboard" : "mouse-or-touch"
        }), _e = !ma(pe, Oe);
        (is(U) || us(U)) && v.value !== ie && (v.value = ie, _e ? tn(F, 0) : Ce ? tn(
          F,
          ie < 0 ? ps : fs
        ) : tn(
          F,
          ie < 0 ? vs : ms
        )), _e && (x(Oe), h.value.layout = Oe, n("layout", Oe), Wt(
          ue,
          Oe,
          c.value
        ));
      };
    }
    function S(F, Y) {
      const { layout: U, panelDataArray: Z } = h.value, oe = Z.map((Ee) => Ee.constraints), { panelSize: ee, pivotIndices: W } = z(
        Z,
        F,
        U
      );
      le(ee != null);
      const pe = H(Z, F) === Z.length - 1 ? ee - Y : Y - ee, ue = jt({
        delta: pe,
        layout: U,
        panelConstraints: oe,
        pivotIndices: W,
        trigger: "imperative-api"
      });
      ma(U, ue) || (x(ue), h.value.layout = ue, n("layout", ue), Wt(
        Z,
        ue,
        c.value
      ));
    }
    function D(F, Y) {
      const { layout: U, panelDataArray: Z } = h.value, {
        collapsedSize: oe = 0,
        collapsible: ee
      } = Y, {
        collapsedSize: W = 0,
        collapsible: ce,
        maxSize: pe = 100,
        minSize: ue = 0
      } = F.constraints, { panelSize: Ee } = z(
        Z,
        F,
        U
      );
      Ee !== null && (ee && ce && Ee === oe ? oe !== W && S(F, W) : Ee < ue ? S(F, ue) : Ee > pe && S(F, pe));
    }
    function E(F, Y) {
      const { direction: U } = y.value, { layout: Z } = h.value;
      if (!u.value)
        return;
      const oe = za(
        F,
        u.value
      );
      le(oe);
      const ee = ds(
        U,
        Y
      );
      d.value = {
        dragHandleId: F,
        dragHandleRect: oe.getBoundingClientRect(),
        initialCursorPosition: ee,
        initialLayout: Z
      };
    }
    function T() {
      d.value = null;
    }
    function M(F) {
      const { panelDataArray: Y } = h.value, U = H(Y, F);
      U >= 0 && (Y.splice(U, 1), delete c.value[F.id], h.value.panelDataArrayChanged = !0);
    }
    function V(F) {
      const { layout: Y, panelDataArray: U } = h.value;
      if (F.constraints.collapsible) {
        const Z = U.map(
          (ce) => ce.constraints
        ), {
          collapsedSize: oe = 0,
          panelSize: ee,
          pivotIndices: W
        } = z(U, F, Y);
        if (le(
          ee != null,
          `Panel size not found for panel "${F.id}"`
        ), ee !== oe) {
          f.value.set(F.id, ee);
          const pe = H(U, F) === U.length - 1 ? ee - oe : oe - ee, ue = jt({
            delta: pe,
            layout: Y,
            panelConstraints: Z,
            pivotIndices: W,
            trigger: "imperative-api"
          });
          ma(Y, ue) || (x(ue), h.value.layout = ue, n("layout", ue), Wt(
            U,
            ue,
            c.value
          ));
        }
      }
    }
    function I(F) {
      const { layout: Y, panelDataArray: U } = h.value;
      if (F.constraints.collapsible) {
        const Z = U.map(
          (pe) => pe.constraints
        ), {
          collapsedSize: oe = 0,
          panelSize: ee,
          minSize: W = 0,
          pivotIndices: ce
        } = z(U, F, Y);
        if (ee === oe) {
          const pe = f.value.get(
            F.id
          ), ue = pe != null && pe >= W ? pe : W, se = H(U, F) === U.length - 1 ? ee - ue : ue - ee, ie = jt({
            delta: se,
            layout: Y,
            panelConstraints: Z,
            pivotIndices: ce,
            trigger: "imperative-api"
          });
          ma(Y, ie) || (x(ie), h.value.layout = ie, n("layout", ie), Wt(
            U,
            ie,
            c.value
          ));
        }
      }
    }
    function L(F) {
      const { layout: Y, panelDataArray: U } = h.value, { panelSize: Z } = z(U, F, Y);
      return le(
        Z != null,
        `Panel size not found for panel "${F.id}"`
      ), Z;
    }
    function G(F) {
      const { layout: Y, panelDataArray: U } = h.value, {
        collapsedSize: Z = 0,
        collapsible: oe,
        panelSize: ee
      } = z(U, F, Y);
      return oe === !0 && ee === Z;
    }
    function X(F) {
      const { layout: Y, panelDataArray: U } = h.value, {
        collapsedSize: Z = 0,
        collapsible: oe,
        panelSize: ee
      } = z(U, F, Y);
      return le(
        ee != null,
        `Panel size not found for panel "${F.id}"`
      ), !oe || ee > Z;
    }
    Dp({
      direction: e.direction,
      dragState: d.value,
      groupId: s,
      reevaluatePanelConstraints: D,
      registerPanel: $,
      registerResizeHandle: b,
      resizePanel: S,
      startDragging: E,
      stopDragging: T,
      unregisterPanel: M,
      panelGroupElement: u,
      collapsePanel: V,
      expandPanel: I,
      isPanelCollapsed: G,
      isPanelExpanded: X,
      getPanelSize: L,
      getPanelStyle: P
    });
    function H(F, Y) {
      return F.findIndex(
        (U) => U === Y || U.id === Y.id
      );
    }
    function z(F, Y, U) {
      const Z = H(F, Y), ee = Z === F.length - 1 ? [Z - 1, Z] : [Z, Z + 1], W = U[Z];
      return {
        ...Y.constraints,
        panelSize: W,
        pivotIndices: ee
      };
    }
    return (F, Y) => (g(), w(o(O), {
      ref: o(i),
      style: ge({
        display: "flex",
        flexDirection: F.direction === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": F.direction,
      "data-panel-group-id": o(s)
    }, {
      default: m(() => [
        C(F.$slots, "default", { layout: p.value })
      ]),
      _: 3
    }, 8, ["style", "data-orientation", "data-panel-group-id"]));
  }
}), $h = /* @__PURE__ */ _({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {},
    collapsible: { type: Boolean },
    defaultSize: {},
    id: {},
    maxSize: {},
    minSize: {},
    order: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["collapse", "expand", "resize"],
  setup(a, { expose: t, emit: e }) {
    const n = a, l = e, s = Ps();
    if (s === null)
      throw new Error(
        "SplitterPanel components must be rendered within a SplitterGroup container"
      );
    const { collapsePanel: r, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: p, resizePanel: c, groupId: f, reevaluatePanelConstraints: v, registerPanel: y, unregisterPanel: h } = s, x = ve(n.id, "radix-vue-splitter-panel"), P = A(() => ({
      callbacks: {
        onCollapse: () => l("collapse"),
        onExpand: () => l("expand"),
        onResize: (...D) => l("resize", ...D)
      },
      constraints: {
        collapsedSize: n.collapsedSize,
        collapsible: n.collapsible,
        defaultSize: n.defaultSize,
        /** Panel id (unique within group); falls back to useId when not provided */
        /** Panel id (unique within group); falls back to useId when not provided */
        maxSize: n.maxSize,
        minSize: n.minSize
      },
      id: x,
      idIsFromProps: n.id !== void 0,
      order: n.order
    }));
    J(() => P.value.constraints, (D, E) => {
      (D.collapsedSize !== E.collapsedSize || D.collapsible !== E.collapsible || D.maxSize !== E.maxSize || D.minSize !== E.minSize) && v(P.value, D);
    }, { deep: !0 }), ae(() => {
      const D = P.value;
      y(D), De(() => {
        h(D);
      });
    });
    const $ = A(() => d(P.value, n.defaultSize)), b = A(() => p(P.value)), S = A(() => !b.value);
    return t({
      /** If panel is `collapsible`, collapse it fully. */
      collapse: () => {
        r(P.value);
      },
      /** If panel is currently collapsed, expand it to its most recent size. */
      expand: () => {
        i(P.value);
      },
      /** Gets the current size of the panel as a percentage (1 - 100). */
      getSize() {
        return u(P.value);
      },
      /** Resize panel to the specified percentage (1 - 100). */
      resize: (D) => {
        c(P.value, D);
      },
      /** Returns `true` if the panel is currently collapsed */
      isCollapsed: b,
      /** Returns `true` if the panel is currently not collapsed */
      isExpanded: S
    }), (D, E) => (g(), w(o(O), {
      id: o(x),
      style: ge($.value),
      "data-panel": "",
      "data-panel-collapsible": D.collapsible || void 0,
      "data-panel-group-id": o(f),
      "data-panel-id": o(x),
      "data-panel-size": Number.parseFloat(`${$.value.flexGrow}`).toFixed(1),
      "data-state": D.collapsible ? b.value ? "collapsed" : "expanded" : void 0
    }, {
      default: m(() => [
        C(D.$slots, "default", {
          isCollapsed: b.value,
          isExpanded: S.value
        })
      ]),
      _: 3
    }, 8, ["id", "style", "data-panel-collapsible", "data-panel-group-id", "data-panel-id", "data-panel-size", "data-state"]));
  }
});
function $p({
  disabled: a,
  handleId: t,
  resizeHandler: e,
  panelGroupElement: n
}) {
  de((l) => {
    const s = n.value;
    if (a.value || e.value === null || s === null)
      return;
    const r = za(t, s);
    if (r == null)
      return;
    const i = (u) => {
      var d;
      if (!u.defaultPrevented)
        switch (u.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            u.preventDefault(), (d = e.value) == null || d.call(e, u);
            break;
          }
          case "F6": {
            u.preventDefault();
            const p = r.getAttribute("data-panel-group-id");
            le(p);
            const c = ea(
              p,
              s
            ), f = bs(
              p,
              t,
              s
            );
            le(f !== null);
            const v = u.shiftKey ? f > 0 ? f - 1 : c.length - 1 : f + 1 < c.length ? f + 1 : 0;
            c[v].focus();
            break;
          }
        }
    };
    r.addEventListener("keydown", i), l(() => {
      r.removeEventListener("keydown", i);
    });
  });
}
const Eh = /* @__PURE__ */ _({
  __name: "SplitterResizeHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: { default: 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["dragging"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), { disabled: r } = te(e), i = Ps();
    if (i === null)
      throw new Error(
        "PanelResizeHandle components must be rendered within a PanelGroup container"
      );
    const {
      direction: u,
      groupId: d,
      registerResizeHandle: p,
      startDragging: c,
      stopDragging: f,
      panelGroupElement: v
    } = i, y = ve(e.id, "radix-vue-splitter-resize-handle"), h = B("inactive"), x = B(!1), P = B(null);
    return J(r, () => {
      aa && (r.value ? P.value = null : P.value = p(y));
    }, { immediate: !0 }), de(($) => {
      var D, E;
      if (r.value || P.value === null)
        return;
      const b = s.value;
      if (!b)
        return;
      le(b);
      const S = (T, M, V) => {
        var I;
        if (M)
          switch (T) {
            case "down": {
              h.value = "drag", c(y, V), n("dragging", !0);
              break;
            }
            case "move": {
              h.value !== "drag" && (h.value = "hover"), (I = P.value) == null || I.call(P, V);
              break;
            }
            case "up": {
              h.value = "hover", f(), n("dragging", !1);
              break;
            }
          }
        else
          h.value = "inactive";
      };
      $(vp(
        y,
        b,
        u,
        {
          // Coarse inputs (e.g. finger/touch)
          coarse: ((D = e.hitAreaMargins) == null ? void 0 : D.coarse) ?? 15,
          // Fine inputs (e.g. mouse)
          fine: ((E = e.hitAreaMargins) == null ? void 0 : E.fine) ?? 5
        },
        S
      ));
    }), $p({
      disabled: r,
      resizeHandler: P,
      handleId: y,
      panelGroupElement: v
    }), ($, b) => (g(), w(o(O), {
      id: o(y),
      ref: o(l),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      role: "separator",
      "data-resize-handle": "",
      tabindex: $.tabindex,
      "data-state": h.value,
      "data-disabled": o(r) ? "" : void 0,
      "data-orientation": o(u),
      "data-panel-group-id": o(d),
      "data-resize-handle-active": h.value === "drag" ? "pointer" : x.value ? "keyboard" : void 0,
      "data-resize-handle-state": h.value,
      "data-panel-resize-handle-enabled": !o(r),
      "data-panel-resize-handle-id": o(y),
      onBlur: b[0] || (b[0] = (S) => x.value = !1),
      onFocus: b[1] || (b[1] = (S) => x.value = !1)
    }, {
      default: m(() => [
        C($.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "tabindex", "data-state", "data-disabled", "data-orientation", "data-panel-group-id", "data-resize-handle-active", "data-resize-handle-state", "data-panel-resize-handle-enabled", "data-panel-resize-handle-id"]));
  }
}), Ep = ["name", "disabled", "required", "value", "checked", "data-state", "data-disabled"], [Bp, Rp] = q("SwitchRoot"), Bh = /* @__PURE__ */ _({
  __name: "SwitchRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(a, { emit: t }) {
    const e = a, n = t, { disabled: l } = te(e), s = Q(e, "checked", n, {
      defaultValue: e.defaultChecked,
      passive: e.checked === void 0
    });
    function r() {
      l.value || (s.value = !s.value);
    }
    const { forwardRef: i, currentElement: u } = R(), d = gt(u), p = A(() => {
      var c;
      return e.id && u.value ? (c = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : c.innerText : void 0;
    });
    return Rp({
      checked: s,
      toggleCheck: r,
      disabled: l
    }), (c, f) => (g(), fe(xe, null, [
      j(o(O), k(c.$attrs, {
        id: c.id,
        ref: o(i),
        role: "switch",
        type: c.as === "button" ? "button" : void 0,
        value: c.value,
        "aria-label": c.$attrs["aria-label"] || p.value,
        "aria-checked": o(s),
        "aria-required": c.required,
        "data-state": o(s) ? "checked" : "unchecked",
        "data-disabled": o(l) ? "" : void 0,
        "as-child": c.asChild,
        as: c.as,
        disabled: o(l),
        onClick: r,
        onKeydown: he(ye(r, ["prevent"]), ["enter"])
      }), {
        default: m(() => [
          C(c.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]),
      o(d) ? (g(), fe("input", {
        key: 0,
        type: "checkbox",
        name: c.name,
        tabindex: "-1",
        "aria-hidden": "",
        disabled: o(l),
        required: c.required,
        value: c.value,
        checked: !!o(s),
        "data-state": o(s) ? "checked" : "unchecked",
        "data-disabled": o(l) ? "" : void 0,
        style: ge({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, Ep)) : re("", !0)
    ], 64));
  }
}), Rh = /* @__PURE__ */ _({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = Bp();
    return R(), (e, n) => {
      var l;
      return g(), w(o(O), {
        "data-state": (l = o(t).checked) != null && l.value ? "checked" : "unchecked",
        "data-disabled": o(t).disabled.value ? "" : void 0,
        "as-child": e.asChild,
        as: e.as
      }, {
        default: m(() => [
          C(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"]);
    };
  }
}), [Ka, Ap] = q("TabsRoot"), Ah = /* @__PURE__ */ _({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, n = t, { orientation: l, dir: s } = te(e), r = Pe(s);
    R();
    const i = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), u = B();
    return Ap({
      modelValue: i,
      changeModelValue: (d) => {
        i.value = d;
      },
      orientation: l,
      dir: r,
      activationMode: e.activationMode,
      baseId: ve(void 0, "radix-vue-tabs"),
      tabsList: u
    }), (d, p) => (g(), w(o(O), {
      dir: o(r),
      "data-orientation": o(l),
      "as-child": d.asChild,
      as: d.as
    }, {
      default: m(() => [
        C(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), Th = /* @__PURE__ */ _({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { loop: e } = te(t), { forwardRef: n, currentElement: l } = R(), s = Ka();
    return s.tabsList = l, (r, i) => (g(), w(o(Ft), {
      "as-child": "",
      orientation: o(s).orientation.value,
      dir: o(s).dir.value,
      loop: o(e)
    }, {
      default: m(() => [
        j(o(O), {
          ref: o(n),
          role: "tablist",
          "as-child": r.asChild,
          as: r.as,
          "aria-orientation": o(s).orientation.value
        }, {
          default: m(() => [
            C(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
function Ss(a, t) {
  return `${a}-trigger-${t}`;
}
function Ds(a, t) {
  return `${a}-content-${t}`;
}
const Ih = /* @__PURE__ */ _({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e } = R(), n = Ka(), l = A(() => Ss(n.baseId, t.value)), s = A(() => Ds(n.baseId, t.value)), r = A(() => t.value === n.modelValue.value), i = B(r.value);
    return ae(() => {
      requestAnimationFrame(() => {
        i.value = !1;
      });
    }), (u, d) => (g(), w(o(we), {
      present: r.value,
      "force-mount": ""
    }, {
      default: m(({ present: p }) => [
        j(o(O), {
          id: s.value,
          ref: o(e),
          "as-child": u.asChild,
          as: u.as,
          role: "tabpanel",
          "data-state": r.value ? "active" : "inactive",
          "data-orientation": o(n).orientation.value,
          "aria-labelledby": l.value,
          hidden: !p.value,
          tabindex: "0",
          style: ge({
            animationDuration: i.value ? "0s" : void 0
          })
        }, {
          default: m(() => [
            u.forceMount || r.value ? C(u.$slots, "default", { key: 0 }) : re("", !0)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Oh = /* @__PURE__ */ _({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, { forwardRef: e } = R(), n = Ka(), l = A(() => Ss(n.baseId, t.value)), s = A(() => Ds(n.baseId, t.value)), r = A(() => t.value === n.modelValue.value);
    return (i, u) => (g(), w(o(Lt), {
      "as-child": "",
      focusable: !i.disabled,
      active: r.value
    }, {
      default: m(() => [
        j(o(O), {
          id: l.value,
          ref: o(e),
          role: "tab",
          type: i.as === "button" ? "button" : void 0,
          as: i.as,
          "as-child": i.asChild,
          "aria-selected": r.value ? "true" : "false",
          "aria-controls": s.value,
          "data-state": r.value ? "active" : "inactive",
          disabled: i.disabled,
          "data-disabled": i.disabled ? "" : void 0,
          "data-orientation": o(n).orientation.value,
          onMousedown: u[0] || (u[0] = ye((d) => {
            !i.disabled && d.ctrlKey === !1 ? o(n).changeModelValue(i.value) : d.preventDefault();
          }, ["left"])),
          onKeydown: u[1] || (u[1] = he((d) => o(n).changeModelValue(i.value), ["enter", "space"])),
          onFocus: u[2] || (u[2] = () => {
            const d = o(n).activationMode !== "manual";
            !r.value && !i.disabled && d && o(n).changeModelValue(i.value);
          })
        }, {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), kh = /* @__PURE__ */ _({
  __name: "TabsIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Ka();
    R();
    const n = B(), l = B({
      size: null,
      position: null
    });
    J(() => e.modelValue.value, async (r) => {
      await ne(), s();
    }, { immediate: !0 }), We([e.tabsList, n], s);
    function s() {
      var r;
      n.value = (r = e.tabsList.value) == null ? void 0 : r.querySelector('[role="tab"][data-state="active"]'), n.value && (e.orientation.value === "horizontal" ? l.value = {
        size: n.value.offsetWidth,
        position: n.value.offsetLeft
      } : l.value = {
        size: n.value.offsetHeight,
        position: n.value.offsetTop
      });
    }
    return (r, i) => typeof l.value.size == "number" ? (g(), w(o(O), k({ key: 0 }, t, {
      style: {
        "--radix-tabs-indicator-size": `${l.value.size}px`,
        "--radix-tabs-indicator-position": `${l.value.position}px`
      }
    }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"])) : re("", !0);
  }
}), [Ha, Tp] = q("TagsInputRoot"), Mh = /* @__PURE__ */ _({
  __name: "TagsInputRoot",
  props: {
    modelValue: {},
    defaultValue: { default: () => [] },
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: { default: "," },
    dir: {},
    max: { default: 0 },
    required: { type: Boolean },
    name: {},
    id: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "invalid"],
  setup(a, { emit: t }) {
    const e = a, n = t, { addOnPaste: l, disabled: s, delimiter: r, max: i, id: u, dir: d, addOnBlur: p, addOnTab: c } = te(e), f = Pe(d), v = Q(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: !0,
      deep: !0
    }), { forwardRef: y, currentElement: h } = R(), { focused: x } = Kr(h), P = gt(h), { getItems: $ } = In(), b = B(), S = B(!1);
    return Tp({
      modelValue: v,
      onAddValue: (D) => {
        if (v.value.length >= i.value && i.value)
          return n("invalid", D), !1;
        if (e.duplicate)
          return v.value.push(D), !0;
        if (v.value.includes(D))
          S.value = !0;
        else
          return v.value.push(D), !0;
        return n("invalid", D), !1;
      },
      onRemoveValue: (D) => {
        D !== -1 && v.value.splice(D, 1);
      },
      onInputKeydown: (D) => {
        const E = D.target, T = $().map((V) => V.ref).filter((V) => V.dataset.disabled !== "");
        if (!T.length)
          return;
        const M = T.at(-1);
        switch (D.key) {
          case "Delete":
          case "Backspace": {
            if (E.selectionStart !== 0 || E.selectionEnd !== 0)
              break;
            if (b.value) {
              const V = T.findIndex((I) => I === b.value);
              v.value.splice(V, 1), b.value = b.value === M ? T.at(V - 1) : T.at(V + 1), D.preventDefault();
            } else
              D.key === "Backspace" && (b.value = M, D.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const V = D.key === "ArrowRight" && f.value === "ltr" || D.key === "ArrowLeft" && f.value === "rtl", I = !V;
            if (E.selectionStart !== 0 || E.selectionEnd !== 0)
              break;
            if (I && !b.value)
              b.value = M, D.preventDefault();
            else if (V && M && b.value === M)
              b.value = void 0, D.preventDefault();
            else if (b.value) {
              const L = Ot(D, b.value, void 0, {
                itemsArray: T,
                loop: !1,
                dir: f.value
              });
              L && (b.value = L), D.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            b.value && D.preventDefault();
            break;
          }
          default:
            b.value = void 0;
        }
      },
      selectedElement: b,
      isInvalidInput: S,
      addOnPaste: l,
      addOnBlur: p,
      addOnTab: c,
      dir: f,
      disabled: s,
      delimiter: r,
      max: i,
      id: u
    }), (D, E) => (g(), w(o(On), null, {
      default: m(() => [
        j(o(O), {
          ref: o(y),
          dir: o(f),
          as: D.as,
          "as-child": D.asChild,
          "data-invalid": S.value ? "" : void 0,
          "data-disabled": o(s) ? "" : void 0,
          "data-focused": o(x) ? "" : void 0
        }, {
          default: m(() => [
            C(D.$slots, "default", { modelValue: o(v) }),
            o(P) && D.name ? (g(), w(o(bl), {
              key: 0,
              name: D.name,
              value: o(v),
              required: D.required,
              disabled: o(s)
            }, null, 8, ["name", "value", "required", "disabled"])) : re("", !0)
          ]),
          _: 3
        }, 8, ["dir", "as", "as-child", "data-invalid", "data-disabled", "data-focused"])
      ]),
      _: 3
    }));
  }
}), Vh = /* @__PURE__ */ _({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(a) {
    const t = a, e = Ha(), { forwardRef: n, currentElement: l } = R();
    function s(p) {
      if (!e.addOnBlur.value)
        return;
      const c = p.target;
      if (!c.value)
        return;
      e.onAddValue(c.value) && (c.value = "");
    }
    function r(p) {
      e.addOnTab.value && i(p);
    }
    async function i(p) {
      if (await ne(), p.defaultPrevented)
        return;
      const c = p.target;
      if (!c.value)
        return;
      e.onAddValue(c.value) && (c.value = ""), p.preventDefault();
    }
    function u(p) {
      e.isInvalidInput.value = !1;
      const c = e.delimiter.value;
      if (c === p.data) {
        const f = p.target;
        f.value = f.value.replaceAll(c, ""), e.onAddValue(f.value) && (f.value = "");
      }
    }
    function d(p) {
      if (e.addOnPaste.value) {
        p.preventDefault();
        const c = p.clipboardData;
        if (!c)
          return;
        const f = c.getData("text");
        e.delimiter.value ? f.split(e.delimiter.value).forEach((y) => {
          e.onAddValue(y);
        }) : e.onAddValue(f);
      }
    }
    return ae(() => {
      const p = l.value.nodeName === "INPUT" ? l.value : l.value.querySelector("input");
      p && setTimeout(() => {
        t.autoFocus && (p == null || p.focus());
      }, 1);
    }), (p, c) => {
      var f;
      return g(), w(o(O), {
        id: (f = o(e).id) == null ? void 0 : f.value,
        ref: o(n),
        type: "text",
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        as: p.as,
        "as-child": p.asChild,
        maxlength: p.maxLength,
        placeholder: p.placeholder,
        disabled: o(e).disabled.value,
        "data-invalid": o(e).isInvalidInput.value ? "" : void 0,
        onInput: u,
        onKeydown: [
          he(i, ["enter"]),
          he(r, ["tab"]),
          o(e).onInputKeydown
        ],
        onBlur: s,
        onPaste: d
      }, {
        default: m(() => [
          C(p.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "maxlength", "placeholder", "disabled", "data-invalid", "onKeydown"]);
    };
  }
}), [$s, Ip] = q("TagsInputItem"), Fh = /* @__PURE__ */ _({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { value: e } = te(t), n = Ha(), { forwardRef: l, currentElement: s } = R(), r = A(() => n.selectedElement.value === s.value), i = A(() => t.disabled || n.disabled.value), u = Ip({
      value: e,
      isSelected: r,
      disabled: i,
      textId: ""
    });
    return (d, p) => (g(), w(o(kn), null, {
      default: m(() => [
        j(o(O), {
          ref: o(l),
          as: d.as,
          "as-child": d.asChild,
          "aria-labelledby": o(u).textId,
          "aria-current": r.value,
          "data-disabled": i.value ? "" : void 0,
          "data-state": r.value ? "active" : "inactive"
        }, {
          default: m(() => [
            C(d.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "aria-labelledby", "aria-current", "data-disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), Lh = /* @__PURE__ */ _({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(a) {
    const t = a, e = $s();
    return R(), e.textId || (e.textId = ve(void 0, "radix-vue-tags-input-item-text")), (n, l) => (g(), w(o(O), k(t, {
      id: o(e).textId
    }), {
      default: m(() => [
        C(n.$slots, "default", {}, () => [
          me(ke(o(e).value.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Nh = /* @__PURE__ */ _({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = Ha(), n = $s(), l = A(() => {
      var r;
      return ((r = n.disabled) == null ? void 0 : r.value) || e.disabled.value;
    });
    function s() {
      if (l.value)
        return;
      const r = e.modelValue.value.findIndex((i) => i === n.value.value);
      e.onRemoveValue(r);
    }
    return (r, i) => (g(), w(o(O), k({ tabindex: "-1" }, t, {
      "aria-labelledby": o(n).textId,
      "aria-current": o(n).isSelected.value,
      "data-state": o(n).isSelected.value ? "active" : "inactive",
      "data-disabled": l.value ? "" : void 0,
      type: r.as === "button" ? "button" : void 0,
      onClick: s
    }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby", "aria-current", "data-state", "data-disabled", "type"]));
  }
}), zh = /* @__PURE__ */ _({
  __name: "TagsInputClear",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a;
    R();
    const e = Ha();
    function n() {
      e.disabled.value || (e.modelValue.value = []);
    }
    return (l, s) => (g(), w(o(O), k(t, {
      type: l.as === "button" ? "button" : void 0,
      "data-disabled": o(e).disabled.value ? "" : void 0,
      onClick: n
    }), {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "data-disabled"]));
  }
}), [Wa, Op] = q("ToastProvider"), Kh = /* @__PURE__ */ _({
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(a) {
    const t = a, { label: e, duration: n, swipeDirection: l, swipeThreshold: s } = te(t), r = B(), i = B(0), u = B(!1), d = B(!1);
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const p = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(p);
    }
    return Op({
      label: e,
      duration: n,
      swipeDirection: l,
      swipeThreshold: s,
      toastCount: i,
      viewport: r,
      onViewportChange(p) {
        r.value = p;
      },
      onToastAdd() {
        i.value++;
      },
      onToastRemove() {
        i.value--;
      },
      isFocusedToastEscapeKeyDownRef: u,
      isClosePausedRef: d
    }), (p, c) => C(p.$slots, "default");
  }
}), kp = "toast.swipeStart", Mp = "toast.swipeMove", Vp = "toast.swipeCancel", Fp = "toast.swipeEnd", cn = "toast.viewportPause", pn = "toast.viewportResume";
function ha(a, t, e) {
  const n = e.originalEvent.currentTarget, l = new CustomEvent(a, {
    bubbles: !1,
    cancelable: !0,
    detail: e
  });
  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);
}
function Bo(a, t, e = 0) {
  const n = Math.abs(a.x), l = Math.abs(a.y), s = n > l;
  return t === "left" || t === "right" ? s && n > e : !s && l > e;
}
function Lp(a) {
  return a.nodeType === a.ELEMENT_NODE;
}
function Es(a) {
  const t = [];
  return Array.from(a.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), Lp(n)) {
      const l = n.ariaHidden || n.hidden || n.style.display === "none", s = n.dataset.radixToastAnnounceExclude === "";
      if (!l)
        if (s) {
          const r = n.dataset.radixToastAnnounceAlt;
          r && t.push(r);
        } else
          t.push(...Es(n));
    }
  }), t;
}
const Np = /* @__PURE__ */ _({
  __name: "ToastAnnounce",
  setup(a) {
    const t = Wa(), e = kr(1e3), n = B(!1);
    return Lr(() => {
      n.value = !0;
    }), (l, s) => o(e) || n.value ? (g(), w(o(Vt), { key: 0 }, {
      default: m(() => [
        me(ke(o(t).label.value) + " ", 1),
        C(l.$slots, "default")
      ]),
      _: 3
    })) : re("", !0);
  }
}), [zp, Kp] = q("ToastRoot"), Hp = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: !1 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = Wa(), i = B(null), u = B(null), d = A(() => e.duration || r.duration.value), p = B(0), c = B(d.value), f = B(0);
    function v(x) {
      !x || x === Number.POSITIVE_INFINITY || (window.clearTimeout(f.value), p.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(y, x));
    }
    function y() {
      var P, $;
      ((P = s.value) == null ? void 0 : P.contains(document.activeElement)) && (($ = r.viewport.value) == null || $.focus()), n("close");
    }
    const h = A(() => s.value ? Es(s.value) : null);
    if (e.type && !["foreground", "background"].includes(e.type)) {
      const x = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(x);
    }
    return de((x) => {
      const P = r.viewport.value;
      if (P) {
        const $ = () => {
          v(c.value), n("resume");
        }, b = () => {
          const S = (/* @__PURE__ */ new Date()).getTime() - p.value;
          c.value = c.value - S, window.clearTimeout(f.value), n("pause");
        };
        return P.addEventListener(cn, b), P.addEventListener(pn, $), () => {
          P.removeEventListener(cn, b), P.removeEventListener(pn, $);
        };
      }
    }), de(() => {
      e.open && !r.isClosePausedRef.value && v(d.value);
    }), _n("Escape", (x) => {
      n("escapeKeyDown", x), x.defaultPrevented || (r.isFocusedToastEscapeKeyDownRef.value = !0, y());
    }), ae(() => {
      r.onToastAdd();
    }), De(() => {
      r.onToastRemove();
    }), Kp({ onClose: y }), (x, P) => (g(), fe(xe, null, [
      h.value ? (g(), w(Np, {
        key: 0,
        role: "status",
        "aria-live": x.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": ""
      }, {
        default: m(() => [
          me(ke(h.value), 1)
        ]),
        _: 1
      }, 8, ["aria-live"])) : re("", !0),
      (g(), w(At, {
        to: o(r).viewport.value
      }, [
        j(o(O), k({
          ref: o(l),
          role: "status",
          "aria-live": "off",
          "aria-atomic": "",
          tabindex: "0",
          "data-radix-vue-collection-item": ""
        }, x.$attrs, {
          as: x.as,
          "as-child": x.asChild,
          "data-state": x.open ? "open" : "closed",
          "data-swipe-direction": o(r).swipeDirection.value,
          style: { userSelect: "none", touchAction: "none" },
          onPointerdown: P[0] || (P[0] = ye(($) => {
            i.value = { x: $.clientX, y: $.clientY };
          }, ["left"])),
          onPointermove: P[1] || (P[1] = ($) => {
            if (!i.value)
              return;
            const b = $.clientX - i.value.x, S = $.clientY - i.value.y, D = !!u.value, E = ["left", "right"].includes(o(r).swipeDirection.value), T = ["left", "up"].includes(o(r).swipeDirection.value) ? Math.min : Math.max, M = E ? T(0, b) : 0, V = E ? 0 : T(0, S), I = $.pointerType === "touch" ? 10 : 2, L = { x: M, y: V }, G = { originalEvent: $, delta: L };
            D ? (u.value = L, o(ha)(o(Mp), (X) => n("swipeMove", X), G)) : o(Bo)(L, o(r).swipeDirection.value, I) ? (u.value = L, o(ha)(o(kp), (X) => n("swipeStart", X), G), $.target.setPointerCapture($.pointerId)) : (Math.abs(b) > I || Math.abs(S) > I) && (i.value = null);
          }),
          onPointerup: P[2] || (P[2] = ($) => {
            const b = u.value, S = $.target;
            if (S.hasPointerCapture($.pointerId) && S.releasePointerCapture($.pointerId), u.value = null, i.value = null, b) {
              const D = $.currentTarget, E = { originalEvent: $, delta: b };
              o(Bo)(b, o(r).swipeDirection.value, o(r).swipeThreshold.value) ? o(ha)(o(Fp), (T) => n("swipeEnd", T), E) : o(ha)(o(Vp), (T) => n("swipeCancel", T), E), D == null || D.addEventListener("click", (T) => T.preventDefault(), {
                once: !0
              });
            }
          })
        }), {
          default: m(() => [
            C(x.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
      ], 8, ["to"]))
    ], 64));
  }
}), Hh = /* @__PURE__ */ _({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: !0 },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t, { forwardRef: l } = R(), s = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    return (r, i) => (g(), w(o(we), {
      present: r.forceMount || o(s)
    }, {
      default: m(() => [
        j(Hp, k({
          ref: o(l),
          open: o(s),
          type: r.type,
          as: r.as,
          "as-child": r.asChild,
          duration: r.duration
        }, r.$attrs, {
          onClose: i[0] || (i[0] = (u) => s.value = !1),
          onPause: i[1] || (i[1] = (u) => n("pause")),
          onResume: i[2] || (i[2] = (u) => n("resume")),
          onEscapeKeyDown: i[3] || (i[3] = (u) => n("escapeKeyDown", u)),
          onSwipeStart: i[4] || (i[4] = (u) => {
            n("swipeStart", u), u.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: i[5] || (i[5] = (u) => {
            const { x: d, y: p } = u.detail.delta, c = u.currentTarget;
            c.setAttribute("data-swipe", "move"), c.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), c.style.setProperty("--radix-toast-swipe-move-y", `${p}px`);
          }),
          onSwipeCancel: i[6] || (i[6] = (u) => {
            const d = u.currentTarget;
            d.setAttribute("data-swipe", "cancel"), d.style.removeProperty("--radix-toast-swipe-move-x"), d.style.removeProperty("--radix-toast-swipe-move-y"), d.style.removeProperty("--radix-toast-swipe-end-x"), d.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: i[7] || (i[7] = (u) => {
            const { x: d, y: p } = u.detail.delta, c = u.currentTarget;
            c.setAttribute("data-swipe", "end"), c.style.removeProperty("--radix-toast-swipe-move-x"), c.style.removeProperty("--radix-toast-swipe-move-y"), c.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), c.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), s.value = !1;
          })
        }), {
          default: m(() => [
            C(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Bs = /* @__PURE__ */ _({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    return (t, e) => (g(), w(o(O), {
      as: t.as,
      "as-child": t.asChild,
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": t.altText || void 0
    }, {
      default: m(() => [
        C(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]));
  }
}), Wp = /* @__PURE__ */ _({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = zp(), { forwardRef: n } = R();
    return (l, s) => (g(), w(Bs, { "as-child": "" }, {
      default: m(() => [
        j(o(O), k(t, {
          ref: o(n),
          type: l.as === "button" ? "button" : void 0,
          onClick: s[0] || (s[0] = (r) => o(e).onClose())
        }), {
          default: m(() => [
            C(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }));
  }
}), Wh = /* @__PURE__ */ _({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    if (!a.altText)
      throw new Error("Missing prop `altText` expected on `ToastAction`");
    const { forwardRef: e } = R();
    return (n, l) => n.altText ? (g(), w(Bs, {
      key: 0,
      "alt-text": n.altText,
      "as-child": ""
    }, {
      default: m(() => [
        j(Wp, {
          ref: o(e),
          as: n.as,
          "as-child": n.asChild
        }, {
          default: m(() => [
            C(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child"])
      ]),
      _: 3
    }, 8, ["alt-text"])) : re("", !0);
  }
}), Ro = /* @__PURE__ */ _({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(a, { emit: t }) {
    const e = t, n = Wa();
    return (l, s) => (g(), w(o(Vt), {
      "aria-hidden": "",
      tabindex: "0",
      style: { position: "fixed" },
      onFocus: s[0] || (s[0] = (r) => {
        var d;
        const i = r.relatedTarget;
        !((d = o(n).viewport.value) != null && d.contains(i)) && e("focusFromOutsideViewport");
      })
    }, {
      default: m(() => [
        C(l.$slots, "default")
      ]),
      _: 3
    }));
  }
}), jh = /* @__PURE__ */ _({
  inheritAttrs: !1,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => ["F8"] },
    label: { type: [String, Function], default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(a) {
    const t = a, { hotkey: e, label: n } = te(t), { forwardRef: l, currentElement: s } = R(), { createCollection: r } = Te(), i = r(s), u = Wa(), d = A(() => u.toastCount.value > 0), p = B(), c = B(), f = A(() => e.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    _n(e.value, () => {
      s.value.focus();
    }), ae(() => {
      u.onViewportChange(s.value);
    }), de((y) => {
      const h = s.value;
      if (d.value && h) {
        const x = () => {
          if (!u.isClosePausedRef.value) {
            const D = new CustomEvent(cn);
            h.dispatchEvent(D), u.isClosePausedRef.value = !0;
          }
        }, P = () => {
          if (u.isClosePausedRef.value) {
            const D = new CustomEvent(pn);
            h.dispatchEvent(D), u.isClosePausedRef.value = !1;
          }
        }, $ = (D) => {
          !h.contains(D.relatedTarget) && P();
        }, b = () => {
          h.contains(document.activeElement) || P();
        }, S = (D) => {
          var M, V, I;
          const E = D.altKey || D.ctrlKey || D.metaKey;
          if (D.key === "Tab" && !E) {
            const L = document.activeElement, G = D.shiftKey;
            if (D.target === h && G) {
              (M = p.value) == null || M.focus();
              return;
            }
            const z = v({ tabbingDirection: G ? "backwards" : "forwards" }), F = z.findIndex((Y) => Y === L);
            ya(z.slice(F + 1)) ? D.preventDefault() : G ? (V = p.value) == null || V.focus() : (I = c.value) == null || I.focus();
          }
        };
        h.addEventListener("focusin", x), h.addEventListener("focusout", $), h.addEventListener("pointermove", x), h.addEventListener("pointerleave", b), h.addEventListener("keydown", S), window.addEventListener("blur", x), window.addEventListener("focus", P), y(() => {
          h.removeEventListener("focusin", x), h.removeEventListener("focusout", $), h.removeEventListener("pointermove", x), h.removeEventListener("pointerleave", b), h.removeEventListener("keydown", S), window.removeEventListener("blur", x), window.removeEventListener("focus", P);
        });
      }
    });
    function v({ tabbingDirection: y }) {
      const x = i.value.map((P) => {
        const $ = [P, ...Bn(P)];
        return y === "forwards" ? $ : $.reverse();
      });
      return (y === "forwards" ? x.reverse() : x).flat();
    }
    return (y, h) => (g(), w(o(Di), {
      role: "region",
      "aria-label": typeof o(n) == "string" ? o(n).replace("{hotkey}", f.value) : o(n)(f.value),
      tabindex: "-1",
      style: ge({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: d.value ? void 0 : "none"
      })
    }, {
      default: m(() => [
        d.value ? (g(), w(Ro, {
          key: 0,
          ref: (x) => {
            p.value = o(Ae)(x);
          },
          onFocusFromOutsideViewport: h[0] || (h[0] = () => {
            const x = v({
              tabbingDirection: "forwards"
            });
            o(ya)(x);
          })
        }, null, 512)) : re("", !0),
        j(o(O), k({
          ref: o(l),
          tabindex: "-1",
          as: y.as,
          "as-child": y.asChild
        }, y.$attrs), {
          default: m(() => [
            C(y.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"]),
        d.value ? (g(), w(Ro, {
          key: 1,
          ref: (x) => {
            c.value = o(Ae)(x);
          },
          onFocusFromOutsideViewport: h[1] || (h[1] = () => {
            const x = v({
              tabbingDirection: "backwards"
            });
            o(ya)(x);
          })
        }, null, 512)) : re("", !0)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
}), Gh = /* @__PURE__ */ _({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uh = /* @__PURE__ */ _({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(O), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jp = /* @__PURE__ */ _({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:pressed"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    const l = Q(e, "pressed", n, {
      defaultValue: e.defaultValue,
      passive: e.pressed === void 0
    });
    function s() {
      l.value = !l.value;
    }
    const r = A(() => l.value ? "on" : "off");
    return (i, u) => (g(), w(o(O), {
      type: i.as === "button" ? "button" : void 0,
      "as-child": e.asChild,
      as: i.as,
      "aria-pressed": o(l),
      "data-state": r.value,
      "data-disabled": i.disabled ? "" : void 0,
      disabled: i.disabled,
      onClick: s
    }, {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled"]));
  }
}), [Gp, Up] = q("ToggleGroupRoot"), qp = /* @__PURE__ */ _({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    orientation: {},
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    type: { default: "single" },
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, n = t, { loop: l, rovingFocus: s, disabled: r, dir: i } = te(e), u = Pe(i), { forwardRef: d } = R(), { modelValue: p, changeModelValue: c, isSingle: f } = ul(e, n);
    return Up({
      isSingle: f,
      modelValue: p,
      changeModelValue: c,
      dir: u,
      orientation: e.orientation,
      loop: l,
      rovingFocus: s,
      disabled: r
    }), (v, y) => (g(), w(Ge(o(s) ? o(Ft) : o(O)), {
      "as-child": "",
      orientation: o(s) ? v.orientation : void 0,
      dir: o(u),
      loop: o(s) ? o(l) : void 0
    }, {
      default: m(() => [
        j(o(O), {
          ref: o(d),
          role: "group",
          "as-child": v.asChild,
          as: v.as
        }, {
          default: m(() => [
            C(v.$slots, "default", { modelValue: o(p) })
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), Yp = /* @__PURE__ */ _({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = Gp(), n = A(() => {
      var i;
      return ((i = e.disabled) == null ? void 0 : i.value) || t.disabled;
    }), l = A(() => {
      var i;
      return (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);
    }), s = A(() => {
      var i;
      return e.isSingle.value ? e.modelValue.value === t.value : (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);
    }), { forwardRef: r } = R();
    return (i, u) => (g(), w(Ge(o(e).rovingFocus.value ? o(Lt) : o(O)), {
      "as-child": "",
      focusable: !n.value,
      active: l.value
    }, {
      default: m(() => [
        j(o(jp), k(t, {
          ref: o(r),
          disabled: n.value,
          pressed: s.value,
          "onUpdate:pressed": u[0] || (u[0] = (d) => o(e).changeModelValue(i.value))
        }), {
          default: m(() => [
            C(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["disabled", "pressed"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), [Rs, Xp] = q("ToolbarRoot"), qh = /* @__PURE__ */ _({
  __name: "ToolbarRoot",
  props: {
    orientation: { default: "horizontal" },
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { orientation: e, dir: n } = te(t), l = Pe(n), { forwardRef: s } = R();
    return Xp({ orientation: e, dir: l }), (r, i) => (g(), w(o(Ft), {
      "as-child": "",
      orientation: o(e),
      dir: o(l),
      loop: r.loop
    }, {
      default: m(() => [
        j(o(O), {
          ref: o(s),
          role: "toolbar",
          "aria-orientation": o(e),
          "as-child": r.asChild,
          as: r.as
        }, {
          default: m(() => [
            C(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-orientation", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), Zp = /* @__PURE__ */ _({
  __name: "ToolbarButton",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, { forwardRef: e } = R();
    return (n, l) => (g(), w(o(Lt), {
      "as-child": "",
      focusable: !n.disabled
    }, {
      default: m(() => [
        j(o(O), k({
          ref: o(e),
          type: n.as === "button" ? "button" : void 0
        }, t), {
          default: m(() => [
            C(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }, 8, ["focusable"]));
  }
}), Yh = /* @__PURE__ */ _({
  __name: "ToolbarLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(a) {
    const t = a, { forwardRef: e } = R();
    return (n, l) => (g(), w(o(Lt), {
      "as-child": "",
      focusable: ""
    }, {
      default: m(() => [
        j(o(O), k(t, {
          ref: o(e),
          onKeydown: l[0] || (l[0] = (s) => {
            var r;
            s.key === " " && ((r = s.currentTarget) == null || r.click());
          })
        }), {
          default: m(() => [
            C(n.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), Xh = /* @__PURE__ */ _({
  __name: "ToolbarToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = Rs(), s = $e(n);
    return R(), (r, i) => (g(), w(o(qp), k({ ...e, ...o(s) }, {
      "data-orientation": o(l).orientation.value,
      dir: o(l).dir.value,
      "roving-focus": !1
    }), {
      default: m(() => [
        C(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-orientation", "dir"]));
  }
}), Zh = /* @__PURE__ */ _({
  __name: "ToolbarToggleItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, { forwardRef: e } = R();
    return (n, l) => (g(), w(Zp, { "as-child": "" }, {
      default: m(() => [
        j(o(Yp), k(t, { ref: o(e) }), {
          default: m(() => [
            C(n.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), Jh = /* @__PURE__ */ _({
  __name: "ToolbarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(a) {
    const t = a, e = Rs();
    return R(), (n, l) => (g(), w(Jl, {
      orientation: o(e).orientation.value,
      "as-child": t.asChild,
      as: n.as
    }, {
      default: m(() => [
        C(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["orientation", "as-child", "as"]));
  }
}), As = "tooltip.open", [uo, Jp] = q("TooltipProvider"), Qh = /* @__PURE__ */ _({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 },
    disableClosingTrigger: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }
  },
  setup(a) {
    const t = a, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: l, disableClosingTrigger: s, ignoreNonKeyboardFocus: r } = te(t);
    R();
    const i = B(!0), u = B(!1), { start: d, stop: p } = Cn(() => {
      i.value = !0;
    }, n, { immediate: !1 });
    return Jp({
      isOpenDelayed: i,
      delayDuration: e,
      onOpen() {
        p(), i.value = !1;
      },
      onClose() {
        d();
      },
      isPointerInTransitRef: u,
      disableHoverableContent: l,
      disableClosingTrigger: s,
      ignoreNonKeyboardFocus: r
    }), (c, f) => C(c.$slots, "default");
  }
}), [ja, Qp] = q("TooltipRoot"), ey = /* @__PURE__ */ _({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 },
    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(a, { emit: t }) {
    const e = a, n = t;
    R();
    const l = uo(), s = A(() => e.disableHoverableContent ?? l.disableHoverableContent.value), r = A(() => e.disableClosingTrigger ?? l.disableClosingTrigger.value), i = A(() => e.delayDuration ?? l.delayDuration.value), u = A(() => e.ignoreNonKeyboardFocus ?? l.ignoreNonKeyboardFocus.value), d = Q(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    J(d, ($) => {
      l.onClose && ($ ? (l.onOpen(), document.dispatchEvent(new CustomEvent(As))) : l.onClose());
    });
    const p = B(!1), c = B(), f = A(() => d.value ? p.value ? "delayed-open" : "instant-open" : "closed"), { start: v, stop: y } = Cn(() => {
      p.value = !0, d.value = !0;
    }, i, { immediate: !1 });
    function h() {
      y(), p.value = !1, d.value = !0;
    }
    function x() {
      y(), d.value = !1;
    }
    function P() {
      v();
    }
    return Qp({
      contentId: "",
      open: d,
      stateAttribute: f,
      trigger: c,
      onTriggerChange($) {
        c.value = $;
      },
      onTriggerEnter() {
        l.isOpenDelayed.value ? P() : h();
      },
      onTriggerLeave() {
        s.value ? x() : y();
      },
      onOpen: h,
      onClose: x,
      disableHoverableContent: s,
      disableClosingTrigger: r,
      ignoreNonKeyboardFocus: u
    }), ($, b) => (g(), w(o(_t), null, {
      default: m(() => [
        C($.$slots, "default")
      ]),
      _: 3
    }));
  }
}), ty = /* @__PURE__ */ _({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(a) {
    const t = a, e = ja(), n = uo();
    e.contentId || (e.contentId = ve(void 0, "radix-vue-tooltip-content"));
    const { forwardRef: l, currentElement: s } = R(), r = B(!1), i = B(!1);
    function u() {
      r.value = !1;
    }
    function d() {
      r.value = !0, document.addEventListener("pointerup", u, { once: !0 });
    }
    return ae(() => {
      e.onTriggerChange(s.value);
    }), (p, c) => (g(), w(o(wt), { "as-child": "" }, {
      default: m(() => [
        j(o(O), {
          ref: o(l),
          "aria-describedby": o(e).open.value ? o(e).contentId : void 0,
          "data-state": o(e).stateAttribute.value,
          as: p.as,
          "as-child": t.asChild,
          onPointermove: c[0] || (c[0] = (f) => {
            f.pointerType !== "touch" && !i.value && !o(n).isPointerInTransitRef.value && (o(e).onTriggerEnter(), i.value = !0);
          }),
          onPointerleave: c[1] || (c[1] = (f) => {
            o(e).onTriggerLeave(), i.value = !1;
          }),
          onPointerdown: d,
          onFocus: c[2] || (c[2] = (f) => {
            var v, y;
            r.value || o(e).ignoreNonKeyboardFocus.value && !((y = (v = f.target).matches) != null && y.call(v, ":focus-visible")) || o(e).onOpen();
          }),
          onBlur: c[3] || (c[3] = (f) => o(e).onClose()),
          onClick: c[4] || (c[4] = () => {
            o(e).disableClosingTrigger.value || o(e).onClose();
          })
        }, {
          default: m(() => [
            C(p.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), Ts = /* @__PURE__ */ _({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = ja(), { forwardRef: s } = R(), r = Ko(), i = A(() => {
      var p;
      return (p = r.default) == null ? void 0 : p.call(r);
    }), u = A(() => {
      var f;
      if (e.ariaLabel)
        return e.ariaLabel;
      let p = "";
      function c(v) {
        typeof v.children == "string" ? p += v.children : Array.isArray(v.children) && v.children.forEach((y) => c(y));
      }
      return (f = i.value) == null || f.forEach((v) => c(v)), p;
    }), d = A(() => {
      const { ariaLabel: p, ...c } = e;
      return c;
    });
    return ae(() => {
      ot(window, "scroll", (p) => {
        const c = p.target;
        c != null && c.contains(l.trigger.value) && l.onClose();
      }), ot(window, As, l.onClose);
    }), (p, c) => (g(), w(o(dt), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: c[0] || (c[0] = (f) => n("escapeKeyDown", f)),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        var v;
        o(l).disableClosingTrigger.value && ((v = o(l).trigger.value) != null && v.contains(f.target)) && f.preventDefault(), n("pointerDownOutside", f);
      }),
      onFocusOutside: c[2] || (c[2] = ye(() => {
      }, ["prevent"])),
      onDismiss: c[3] || (c[3] = (f) => o(l).onClose())
    }, {
      default: m(() => [
        j(o(ht), k({
          ref: o(s),
          "data-state": o(l).stateAttribute.value
        }, { ...p.$attrs, ...d.value }, { style: {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        } }), {
          default: m(() => [
            C(p.$slots, "default"),
            j(o(Vt), {
              id: o(l).contentId,
              role: "tooltip"
            }, {
              default: m(() => [
                me(ke(u.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }));
  }
}), ef = /* @__PURE__ */ _({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  setup(a) {
    const e = bt(a), { forwardRef: n, currentElement: l } = R(), { trigger: s, onClose: r } = ja(), i = uo(), { isPointerInTransit: u, onPointerExit: d } = nl(s, l);
    return i.isPointerInTransitRef = u, d(() => {
      r();
    }), (p, c) => (g(), w(Ts, k({ ref: o(n) }, o(e)), {
      default: m(() => [
        C(p.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ay = /* @__PURE__ */ _({
  __name: "TooltipContent",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(a, { emit: t }) {
    const e = a, n = t, l = ja(), s = be(e, n), { forwardRef: r } = R();
    return (i, u) => o(l).open.value ? (g(), w(Ge(o(l).disableHoverableContent.value ? Ts : ef), k({
      key: 0,
      ref: o(r)
    }, o(s)), {
      default: m(() => [
        C(i.$slots, "default")
      ]),
      _: 3
    }, 16)) : re("", !0);
  }
}), ny = /* @__PURE__ */ _({
  __name: "TooltipArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(a) {
    const t = a;
    return R(), (e, n) => (g(), w(o(Mt), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), oy = /* @__PURE__ */ _({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(a) {
    const t = a;
    return (e, n) => (g(), w(o(ut), N(K(t)), {
      default: m(() => [
        C(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
export {
  uf as AccordionContent,
  df as AccordionHeader,
  rf as AccordionItem,
  sf as AccordionRoot,
  cf as AccordionTrigger,
  _f as AlertDialogAction,
  gf as AlertDialogCancel,
  hf as AlertDialogContent,
  Cf as AlertDialogDescription,
  yf as AlertDialogOverlay,
  mf as AlertDialogPortal,
  ff as AlertDialogRoot,
  bf as AlertDialogTitle,
  vf as AlertDialogTrigger,
  wf as AspectRatio,
  Sf as AvatarFallback,
  Pf as AvatarImage,
  xf as AvatarRoot,
  su as CalendarCell,
  fu as CalendarCellTrigger,
  lu as CalendarGrid,
  cu as CalendarGridBody,
  du as CalendarGridHead,
  pu as CalendarGridRow,
  ru as CalendarHeadCell,
  nu as CalendarHeader,
  ou as CalendarHeading,
  iu as CalendarNext,
  uu as CalendarPrev,
  au as CalendarRoot,
  $f as CheckboxIndicator,
  Df as CheckboxRoot,
  vi as CollapsibleContent,
  ci as CollapsibleRoot,
  pi as CollapsibleTrigger,
  Rf as ComboboxAnchor,
  zf as ComboboxArrow,
  Tf as ComboboxCancel,
  kf as ComboboxContent,
  Mf as ComboboxEmpty,
  If as ComboboxGroup,
  Bf as ComboboxInput,
  Ff as ComboboxItem,
  Lf as ComboboxItemIndicator,
  Of as ComboboxLabel,
  Kf as ComboboxPortal,
  Ef as ComboboxRoot,
  Nf as ComboboxSeparator,
  Af as ComboboxTrigger,
  Vf as ComboboxViewport,
  of as ConfigProvider,
  Uf as ContextMenuArrow,
  Zf as ContextMenuCheckboxItem,
  Gf as ContextMenuContent,
  Yf as ContextMenuGroup,
  qf as ContextMenuItem,
  Jf as ContextMenuItemIndicator,
  Qf as ContextMenuLabel,
  jf as ContextMenuPortal,
  ev as ContextMenuRadioGroup,
  tv as ContextMenuRadioItem,
  Hf as ContextMenuRoot,
  Xf as ContextMenuSeparator,
  av as ContextMenuSub,
  nv as ContextMenuSubContent,
  ov as ContextMenuSubTrigger,
  Wf as ContextMenuTrigger,
  yd as DateFieldInput,
  sd as DateFieldRoot,
  Cv as DatePickerAnchor,
  _v as DatePickerArrow,
  gv as DatePickerCalendar,
  iv as DatePickerCell,
  mv as DatePickerCellTrigger,
  wv as DatePickerClose,
  Pv as DatePickerContent,
  bv as DatePickerField,
  rv as DatePickerGrid,
  fv as DatePickerGridBody,
  pv as DatePickerGridHead,
  vv as DatePickerGridRow,
  uv as DatePickerHeadCell,
  lv as DatePickerHeader,
  sv as DatePickerHeading,
  hv as DatePickerInput,
  dv as DatePickerNext,
  cv as DatePickerPrev,
  yv as DatePickerRoot,
  xv as DatePickerTrigger,
  Pd as DateRangeFieldInput,
  xd as DateRangeFieldRoot,
  Nv as DateRangePickerAnchor,
  zv as DateRangePickerArrow,
  Fv as DateRangePickerCalendar,
  Ev as DateRangePickerCell,
  kv as DateRangePickerCellTrigger,
  Kv as DateRangePickerClose,
  Wv as DateRangePickerContent,
  Lv as DateRangePickerField,
  $v as DateRangePickerGrid,
  Iv as DateRangePickerGridBody,
  Tv as DateRangePickerGridHead,
  Ov as DateRangePickerGridRow,
  Bv as DateRangePickerHeadCell,
  Sv as DateRangePickerHeader,
  Dv as DateRangePickerHeading,
  Mv as DateRangePickerInput,
  Rv as DateRangePickerNext,
  Av as DateRangePickerPrev,
  Vv as DateRangePickerRoot,
  Hv as DateRangePickerTrigger,
  fl as DialogClose,
  Hi as DialogContent,
  Ui as DialogDescription,
  ji as DialogOverlay,
  pf as DialogPortal,
  Ci as DialogRoot,
  Gi as DialogTitle,
  _i as DialogTrigger,
  Yv as DropdownMenuArrow,
  Qv as DropdownMenuCheckboxItem,
  qv as DropdownMenuContent,
  Zv as DropdownMenuGroup,
  Xv as DropdownMenuItem,
  em as DropdownMenuItemIndicator,
  tm as DropdownMenuLabel,
  Uv as DropdownMenuPortal,
  am as DropdownMenuRadioGroup,
  nm as DropdownMenuRadioItem,
  jv as DropdownMenuRoot,
  Jv as DropdownMenuSeparator,
  om as DropdownMenuSub,
  lm as DropdownMenuSubContent,
  sm as DropdownMenuSubTrigger,
  Gv as DropdownMenuTrigger,
  cm as HoverCardArrow,
  dm as HoverCardContent,
  um as HoverCardPortal,
  rm as HoverCardRoot,
  im as HoverCardTrigger,
  pm as Label,
  gm as MenubarArrow,
  wm as MenubarCheckboxItem,
  ym as MenubarContent,
  Cm as MenubarGroup,
  bm as MenubarItem,
  xm as MenubarItemIndicator,
  Pm as MenubarLabel,
  vm as MenubarMenu,
  hm as MenubarPortal,
  Sm as MenubarRadioGroup,
  Dm as MenubarRadioItem,
  fm as MenubarRoot,
  _m as MenubarSeparator,
  $m as MenubarSub,
  Em as MenubarSubContent,
  Bm as MenubarSubTrigger,
  mm as MenubarTrigger,
  Tm as NavigationMenuContent,
  Im as NavigationMenuIndicator,
  Am as NavigationMenuItem,
  Om as NavigationMenuLink,
  km as NavigationMenuList,
  Rm as NavigationMenuRoot,
  Mm as NavigationMenuSub,
  Vm as NavigationMenuTrigger,
  Fm as NavigationMenuViewport,
  Nm as PaginationEllipsis,
  zm as PaginationFirst,
  Km as PaginationLast,
  Hm as PaginationList,
  Wm as PaginationListItem,
  jm as PaginationNext,
  Gm as PaginationPrev,
  Lm as PaginationRoot,
  qm as PinInputInput,
  Um as PinInputRoot,
  Hl as PopoverAnchor,
  zl as PopoverArrow,
  Kl as PopoverClose,
  Nl as PopoverContent,
  Fl as PopoverPortal,
  Ml as PopoverRoot,
  Vl as PopoverTrigger,
  O as Primitive,
  Xm as ProgressIndicator,
  Ym as ProgressRoot,
  Qm as RadioGroupIndicator,
  Jm as RadioGroupItem,
  Zm as RadioGroupRoot,
  uc as RangeCalendarCell,
  hc as RangeCalendarCellTrigger,
  ic as RangeCalendarGrid,
  vc as RangeCalendarGridBody,
  fc as RangeCalendarGridHead,
  mc as RangeCalendarGridRow,
  dc as RangeCalendarHeadCell,
  sc as RangeCalendarHeader,
  rc as RangeCalendarHeading,
  cc as RangeCalendarNext,
  pc as RangeCalendarPrev,
  lc as RangeCalendarRoot,
  oh as ScrollAreaCorner,
  eh as ScrollAreaRoot,
  ah as ScrollAreaScrollbar,
  nh as ScrollAreaThumb,
  th as ScrollAreaViewport,
  uh as SelectArrow,
  ih as SelectContent,
  fh as SelectGroup,
  Ch as SelectIcon,
  ch as SelectItem,
  ph as SelectItemIndicator,
  mh as SelectItemText,
  vh as SelectLabel,
  rh as SelectPortal,
  lh as SelectRoot,
  gh as SelectScrollDownButton,
  yh as SelectScrollUpButton,
  dh as SelectSeparator,
  sh as SelectTrigger,
  bh as SelectValue,
  hh as SelectViewport,
  _h as Separator,
  Sh as SliderRange,
  wh as SliderRoot,
  xh as SliderThumb,
  Ph as SliderTrack,
  $n as Slot,
  Dh as SplitterGroup,
  $h as SplitterPanel,
  Eh as SplitterResizeHandle,
  Bh as SwitchRoot,
  Rh as SwitchThumb,
  Ih as TabsContent,
  kh as TabsIndicator,
  Th as TabsList,
  Ah as TabsRoot,
  Oh as TabsTrigger,
  zh as TagsInputClear,
  Vh as TagsInputInput,
  Fh as TagsInputItem,
  Nh as TagsInputItemDelete,
  Lh as TagsInputItemText,
  Mh as TagsInputRoot,
  Wh as ToastAction,
  Wp as ToastClose,
  Uh as ToastDescription,
  Kh as ToastProvider,
  Hh as ToastRoot,
  Gh as ToastTitle,
  jh as ToastViewport,
  jp as Toggle,
  Yp as ToggleGroupItem,
  qp as ToggleGroupRoot,
  Zp as ToolbarButton,
  Yh as ToolbarLink,
  qh as ToolbarRoot,
  Jh as ToolbarSeparator,
  Xh as ToolbarToggleGroup,
  Zh as ToolbarToggleItem,
  ny as TooltipArrow,
  ay as TooltipContent,
  oy as TooltipPortal,
  Qh as TooltipProvider,
  ey as TooltipRoot,
  ty as TooltipTrigger,
  Vt as VisuallyHidden,
  q as createContext,
  Ve as toDate,
  oa as useBodyScrollLock,
  xn as useDateFormatter,
  $e as useEmitAsProps,
  R as useForwardExpose,
  bt as useForwardProps,
  be as useForwardPropsEmits,
  ve as useId,
  sl as useStateMachine,
  lf as withDefault
};
