import type { PrimitiveProps } from '../Primitive';
import type { Direction } from '../shared/types';
import { type Ref } from 'vue';
export interface TagsInputRootProps extends PrimitiveProps {
    /** The controlled value of the tags input. Can be bind as `v-model`. */
    modelValue?: Array<string>;
    /** The value of the tags that should be added. Use when you do not need to control the state of the tags input */
    defaultValue?: Array<string>;
    /** When `true`, allow adding tags on paste. Work in conjunction with delimiter prop. */
    addOnPaste?: boolean;
    /** When `true` allow adding tags on tab keydown */
    addOnTab?: boolean;
    /** When `true` allow adding tags blur input */
    addOnBlur?: boolean;
    /** When `true`, allow duplicated tags. */
    duplicate?: boolean;
    /** When `true`, prevents the user from interacting with the tags input. */
    disabled?: boolean;
    /** The character to trigger the addition of a new tag. Also used to split tags for `@paste` event */
    delimiter?: string;
    /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `DirectionProvider` or assumes LTR (left-to-right) reading mode. */
    dir?: Direction;
    /** Maximum number of tags. */
    max?: number;
    /** When `true`, indicates that the user must add the tags input before the owning form can be submitted. */
    required?: boolean;
    /** The name of the tags input submitted with its owning form as part of a name/value pair. */
    name?: string;
    id?: string;
}
export type TagsInputRootEmits = {
    /** Event handler called when the value changes */
    'update:modelValue': [payload: Array<string>];
    /** Event handler called when the value is invalid */
    'invalid': [payload: string];
};
export interface TagsInputRootContext {
    modelValue: Ref<Array<string>>;
    onAddValue: (payload: string) => boolean;
    onRemoveValue: (index: number) => void;
    onInputKeydown: (event: KeyboardEvent) => void;
    selectedElement: Ref<HTMLElement | undefined>;
    isInvalidInput: Ref<boolean>;
    addOnPaste: Ref<boolean>;
    addOnTab: Ref<boolean>;
    addOnBlur: Ref<boolean>;
    disabled: Ref<boolean>;
    delimiter: Ref<string>;
    dir: Ref<Direction>;
    max: Ref<number>;
    id: Ref<string | undefined> | undefined;
}
export declare const injectTagsInputRootContext: <T extends TagsInputRootContext | null | undefined = TagsInputRootContext>(fallback?: T | undefined) => T extends null ? TagsInputRootContext | null : TagsInputRootContext, provideTagsInputRootContext: (contextValue: TagsInputRootContext) => TagsInputRootContext;
declare const _default: __VLS_WithTemplateSlots<import("vue").DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<TagsInputRootProps>, {
    defaultValue: () => never[];
    delimiter: string;
    max: number;
}>, {}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
    invalid: (payload: string) => void;
    "update:modelValue": (payload: string[]) => void;
}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<TagsInputRootProps>, {
    defaultValue: () => never[];
    delimiter: string;
    max: number;
}>>> & {
    onInvalid?: ((payload: string) => any) | undefined;
    "onUpdate:modelValue"?: ((payload: string[]) => any) | undefined;
}, {
    defaultValue: string[];
    max: number;
    delimiter: string;
}, {}>, Readonly<{
    default(props: {
        /** Current input values */
        modelValue: string[];
    }): any;
}> & {
    default(props: {
        /** Current input values */
        modelValue: string[];
    }): any;
}>;
export default _default;
type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
type __VLS_TypePropsToRuntimeProps<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? {
        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
    } : {
        type: import('vue').PropType<T[K]>;
        required: true;
    };
};
type __VLS_WithDefaults<P, D> = {
    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
        default: D[K];
    }> : P[K];
};
type __VLS_Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
type __VLS_WithTemplateSlots<T, S> = T & {
    new (): {
        $slots: S;
    };
};
